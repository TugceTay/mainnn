//=============================================================================
// This source code is a part of TatukGIS Developer Kernel.
// DK11.85.0.33382-Unstable2
// (c)2000-2023 TatukGIS. ALL RIGHTS RESERVED.
//
// This file is uniquely watermarked for licensed user:
// 
// Any unauthorized use this file can be traced back to the licensed user,
// who may be held accountable.
//=============================================================================
{
  Encapsulation of a Vector Layer.

  Consists also of basic geometry objects (Arc, Point, Polygon).
}

{$IFDEF DCC}
  unit Lider.CG.GIS.GeoLayerVector ;
  {$HPPEMIT '#pragma link "Lider.CG.GIS.GeoLayerVector"'}
{$ENDIF}
{$IFDEF CLR}
  namespace TatukGIS.NDK ;
  {$DELPHICOMPATIBILITY ON}
{$ENDIF}
{$IFDEF JAVA}
  namespace tatukgis.jdk ;
{$ENDIF}
{$IFDEF COCOA}
  namespace TatukGIS.OSDK ;
{$ENDIF}
{$IFDEF ISLAND}
  namespace TatukGIS ;
{$ENDIF}

{$INCLUDE Lider.CG.GIS.GeoInclude.inc}

{$DEFINE RECOMMENDED}

interface

{$IFDEF CLR}
  uses
    System.Data,
    System.Text,
    System.Collections.Generic,
    System.Collections,
    {$IFDEF MSWINDOWS}
      ADODB,
    {$ENDIF}
    TatukGIS.RTL;
{$ENDIF}
{$IFDEF DCC}
  uses
    System.Classes,
    System.SysUtils,
    System.Math,
    System.Variants,
    System.SyncObjs,
    System.Types,
    {$IFNDEF GIS_NOADO_JOIN}
      {$IFDEF ADOINTUNIT}
        Winapi.ADOint,
      {$ELSE}
        Lider.CG.GIS.GeoAdoInt,
      {$ENDIF}
    {$ENDIF}
    {$IFNDEF GIS_NODB}
      Data.DB,
    {$ENDIF}
    System.Generics.Collections,
    System.Generics.Defaults,
    {$IFDEF GIS_PDK}
      PythonEngine,
    {$ENDIF}

    Lider.CG.GIS.GeoRtl,
    Lider.CG.GIS.GeoConfigIni,
    Lider.CG.GIS.GeoInterfaces,
    Lider.CG.GIS.GeoClasses,
    Lider.CG.GIS.GeoTypes,
    Lider.CG.GIS.GeoLayer,
    Lider.CG.GIS.GeoFunctions,
    Lider.CG.GIS.GeoConfig,
    Lider.CG.GIS.GeoParams,
    Lider.CG.GIS.GeoSqlQuery,
    Lider.CG.GIS.GeoRTree,
    Lider.CG.GIS.GeoTypesUI,
    Lider.CG.GIS.GeoCsSystems ;
{$ENDIF}
{$IFDEF JAVA}
  uses
    remobjects.elements.rtl.*,
    tatukgis.rtl ;
{$ENDIF}
{$IFDEF ISLAND}
  uses
    TatukGIS.RTL ;
{$ENDIF}

type

{$REGION 'Forwarded types'}

  // encapsulation of layer
  TGIS_LayerVector = class ;

  // encapsulation of layer enumerator
  TGIS_LayerVectorEnumerator = class ;

  // encapsulation of layer enumerator factory
  TGIS_LayerVectorEnumeratorFactory = class ;

  // encapsulation of shape aggregation processors
  TGIS_DynamicAggregatorAbstract = class ;
  TGIS_DynamicAggregatorAbstractClass = class of TGIS_DynamicAggregatorAbstract ;

  // encapsulation of list of selected shapes
  TGIS_SelectedShapeList = class ;

  // encapsulation of shape
  TGIS_Shape = class ;
  TGIS_ShapeClass = class of TGIS_Shape ;

  // encapsulation of single point
  TGIS_ShapePoint = class ;

  // encapsulation of multi-point
  TGIS_ShapeMultiPoint = class ;

  // encapsulation of lines
  TGIS_ShapeArc = class ;

  // encapsulation of polygons
  TGIS_ShapePolygon = class ;

  // encapsulation of list of shapes
  TGIS_ShapeList = class ;

{$ENDREGION 'Forwarded types'}

{$REGION 'Events declaration'}
  {$IFDEF OXYGENE}
    /// <summary>
    ///   Provides data for the shape event.
    /// </summary>
    TGIS_ShapeEventArgs = public class ( EventArgs )

      // properties internal value
      {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}
        FShape : TGIS_Shape ;

      public
        /// <summary>
        ///   Create an event object.
        /// </summary>
        /// <param name="_shape">
        ///   shape to which event is related
        /// </param>
        constructor Create  ( const _shape : TGIS_Shape
                            ) ;

      public
        /// <summary>
        ///   Shape object.
        /// </summary>
        property Shape      : TGIS_Shape
                              read FShape ;
    end ;

    /// <summary>
    ///   Delegate for ShapeEvent.
    /// </summary>
    /// <param name="_sender">
    ///   sender object
    /// </param>
    /// <param name="_e">
    ///   event object
    /// </param>
    TGIS_ShapeEvent = public procedure(
      _sender : Object ;
      _e      : TGIS_ShapeEventArgs
    ) of object ;

  {$ELSE}

    /// <summary>
    ///   Standard event for PaintXXXX.
    /// </summary>
    /// <param name="_sender">
    ///   sender object
    /// </param>
    /// <param name="_shape">
    ///   shape to which event is related
    /// </param>
    {$IFDEF GENXDK}
      TGIS_ShapeEvent = procedure(
        var _translated : Boolean ;
            _sender     : TObject ;
            _shape      : TGIS_Shape
      ) of object ;
    {$ELSE}
      TGIS_ShapeEvent = procedure(
        _sender     : TObject ;
        _shape      : TGIS_Shape
      ) of object ;
    {$ENDIF}
  {$ENDIF}

  {$IFDEF OXYGENE}
    /// <summary>
    ///   Provides data for the ShapePosEvent.
    /// </summary>
    TGIS_ShapePosEventArgs = public class ( EventArgs )

      // properties internal value
      {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}
        FShape  : TGIS_Shape ;
        FPos    : TGIS_LabelPositions ;
        {$IFDEF JAVA}
          FPoint  : TPoint ;
          FRect   : TRect ;
        {$ENDIF}
        {$IFDEF CLR}
          FPoint  : System.Drawing.Point ;
          FRect   : System.Drawing.Rectangle ;
        {$ENDIF}
        {$IFDEF ISLAND}
          FPoint  : TPoint ;
          FRect   : TRect ;
        {$ENDIF}
      public
        /// <summary>
        ///   Create an event object.
        /// </summary>
        /// <param name="_shape">
        ///   shape to which event is related
        /// </param>
        /// <param name="_pos">
        ///   desired position of label
        /// </param>
        /// <param name="_pt">
        ///   label position; can be modified
        /// </param>
        /// <param name="_rct">
        ///   Precalculated label rectangle; use a a hint for label size
        /// </param>
        constructor Create  ( const _shape : TGIS_Shape ;
                              const _pos   : TGIS_LabelPositions ;
                              {$IFDEF JAVA}
                                const _pt    : TPoint ;
                                const _rct   : TRect
                              {$ENDIF}
                              {$IFDEF CLR}
                                const _pt    : System.Drawing.Point ;
                                const _rct   : System.Drawing.Rectangle
                              {$ENDIF}
                              {$IFDEF ISLAND}
                                const _pt    : TPoint ;
                                const _rct   : TRect
                              {$ENDIF}
                            ) ;

      public
        /// <summary>
        ///   Shape object.
        /// </summary>
        property Shape      : TGIS_Shape
                              read  FShape ;

        /// <summary>
        ///   Desired position of label
        /// </summary>
        property Pos        : TGIS_LabelPositions
                              read  FPos ;
        {$IFDEF JAVA}
          /// <summary>
          ///   label position; can be modified
          /// </summary>
          property Point    : TPoint
                              read  FPoint
                              write FPoint ;

          /// <summary>
          ///   Pre-calculated label rectangle; use a a hint for label size
          /// </summary>
          property Rect     : TRect
                              read  FRect ;
        {$ENDIF}
        {$IFDEF CLR}
          /// <summary>
          ///   label position; can be modified
          /// </summary>
          property Point    : System.Drawing.Point
                              read  FPoint
                              write FPoint ;
          /// <summary>
          ///   Pre-calculated label rectangle; use a a hint for label size
          /// </summary>
          property Rect     : System.Drawing.Rectangle
                              read  FRect ;
        {$ENDIF}
    end ;

    /// <summary>
    ///   Standard event for OnPaintLabelPos. Label position can be modified
    ///   by changing _pt value.
    /// </summary>
    /// <param name="_sender">
    ///   sender object
    /// </param>
    /// <param name="_e">
    ///   shape position args
    /// </param>
    TGIS_ShapePosEvent = public procedure(
      _sender : Object ;
      _e : TGIS_ShapePosEventArgs
    ) of object ;
  {$ELSE}

    /// <summary>
    ///   Standard event for OnPaintLabelPos. Label position can be modified
    ///   by changing _pt value.
    /// </summary>
    /// <param name="_sender">
    ///   sender object
    /// </param>
    /// <param name="_shape">
    ///   shape to which event is related
    /// </param>
    /// <param name="_pos">
    ///   desired position of label
    /// </param>
    /// <param name="_pt">
    ///   label position; can be modified
    /// </param>
    /// <param name="_rct">
    ///   Precalculated label rectangle; use a a hint for label size
    /// </param>
    TGIS_ShapePosEvent = procedure(
            {$IFDEF GENXDK}
              var _translated : Boolean ;
            {$ENDIF}
            _sender     : TObject            ;
            _shape      : TGIS_Shape         ;
            _pos        : TGIS_LabelPosition ;
      var   _pt         : TPoint             ;
      const _rct        : TRect
    ) of object ;
  {$ENDIF}

  /// <summary>
  ///   Standard event for CursorXXX events
  /// </summary>
  /// <param name="_sender">
  ///   sender object
  /// </param>
  /// <param name="_cursor">
  ///   cursor number
  /// </param>
  TGIS_CursorEvent = {$IFDEF OXYGENE} public {$ENDIF} procedure(
    _sender : TObject ;
    _cursor : Integer
  ) of object ;

  /// <summary>
  ///   Callback prototype for TGIS_LayerVector.ForEach function.
  /// </summary>
  /// <param name="_shp">
  ///   shape object
  /// </param>
  /// <param name="_abort">
  ///   if true then operation should be aborted
  /// </param>
  TGIS_ForEachShapeEvent = {$IFDEF OXYGENE} public {$ENDIF} procedure(
         _shp   : TGIS_Shape ;
    var _abort : Boolean
  ) of object ;

  {$IFDEF OXYGENE}

    /// <summary>
    ///   Provides data for the shape event.
    /// </summary>
    TGIS_ShapeFieldChangeEventArgs = public class ( EventArgs )

      // properties internal value
      {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}
        FShape : TGIS_Shape ;
        FId    : Integer ;
      public
        /// <summary>
        ///   Create an event object.
        /// </summary>
        /// <param name="_shape">
        ///   shape object
        /// </param>
        /// <param name="_id">
        ///   field id
        /// </param>
        constructor Create  ( const _shape : TGIS_Shape ;
                              const _id    : Integer
                            ) ;

      public
        /// <summary>
        ///   Shape object.
        /// </summary>
        property Shape      : TGIS_Shape
                              read FShape ;

        /// <summary>
        ///   Field id.
        /// </summary>
        property Id         : Integer
                              read FId ;
    end ;

    /// <summary>
    ///   Callback prototype for TGIS_LayerVector.OnShapeAttributeChange
    ///   function.
    /// </summary>
    /// <param name="_sender">
    ///   sender object
    /// </param>
    /// <param name="_e">
    ///   event object
    /// </param>
    TGIS_ShapeFieldChangeEvent = public procedure(
      _sender : TObject    ;
      _e      : TGIS_ShapeFieldChangeEventArgs
    ) of object ;
  {$ELSE}

    /// <summary>
    ///   Callback prototype for TGIS_LayerVector.OnShapeAttributeChange
    ///   function.
    /// </summary>
    /// <param name="_sender">
    ///   sender object
    /// </param>
    /// <param name="_shp">
    ///   shape object
    /// </param>
    /// <param name="_id">
    ///   field id
    /// </param>
    TGIS_ShapeFieldChangeEvent = procedure(
      _sender : TObject    ;
      _shp    : TGIS_Shape ;
      _id     : Integer
    ) of object ;
  {$ENDIF}
{$ENDREGION 'Events declaration'}

{$REGION 'Nested types'}
  {$IFDEF OXYGENE}
    T_cursorState nested in TGIS_LayerVector = public {$IFDEF GIS_NORECORDS} class {$ELSE} record {$ENDIF}
      public

        /// <summary>
        ///   Is cursor in use.
        /// </summary>
        curInUse : Boolean ;

        /// <summary>
        ///   Last position in FItems. Used in MoveFirst, MoveNext
        ///   to access "in-memory" items.
        /// </summary>
        curPos : TGIS_Uid ;

        /// <summary>
        ///   Mode to find operations. If True, then used RTree.
        /// </summary>
        curFindMode : Boolean ;

        /// <summary>
        ///   Current shape. Layer access is based on record-by-record
        ///   access.
        /// </summary>
        curShape : TGIS_Shape ;

        /// <summary>
        ///   Value of query treated as a sub-scope of Scope.
        /// </summary>
        curDrawQuery : String ;

        /// <summary>
        ///   Value of an extent for the current scope.
        /// </summary>
        curExtent : TGIS_Extent ;

        /// <summary>
        ///   Value of an unprojected extent for the current scope.
        /// </summary>
        curRawExtent : TGIS_Extent ;

        /// <summary>
        ///   Value of query for the current scope.
        /// </summary>
        curQuery : String ;

        /// <summary>
        ///   Value of relation shape for the current scope.
        /// </summary>
        curRelShape : TGIS_Shape ;

        /// <summary>
        ///  Value of feature matrix for the current scope.
        /// </summary>
        curDE9IM  : String ;

        /// <summary>
        ///   Value of mode for the current scope. If True, then deleted
        ///   items will not be visible. Default True.
        /// </summary>
       curSkipDeleted : Boolean ;

       /// <summary>
       ///   Object for scope topological operations.
       /// </summary>
       curTopology : TObject ;

       /// <summary>
       ///  List of scope shape candidates. To be used by SQL Layers for
       ///  synchronizing between in-memory layers and layers fetch from
       ///  the server. Important for shapes not sorted by uid.
       /// </summary>
       curCandidates : TGIS_ShapeList ;

       /// <summary>
       ///   Active query object for the current scope
       /// </summary>
       curSqlQuery : TGIS_SqlQuery ;

       /// <summary>
       ///   Offset between real field number and mapped field number.
       /// </summary>
       curBindOffset : Integer ;

       /// <summary>
       ///   Last position in aggregatedItems. Used in MoveFirst, MoveNext
       ///   to access aggregated items.
       /// </summary>
       curAggregatedPos : Integer ;
    end ;

    T_helperFindField nested in TGIS_LayerVector = record
      public

        /// <summary>
        ///   List of field names.
        /// </summary>
       lstNames : TGIS_StringList ;

       /// <summary>
       ///   Last found position.
       /// </summary>
       iName    : Integer ;
    end ;

    T_helperFindFieldInternal nested in TGIS_LayerVector = record
      public

        lstNames : TGIS_StringList ;

        iName    : Integer ;
    end ;

    T_rJoin nested in TGIS_LayerVector = record
      public

        Active : Boolean ;
        Reset : Boolean ;
        LastUid : TGIS_Uid ;
        Primary : Integer ;

        {$IFDEF CLR}
          ForeignRowNET : DataRow ;
          ForeignColNET : DataColumn ;
          FieldsRowsNET : array of DataRow    ;
          FieldsColsNET : array of DataColumn ;
          RowNET : Integer ;
        {$ENDIF}
        {$IFNDEF GIS_NOADO_JOIN}
          ForeignADO : Field ;
          FieldsADO : array of Field ;
        {$ENDIF}
        {$IFNDEF GIS_NOJDBC}
          ForeignJDBC  : String            ;
          FieldsJDBC   : array of String   ;
          Columns      : array of Integer  ;
        {$ENDIF}
        {$IFNDEF GIS_NODB}
          ForeignDB : TField ;
          FieldsDB : array of TField ;
      {$ENDIF}

        Prev : Variant ;
    end ;

    /// <summary>
    ///  Locked renderer values.
    /// </summary>
    T_rLockedRender nested in TGIS_LayerVector = {$IFDEF GIS_NORECORDS} class {$ELSE} record {$ENDIF}
      public
        oldSerial : Integer ;

        // thread protection
        oLock   : TGIS_ThreadClass  ;

        // stored values
        pLine   : TGIS_ParamsLine   ;
        pArea   : TGIS_ParamsArea   ;
        pMarker : TGIS_ParamsMarker ;
        pLabel  : TGIS_ParamsLabel  ;
        pChart  : TGIS_ParamsChart  ;

        // default values
        dLine   : TGIS_ParamsLine   ;
        dArea   : TGIS_ParamsArea   ;
        dMarker : TGIS_ParamsMarker ;
        dLabel  : TGIS_ParamsLabel  ;
        dChart  : TGIS_ParamsChart  ;

        bLine   : Boolean ;
        bArea   : Boolean ;
        bMarker : Boolean ;
        bLabel  : Boolean ;
        bChart  : Boolean ;
    end ;

  {$ENDIF}
{$ENDREGION 'Nested types'}

{$REGION 'LayerVector and relative types'}
  /// <summary>
  ///   General layer class for vector layers. Must be derived to provide
  ///   file access.
  /// </summary>
  {$IFDEF ISLAND}[Export]{$ENDIF}
  TGIS_LayerVector = {$IFDEF OXYGENE} public {$ENDIF} class( TGIS_Layer )
    public
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}
      {$IFDEF OXYGENE}
        /// <summary>
        ///   Whole cursor status.
        /// </summary>
        cursorState : array of T_cursorState ;

        /// <summary>
        ///   Whole cursor status. To save state.
        /// </summary>
        cursorStateStore : array of T_cursorState ;
      {$ELSE}

        /// <summary>
        ///   Whole cursor status.
        /// </summary>
        cursorState,

        /// <summary>
        ///   Whole cursor status. To save state.
        /// </summary>
        cursorStateStore : array of record

          /// <summary>
          ///   Is cursor in use.
          /// </summary>
          curInUse : Boolean ;

          /// <summary>
          ///   Last position in FItems. Used in MoveFirst, MoveNext
          ///   to access "in-memory" items.
          /// </summary>
          curPos : TGIS_Uid ;

          /// <summary>
          ///   Mode to find operations. If True, then used RTree.
          /// </summary>
          curFindMode : Boolean ;

          /// <summary>
          ///   Current shape. Layer access is based on record-by-record
          ///   access.
          /// </summary>
          curShape : TGIS_Shape ;

          /// <summary>
          ///   Value of query treated as a sub-scope of Scope.
          /// </summary>
          curDrawQuery : String ;

          /// <summary>
          ///   Value of an extent for the current scope.
          /// </summary>
          curExtent : TGIS_Extent ;

          /// <summary>
          ///  Value of an unprojected extent for the current scope.
          /// </summary>
          curRawExtent : TGIS_Extent ;

          /// <summary>
          ///   Value of query for the current scope.
          /// </summary>
          curQuery : String ;

          /// <summary>
          ///   Value of relation shape for the current scope.
          /// </summary>
          curRelShape : TGIS_Shape ;

          /// <summary>
          ///   Value of feature matrix for the current scope.
          /// </summary>
          curDE9IM  : String ;

          /// <summary>
          ///   Value of mode for the current scope. If True, then deleted
          ///   items will not be visible. Default True.
          /// </summary>
          curSkipDeleted : Boolean ;

          /// <summary>
          ///   Object for scope topological operations.
          /// </summary>
          curTopology : TObject ;

          /// <summary>
          ///   List of scope shape candidates. To be used by SQL Layers for
          ///   synchronizing between in-memory layers and layers fetch from
          ///   the server. Important for shapes not sorted by uid.
          /// </summary>
          curCandidates : TGIS_ShapeList ;

          /// <summary>
          ///   Active query object for the current scope
          /// </summary>
          curSqlQuery : TGIS_SqlQuery ;

          /// <summary>
          ///   Offset between real field number and mapped field number.
          /// </summary>
          curBindOffset : Integer ;


          /// <summary>
          ///   Last position in aggregatedItems. Used in MoveFirst, MoveNext
          ///   to access aggregated items.
          /// </summary>
          curAggregatedPos : Integer ;
        end ;
      {$ENDIF}

    // properties internal value
    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}

      /// <summary>
      ///   If true then section should be rendered in natural order
      ///   in a multipass way.
      /// </summary>
      FMultipassRendering : Boolean ;

      /// <summary>
      ///   Scope value - used to limit the result.
      /// </summary>
      FScope : String ;

      /// <summary>
      ///   Scope value - used to limit the result.
      /// </summary>
      FScopeExtent : TGIS_Extent ;

      /// <summary>
      ///   List of all "in-memory" edited items.
      /// </summary>
      FItems : TGIS_ShapeList ;

      /// <summary>
      ///   List of all fields.
      /// </summary>
      FFields : TGIS_FieldInfoList ;

      /// <summary>
      ///   List of all virtual fields.
      /// </summary>
      FFieldsVirtual : TGIS_FieldInfoList ;

      /// <summary>
      ///   Default shape type for layer.
      /// </summary>
      FDefaultShapeType : TGIS_ShapeType ;

      /// <summary>
      ///   Default shape type for layer.
      /// </summary>
      FDefaultDimension : TGIS_DimensionType ;

      {$IFDEF CLR}
        /// <summary>
        ///   ADO.NET Query to be joined.
        /// </summary>
        FJoinNET : Object ;
      {$ENDIF}

      {$IFNDEF GIS_NOADO_JOIN}
        /// <summary>
        ///   ADO Query to be joined.
        /// </summary>
        FJoinADO :
          {$IFDEF Oxygene}
            Object ;
          {$ELSE}
            _Recordset ;
          {$ENDIF}
      {$ENDIF}
      {$IFNDEF GIS_NODB}
        /// <summary>
        ///   DB (TDataSet) Query to be joined.
        /// </summary>
        FJoinDB  : TDataSet ;
      {$ENDIF}
      {$IFDEF GIS_PDK}
        FJoinDBAPI2 :  PPyObject ;
      {$ENDIF}

      /// <summary>
      ///   Field from feature table that is to be joined. Field value
      ///   must be unique and be the same type as FJoinForeign. Table
      ///   must be ordered by this value.
      /// </summary>
      FJoinPrimary : String ;

      /// <summary>
      ///   Field from Query to be joined. Query must be ordered by this
      ///   value and be the same type as FJoinPrimary.
      /// </summary>
      FJoinForeign : String ;

      /// <summary>
      ///   Code page for JoinDB/JoinADO.
      /// </summary>
      FJoinCodePage : Integer ;

      /// <summary>
      ///   If True then only layer level params will be used.
      /// </summary>
      FIgnoreShapeParams : Boolean ;

      /// <summary>
      ///   Labeling mode metadata.
      /// </summary>
      FLabelingMode : Integer  ;

      /// <summary>
      ///   Symboling mode metadata.
      /// </summary>
      FSymbolingMode : Integer  ;

      /// <summary>
      ///   Dynamic aggregation processor.
      /// </summary>
      FDynamicAggregator : TGIS_DynamicAggregatorAbstract ;

      /// <summary>
      ///   If true than params style attribute field was defined.
      /// </summary>
      FUseShapeStyleField : Boolean ;

    // other internal values
    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}

      {$IFNDEF GIS_NOJDBC}
        /// <summary>
        ///   JDBC ResultSet to be joined.
        /// </summary>
        FJoinJDBC :
          {$IFDEF Oxygene}
            Object ;
          {$ELSE}
            _Recordset ;
          {$ENDIF}
        /// <summary>
        ///   JDBC Query to be joined.
        /// </summary>
        FJoinJDBCQuery : String  ;
      {$ENDIF}
      /// <summary>
      ///   List of objects to flash.
      /// </summary>
      oFlashQueue : TGIS_UidArray ;

      /// <summary>
      ///   Hint for label draw optimization (avoid unnecessary paint).
      /// </summary>
      labelHint : Boolean ;

      /// <summary>
      ///   Hint for chart draw optimization (avoid unnecessary paint).
      /// </summary>
      chartHint : Boolean ;

      /// <summary>
      ///   Named style for drawing.
      /// </summary>
      namedStyle : String ;

      /// <summary>
      ///   Helper for optimizing of FindField function.
      /// </summary>
      helperFindField : TDictionary< String, Integer > ;

      /// <summary>
      ///   Helper for optimizing of FindField function.
      /// </summary>
      helperFindFieldInternal : TDictionary< String, Integer > ;

      /// <summary>
      ///   List of aggregated items.
      /// </summary>
      aggregatedItems : TGIS_ShapeList ;

      /// <summary>
      ///   List of attributes of aggregated items.
      /// </summary>
      aggregatedItemsAttributes : TObjectList<TObject> ;

      /// <summary>
      ///   Shape type of aggregated items.
      /// </summary>
      aggregatorShapeType : TGIS_ShapeType ;

      /// <summary>
      ///   Params to be restored upon canceling of aggregation
      /// </summary>
      oldAggregatorParams : TGIS_ParamsList ;

      {$IFDEF OXYGENE}

        /// <summary>
        ///   Join internal values.
        /// </summary>
        rJoin : T_rJoin ;

      {$ELSE}

        /// <summary>
        ///   Join internal values.
        /// </summary>
        rJoin : record

          /// <summary>
          ///   If False, than join was disabled (because query was wrong etc).
          /// </summary>
          Active : Boolean ;

          /// <summary>
          ///   If True, than join should be resynchronized.
          /// </summary>
          Reset : Boolean ;

          /// <summary>
          ///   Uid of last proper synchronized join, or -1.
          /// </summary>
          LastUid : TGIS_Uid ;

          /// <summary>
          ///   Bound field for primary key.
          /// </summary>
          Primary : Integer ;

          {$IFDEF CLR}

            /// <summary>
            ///   Bound field for ADO.NET foreign key
            ///   (used when JoinNET = IDataReader).
            /// </summary>
            ForeignRowNET : DataRow ;

            /// <summary>
            ///   Bound field for ADO.NET foreign key
            ///   (used when JoinNET = DataTable).
            /// </summary>
            ForeignColNET : DataColumn ;

            /// <summary>
            ///   Bound fields for ADO.NET
            ///   (used when JoinNET = IDataReader).
            /// </summary>
            FieldsRowsNET : array of DataRow    ;

            /// <summary>
            ///   Bound fields for ADO.NET
            ///   (used when JoinNET = DataTable).
            /// </summary>
            FieldsColsNET : array of DataColumn ;

            /// <summary>
            ///   Current row
            ///   (used when JoinNET = DataTable).
            /// </summary>
            RowNET : Integer ;
          {$ENDIF}

          {$IFNDEF GIS_NOADO_JOIN}
            /// <summary>
            ///   Bound field for ADO foreign key.
            /// </summary>
            ForeignADO : Field ;

            /// <summary>
            ///   Bound fields for ADO.
            /// </summary>
            FieldsADO : array of Field ;
          {$ENDIF}
          {$IFNDEF GIS_NODB}

            /// <summary>
            ///   Bound field for DB foreign key.
            /// </summary>
            ForeignDB : TField ;

            /// <summary>
            ///   Bound field for DB.
            /// </summary>
            FieldsDB : array of TField ;
          {$ENDIF}

            /// <summary>
            ///   Previous primary key.
            /// </summary>
            Prev : Variant ;
        end ;
      {$ENDIF}

      {$IFDEF OXYGENE}

        /// <summary>
        ///   Locked renderer values.
        /// </summary>
        rLockedRender : T_rLockedRender ;
      {$ELSE}

        /// <summary>
        ///   Locked renderer values.
        /// </summary>
        rLockedRender : record
          oldSerial : Integer ;

          // thread protection
          oLock   : TGIS_ThreadClass  ;

          // stored values
          pLine   : TGIS_ParamsLine   ;
          pArea   : TGIS_ParamsArea   ;
          pMarker : TGIS_ParamsMarker ;
          pLabel  : TGIS_ParamsLabel  ;
          pChart  : TGIS_ParamsChart  ;

          // default values
          dLine   : TGIS_ParamsLine   ;
          dArea   : TGIS_ParamsArea   ;
          dMarker : TGIS_ParamsMarker ;
          dLabel  : TGIS_ParamsLabel  ;
          dChart  : TGIS_ParamsChart  ;

          bLine   : Boolean ;
          bArea   : Boolean ;
          bMarker : Boolean ;
          bLabel  : Boolean ;
          bChart  : Boolean ;
        end ;
      {$ENDIF}

    private
      /// <summary>
      ///   Color ramp zone index for last shape.
      /// </summary>
      lastColorRampZone : Integer ;

    // properties access function
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}

      function  fget_SupportedShapesAll : TGIS_ShapeTypes ; virtual;

      function  fget_DefaultDimension : TGIS_DimensionType ; virtual;
      procedure fset_DefaultDimension ( const _value : TGIS_DimensionType
                                      ) ; virtual;
      function  fget_DefaultShapeType : TGIS_ShapeType ; virtual;
      procedure fset_DefaultShapeType ( const _value : TGIS_ShapeType
                                      ) ; virtual;
      function  fget_ParamsVector     : TGIS_ParamsSectionVector ;
      procedure fset_ParamsVector     ( const _value : TGIS_ParamsSectionVector
                                      ) ;
      function  fget_SelectedList     : TGIS_SelectedShapeList; virtual;
      {$IFDEF CLR}
        procedure fset_JoinNET        ( const _value : Object
                                      ) ;
      {$ENDIF}
      {$IFNDEF GIS_NOADO_JOIN}
        {$IFDEF OXYGENE}
          procedure fset_JoinADO      ( const _value : Object
                                      ) ;
        {$ELSE}
          procedure fset_JoinADO      ( const _value : _Recordset
                                      ) ;
        {$ENDIF}
      {$ENDIF}
      {$IFNDEF GIS_NOJDBC}
          procedure fset_JoinJDBC     ( const _value : Object
                                      ) ;
          procedure fset_JoinJDBCQuery( const _value : String
                                      ) ;
      {$ENDIF}
      {$IFNDEF GIS_NODB}
        procedure fset_JoinDB         ( const _value : TDataSet
                                      ) ;
      {$ENDIF}
      {$IFDEF GIS_PDK}
        procedure fset_JoinDBAPI2     ( const _value : PPyObject
                                      ) ;
      {$ENDIF}
      procedure fset_JoinPrimary      ( const _value : String
                                      ) ;
      procedure fset_JoinForeign      ( const _value : String
                                      ) ;

    private

      procedure fset_DynamicAggregator( const _value : TGIS_DynamicAggregatorAbstract
                                      ) ;

    // properties internal value
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}

      /// <summary>
      ///   True if rtree is in use. Will be assigned by the property
      ///   UseRTree. Upon the running the setup procedure, it is decided
      ///   whether or not rtree must be created.
      /// </summary>
      FUseRTree : Boolean ;

      /// <summary>
      ///   True if rtree can not be enabled.
      /// </summary>
      FBlockRTree : Boolean ;

      /// <summary>
      ///   True if rtree file will be created in-memory. Only used when
      ///   opening the layer.
      /// </summary>
      FInMemoryRTree : Boolean ;

      /// <summary>
      ///   Rtree based index.
      /// </summary>
      FRTreeFile : TGIS_RTree ;

      /// <summary>
      ///   Pixel density. To avoid improper ZoomEx on ggdPrinter etc.
      /// </summary>
      FPixelsPerInch : Integer ;

      /// <summary>
      ///   Set of shapes supported by a layer.
      /// </summary>
      FSupportedShapes : TGIS_ShapeTypes ;

      /// <summary>
      ///   Set of dimensions supported by a layer.
      /// </summary>
      FSupportedDimensions : TGIS_DimensionTypes ;

      /// <summary>
      ///   List of uids of selected shapes.
      /// </summary>
      FSelectedList : TGIS_SelectedShapeList;

      /// <summary>
      ///   PaintShape event. Will be fired upon Shape.Paint.
      /// </summary>
      FOnPaintShape : TGIS_ShapeEvent ;

      /// <summary>
      ///   PaintShapeLabel event. Will be fired upon Shape.PaintLabel.
      /// </summary>
      FOnPaintShapeLabel : TGIS_ShapeEvent ;

      /// <summary>
      ///   PaintShapeChart event. Will be fired upon Shape.PaintChart.
      /// </summary>
      FOnPaintShapeChart : TGIS_ShapeEvent ;

      /// <summary>
      ///   ShapeLabelPos events. Will be fired before placing the label.
      /// </summary>
      FOnLabelPos          : TGIS_ShapePosEvent ;

      /// <summary>
      ///   CursorOpen event. Will be fired upon cursor open.
      /// </summary>
      FOnCursorOpen        : TGIS_CursorEvent ;

      /// <summary>
      ///   OnCursorClose event. Will be fired upon cursor close.
      /// </summary>
      FOnCursorClose       : TGIS_CursorEvent ;

      /// <summary>
      ///   OnCursorBeforeFetch event. Will be fired before data fetch in
      ///   CursorFirst method.
      /// </summary>
      FOnCursorBeforeFetch : TGIS_CursorEvent ;

      /// <summary>
      ///   OnCursorAfterFetch event. Will be fired after data fetch in
      ///   CursorFirst method.
      /// </summary>
      FOnCursorAfterFetch  : TGIS_CursorEvent ;

      /// <summary>
      ///   OnCursorInterrupt event. Will be fired after interrupting reading.
      /// </summary>
      FOnCursorInterrupt  : TGIS_CursorEvent ;

      /// <summary>
      ///   OnCursorShapeFetch event. Will be fired after shape fetch.
      /// </summary>
      FOnCursorShapeFetch  : TGIS_ShapeEvent ;

      /// <summary>
      ///   OnShapeGeometryChange event. Will be fired after a shape
      ///   geometry change.
      /// </summary>
      FOnShapeGeometryChange : TGIS_ShapeEvent ;

      /// <summary>
      ///   OnShapeFieldChange event. Will be fired after a shape field
      ///   change.
      /// </summary>
      FOnShapeFieldChange    : TGIS_ShapeFieldChangeEvent ;

    // properties access functions
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}

      function  fget_PathRTree     : String ; virtual;
      function  fget_UseRTree      : Boolean ; virtual;
      function  fget_RTree         : TGIS_RTree ; virtual;
      procedure fset_UseRTree      ( const _value  : Boolean
                                   ) ; virtual;
      function  fget_PathFLD       : String ; virtual  ;
      function  fget_PathFLDX      : String ; virtual  ;
      function  fget_Items         : TGIS_ShapeList     ; virtual;
      function  fget_Fields        : TGIS_FieldInfoList ; virtual;
      function  fget_FieldsVirtual : TGIS_FieldInfoList ; virtual;

    {$IFDEF JAVA}
      public
        {#gendoc:hide}
        procedure addPaintShapeEvent        ( const _e : TGIS_ShapeEvent
                                            ) ;
        {#gendoc:hide}
        procedure removePaintShapeEvent     ( const _e : TGIS_ShapeEvent
                                            ) ;
        {#gendoc:hide}
        procedure addPaintShapeLabelEvent   ( const _e : TGIS_ShapeEvent
                                            ) ;
        {#gendoc:hide}
        procedure removePaintShapeLabelEvent( const _e : TGIS_ShapeEvent
                                            ) ;
        {#gendoc:hide}
        procedure addPaintShapeChartEvent   ( const _e : TGIS_ShapeEvent
                                            ) ;
        {#gendoc:hide}
        procedure removePaintShapeChartEvent( const _e : TGIS_ShapeEvent
                                            ) ;
      {$ENDIF}


    // other variables
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}

      /// <summary>
      ///   SmartSize scaling factor (to scale between projected/unprojected
      ///   size.
      /// </summary>
      findSmartSizeFactor : Double ;

      /// <summary>
      ///   Old marker point screen coordinates (to filter drawing points).
      /// </summary>
      oldMarkerPoint : TGIS_Point ;

      /// <summary>
      ///   Internal status of IgnoreShapeParams property.
      /// </summary>
      bIgnoreShapeParams : Boolean ;

    // other functions
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}

      /// <summary>
      ///   Move to the first shape in the Layer.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      /// <param name="_viewerCS">
      ///   if True an the layer has been attached to the Viewer then
      ///   expected _extent units are in a Viewer coordinate space;
      ///   otherwise expected _extent units are in a Layer coordinate space
      /// </param>
      /// <param name="_extent">
      ///   extent of item to be found
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no all items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment; by default deleted items will be
      ///   ignored
      /// </param>
      /// <remarks>
      ///   Non internal version is unsafe in the event of any special
      ///   overrides such as in TGIS_LayerVector.FindNext.
      /// </remarks>
      procedure cursorFirstInternal( const _cursor      : Integer     ;
                                     const _viewerCS    : Boolean     ;
                                     const _extent      : TGIS_Extent ;
                                     const _query       : String      ;
                                     const _shape       : TGIS_Shape  ;
                                     const _de9im       : String      ;
                                     const _skipDeleted : Boolean
                                   ) ; virtual;

      /// <summary>
      ///   Move to next shape in Layer.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      procedure cursorNextInternal ( const _cursor      : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Has the end of shapes been reached?
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <returns>
      ///   True if EOF reached.
      /// </returns>
      function  cursorEofInternal  ( const _cursor      : Integer
                                   ) : Boolean ; virtual;

      /// <summary>
      ///   Get current shape.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <returns>
      ///   Current shape object or nil.
      /// </returns>
      function  cursorShapeInternal( const _cursor      : Integer
                                   ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Allocate new cursor. Cursor should be closes by calling
      ///   cursorClose().
      /// </summary>
      /// <returns>
      ///   Cursor number.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    Override this method in inherited class to provide your own
      ///    layer traversing method.
      ///    </note>
      ///   <note type="note">
      ///    Cursor number 0 is reserved for internal operation and will be
      ///    used by deprecated FindFirst..FindNext. Cursor number 0 will be
      ///    allocated upon layer creation.
      ///    </note>
      /// </remarks>
      function  cursorOpen         :  Integer ; virtual;

      /// <summary>
      ///   Free cursor allocated by cursorOpen().
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    Override cursorOpen(), cursorClose(), cursorFirst(),
      ///    cursorNext(), cursorClose() in an inherited class to provide
      ///    your own layer traversing method.
      ///    </note>
      /// </remarks>
      procedure cursorClose        ( const _cursor      : Integer
                                   ) ; virtual;


      /// <summary>
      ///   Store cursor state.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <remarks>
      ///   To be used if cursor must be reused in inherited layer.
      /// </remarks>
      procedure cursorStateSave    ( const _cursor      : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Restore cursor state to previously stored value.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <remarks>
      ///   To be used if cursor must be reused in inherited layer.
      /// </remarks>
      procedure cursorStateRestore ( const _cursor      : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Move to the first shape in the cursor.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      /// <param name="_extent">
      ///   extent of item to be found
      /// </param>
      /// <param name="_viewerCS">
      ///   if True an the layer has been attached to the Viewer then
      ///   expected _extent units are in a Viewer coordinate  space;
      ///   otherwise expected _extent units are in a Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no all items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment; by default deleted items will be
      ///   ignored
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    Override this method in inherited class to provide your own
      ///    layer traversing method.
      ///    </note>
      /// </remarks>
      procedure cursorFirst        ( const _cursor      : Integer     ;
                                     const _viewerCS    : Boolean     ;
                                     const _extent      : TGIS_Extent ;
                                     const _query       : String      ;
                                     const _shape       : TGIS_Shape  ;
                                     const _de9im       : String      ;
                                     const _skipDeleted : Boolean
                                   ) ; virtual;

      /// <summary>
      ///   Move to the next shape in the cursor.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    Override this method in inherited class to provide your own
      ///    layer traversing method.
      ///    </note>
      /// </remarks>
      procedure cursorNext         ( const _cursor      : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Is it the end of the shapes?
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <returns>
      ///    True if EOF has been reached.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    Override this method in inherited class to provide your own layer
      ///    </note>
      ///   <note type="note">
      ///    cursorEof() will provide proper value only for
      ///    cursorFirst..cursorNext. For cursorFindFirst..cursorFindNext
      ///    use value returned by those functions instead.
      ///    </note>
      /// </remarks>
      function  cursorEof          ( const _cursor      : Integer
                                   ) : Boolean ; virtual;

      /// <summary>
      ///   Get current shape.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///     cursorShape() will provide proper value only for
      ///     cursorFirst..cursorNext. For cursorFindFirst..cursorFindNext
      ///     use value returned by those functions instead.
      ///   </note>
      ///   Use this method to get access to layer shapes. We can locate a
      ///   shape, change or read its attributes, etc.
      /// </remarks>
      function  cursorShape        ( const _cursor      : Integer
                                   ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Get current shape.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    cursorShape() will provide proper value only for
      ///    cursorFirst..cursorNext. For cursorFindFirst..cursorFindNext
      ///    use value returned by those functions instead.
      ///    </note>
      ///   Use this method to get access to layer shapes. We can locate a
      ///   shape, change or read its attributes, etc..
      /// </remarks>
      function  cursorShapeEx      ( const _cursor      : Integer
                                   ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Find first occurrence of an item which meets extent and query.
      ///   Will use RTree if available.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      /// <param name="_extent">
      ///   extent of item to be found
      /// </param>
      /// <param name="_viewerCS">
      ///   if True an the layer has been attached to the Viewer then
      ///   expected _extent units are in a Viewer coordinate space;
      ///   otherwise expected _extent units are in a Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no all items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment; by default deleted items will be
      ///   ignored
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to find to the first shape in the layer matching
      ///   given criteria. Using _query param we can narrow the result of
      ///   the shape searching down to the minimum. This should speed up
      ///   our process of locating a desirable shape.
      /// </remarks>
      function  cursorFindFirst    ( const _cursor      : Integer     ;
                                     const _viewerCS    : Boolean     ;
                                     const _extent      : TGIS_Extent ;
                                     const _query       : String      ;
                                     const _shape       : TGIS_Shape  ;
                                     const _de9im       : String      ;
                                     const _skipDeleted : Boolean
                                   ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Find next occurrence of item defined in cursorFindFirst. Will
      ///   use RTree if available.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to find next shape in the layer matching given
      ///   criteria. We can move between shapes doing custom operations on
      ///   them.
      /// </remarks>
      function  cursorFindNext     ( const _cursor      : Integer
                                   ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Notify about interrupting reading inside a cursor.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      procedure cursorInterrupt    ( const _cursor      : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Notify about finishing reading inside a cursor.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      procedure cursorFinish       ( const _cursor      : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Get shape using bisection.
      /// </summary>
      /// <param name="_uid">
      ///   identifier /same as current record for SHP file/
      /// </param>
      /// <param name="_ipos">
      ///   position of the located element or position in which to insert
      /// </param>
      /// <returns>
      ///   True if shape was found.
      /// </returns>
      function  getShapePos        ( const _uid         : TGIS_Uid       ;
                                     var   _ipos        : Integer
                                   ) : Boolean ; virtual;

      /// <summary>
      ///   Prepare list of scope candidates for SQL Layers.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      /// <remarks>
      ///   Scope list is a list of in-memory shapes affected by scope.
      /// </remarks>
      procedure prepareCandidates  ( const _cursor      : Integer
                                   );

      /// <summary>
      ///   Remove shape from the candidate list.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      /// <param name="_shp">
      ///   shape to be removed from the list
      /// </param>
      /// <remarks>
      ///   shape candidate should be removed after being used in FindNext
      /// </remarks>
      procedure removeCandidate    ( const _cursor      : Integer ;
                                     const _shp         : TGIS_Shape
                                   ) ;

      /// <summary>
      ///   Provides next shape from the candidate list.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor identifier (see TGIS_LayerVector.cursorOpen)
      /// </param>
      /// <returns>
      ///  Shape itself or nil if end of list has been reached
      /// </returns>
      /// <remarks>
      ///   provided shape will be removed from candidate list
      /// </remarks>
      function  nextCandidate      ( const _cursor      : Integer
                                   ) : TGIS_Shape ;

      /// <summary>
      ///   Get the stored field value for a shape specified by unique
      ///   identifier.
      /// </summary>
      /// <param name="_uid">
      ///   shape uid for which field will be retrieved
      /// </param>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   Field value.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Override this in classes derived from GIS_LayerVector.
      ///   </para>
      ///   <para>
      ///     Non internal version is unsafe in the event of any special
      ///     override such as in TGIS_LayerVector.FindNext.
      ///   </para>
      /// </remarks>
      function  getFieldInternal   ( const _uid         : TGIS_Uid       ;
                                     const _name        : String      ;
                                     const _cursor      : Integer
                                   ) : Variant ; virtual;

      /// <summary>
      ///   Obtain a bind number for a given field name.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   Bind field id staring form 0 or -1 if not found.
      /// </returns>
      function  bindField          ( const _name        : String      ;
                                     const _cursor      : Integer
                                   ) : Integer ; virtual;

      /// <summary>
      ///   Obtain a bind number for a given field name.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   Bind field id staring form 0 or -1 if not found.
      /// </returns>
      /// <remarks>
      ///   Override this in classes derived from GIS_LayerVector
      /// </remarks>
      function  bindFieldInternal  ( const _name        : String      ;
                                     const _cursor      : Integer
                                   ) : Integer ; virtual;

      /// <summary>
      ///   Get field value for a shape given by unique identity.
      /// </summary>
      /// <param name="_shape">
      ///   shape from which field will be retrieved
      /// </param>
      /// <param name="_field">
      ///   field bind number
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   Field value.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     To obtain such identify call bindField.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which
      ///     uses FindFirst..FindNext (any function which iterates
      ///     through the shapes using it - so never use inside an
      ///     operation like Locate etc.).
      ///   </para>
      /// </remarks>
      function  getBindedField     ( const _shape       : TObject     ;
                                     const _field       : Integer     ;
                                     const _cursor      : Integer
                                   ) : Variant ; virtual;

      /// <summary>
      ///   Get field value for a shape given by unique identity.
      /// </summary>
      /// <param name="_shape">
      ///   shape from which field will be retrieved
      /// </param>
      /// <param name="_field">
      ///   field bind number
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   Field value.
      /// </returns>
      /// <remarks>
      ///   To obtain such identify call bindField. Override this in classes
      ///   derived from GIS_LayerVector.
      /// </remarks>
      function  getBindedFieldInternal
                                   ( const _shape       : TObject     ;
                                     const _field       : Integer     ;
                                     const _cursor      : Integer
                                   ) : Variant ; virtual;

      /// <summary>
      ///   Parse label string (to expand fields etc.).
      /// </summary>
      /// <param name="_field">
      ///   source field of statistics
      /// </param>
      /// <param name="_function">
      ///   name of statistical function
      /// </param>
      /// <returns>
      ///   Value of statistics or null.
      /// </returns>
      function  getStatistics     ( const _field    : String  ;
                                    const _function : String
                                  ) : Variant ;

      /// <summary>
      ///   Calculate a visibility of a given shape.
      /// </summary>
      /// <param name="_shape">
      ///   shape to test on
      /// </param>
      /// <param name="_extent">
      ///   visible area
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   True if shape is visible.
      /// </returns>
      function  isShapeVisible     ( const _shape       : TGIS_Shape  ;
                                     const _extent      : TGIS_Extent ;
                                     const _cursor      : Integer
                                   ) : Boolean ;

    // for internal use of TGIS_Viewer
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <inheritdoc/>
      /// <remarks>
      ///   For TGIS_LayerVector, any shape is valid, but
      ///   TGIS_ShapeType.Point will be the default.
      /// </remarks>
      procedure setUp              ; override;

      /// <inheritdoc/>
      procedure setUp2             ; override;

      /// <inheritdoc/>
      procedure setUp3             ; override;

      /// <inheritdoc/>
      procedure applyConfigOptions ( const _cfg         : TGIS_ConfigAbstract
                                   ) ; override;

      /// <inheritdoc/>
      procedure storeConfigOptions ( const _cfg         : TGIS_ConfigAbstract
                                   ) ; override;

      /// <summary>
      ///   Internally used by TGIS_Viewer.
      /// </summary>
      /// <param name="_shape">
      ///   shape handle
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   True it shape is in the scope.
      /// </returns>
      /// <remarks>
      ///   Test if the current shape is inside a given scope.
      /// </remarks>
      function  isInScope          ( const _shape       : TGIS_Shape  ;
                                     const _cursor      : Integer
                                   ) : Boolean ; virtual;

      /// <summary>
      ///   Internally used by TGIS_Viewer.
      /// </summary>
      /// <param name="_shape">
      ///   shape for which editable "mirror" will be found
      /// </param>
      /// <returns>
      ///   Editable clone in-memory or _shape itself
      /// </returns>
      /// <remarks>
      ///   Will try to retrieve a mirror shape from an edited list. If
      ///   impossible, then given shape will be returned. Decision will be
      ///   made based on Uid.
      /// </remarks>
      function  getEdited          ( const _shape       : TGIS_Shape
                                   ) : TGIS_Shape ;

      /// <summary>
      ///   Prepare colors and size for a shape using automatic renderer.
      /// </summary>
      /// <param name="_shape">
      ///   shape to be rendered; if nil, then _value will be used
      /// </param>
      /// <param name="_value">
      ///   value to be used instead of parsing _shape by _query
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <returns>
      ///   True if renderer was locked (should be unlocked with
      ///   unlockRender).
      /// </returns>
      /// <remarks>
      ///   An unlockRender MUST be called after successful.
      /// </remarks>
      function  lockRender         ( const _shape       : TGIS_Shape  ;
                                     const _value       : Double ;
                                     const _cursor      : Integer
                                   ) : Boolean ;

      /// <summary>
      ///   Do after lockRender.
      /// </summary>
      procedure unlockRender       ;

      /// <summary>
      ///   Prepare colors and size for a shape using automatic renderer.
      /// </summary>
      /// <param name="_shape">
      ///   shape to be rendered; if nil, then _value will be used
      /// </param>
      /// <param name="_value">
      ///   value to be used instead of parsing _shape by _query
      /// </param>
      /// <param name="_cursor">
      ///   cursor id
      /// </param>
      /// <param name="_paramsVector">
      ///   Params instance to apply render properties
      /// </param>
      /// <param name="_renderColor">
      ///   caluclated render color to be assigned inside this function
      /// </param>
      /// <param name="_renderSize">
      ///   caluclated render size to be assigned inside this function
      /// </param>
      /// <returns>
      ///   True if render properties was successfully calculated
      ///   and renderer can be used.
      /// </returns>
      function  prepareRender      ( const _shape       : TGIS_Shape  ;
                                     const _value       : Double ;
                                     const _cursor      : Integer ;
                                     const _paramsVector: TGIS_ParamsSectionVector ;
                                     var   _renderColor : TGIS_Color ;
                                     var   _renderSize  : Integer
                                   ) : Boolean ;

      /// <summary>
      ///   Prepare colors and sizes for rendering the legend.
      /// </summary>
      /// <param name="_sectionIdx">
      ///   parameters section index
      /// </param>
      /// <param name="_value">
      ///   value to be used
      /// </param>
      /// <param name="_params">
      ///   params to update
      /// </param>
      /// <returns>
      ///   True if data is prepared for rendering.
      /// </returns>
      function  legendRender       ( const _sectionIdx  : Integer ;
                                     const _value       : Double ;
                                     const _params      : TGIS_ParamsSectionVector
                                   ) : Boolean ;

      /// <summary>
      ///   Check if shape is visible based on current paramsCache setup.
      /// </summary>
      /// <param name="_shp">
      ///   shape to be checked
      /// </param>
      /// <param name="_cursor">
      ///   cursor index to be used to check attribute fields
      /// </param>
      /// <returns>
      ///   true if shape is visible
      /// </returns>
      function checkParamsCache    ( const _shp         : TGIS_Shape ;
                                     const _cursor      : Integer
                                   ) : Boolean ;
    // for internal use of TGIS_Shape
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}

      /// <summary>
      ///   Used by TGIS_Shape to add itself to the flash queue.
      /// </summary>
      /// <param name="_uid">
      ///   shape identifier
      /// </param>
      procedure queueFlash         ( const _uid         : TGIS_Uid
                                   ) ;

      /// <summary>
      ///   Used by TGIS_Shape to remove itself from the flash queue.
      /// </summary>
      /// <param name="_uid">
      ///   shape identifier
      /// </param>
      procedure releaseFlash       ( const _uid         : TGIS_Uid
                                   ) ;

    private

      /// <summary>
      ///   Utility function used by CreateShape to perform
      ///   common task like adding shape to a layer.
      /// </summary>
      /// <param name="_shape">
      ///   shape on which shape creation are going to be performed
      /// </param>
      /// <param name="_shape">
      ///   shape on which shape creation are going to be performed
      /// </param>
      /// <returns>
      ///   Created shape of nil if shape is destroyed due to impossibility
      ///   to create it in a proper way (like shape type not adequate to
      ///   layer supported shapes).
      /// </returns>
      function  doCreateShape      ( const _shape       : TGIS_Shape
                                   ) : TGIS_Shape ;

      {$IFDEF CLR or ISLAND}
        /// <summary>
        ///   Creates a new shape and makes it editable.
        /// </summary>
        /// <param name="_type">
        ///   extended shape type inherited from TGIS_Shape descendant;
        ///   base shape type must supported by layer
        /// </param>
        /// <returns>
        ///   Newly created shape or nil.
        /// </returns>
        function  doCreateShapeFromType(
                                     const _type        : &Type
                                   ) : TGIS_Shape ; overload;
      {$ENDIF}

      {$IFDEF JAVA}
        /// <summary>
        ///   Creates a new shape and makes it editable.
        /// </summary>
        /// <param name="_type">
        ///   extended shape type inherited from TGIS_Shape descendant;
        ///   base shape type must supported by layer
        /// </param>
        /// <returns>
        ///   Newly created shape or nil.
        /// </returns>
        function  doCreateShapeFromType(
                                     const _type        : &Class
                                   ) : TGIS_Shape ; overload;
      {$ENDIF}


      /// <summary>
      ///   Apply styling from GIS_STYLE field
      /// </summary>
      /// <param name="_shape">
      ///   shape an which styling should be applied
      /// </param>
      procedure applyShapeStyleField(
                                     const _shape       : TGIS_Shape
                                   );


    {$IFDEF OXYGENE} unit {$ENDIF}

      /// <summary>
      ///   Get shape from processed list using bisection.
      /// </summary>
      /// <param name="_uid">
      ///   identifier /same as current record for SHP file/
      /// </param>
      /// <param name="_ipos">
      ///   position of the located element or position in which to insert
      /// </param>
      /// <returns>
      ///   True if shape was found.
      /// </returns>
      function  getAggregatedPos   ( const _uid         : TGIS_Uid       ;
                                     var   _ipos        : Integer
                                   ) : Boolean ;
      /// <summary>
      ///   Move to next dynamically added shape in Layer
      ///   (by TGIS_DynamicAggregatorAbstract derived class).
      /// </summary>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      procedure cursorNextAggregated(
                                     const _cursor      : Integer
                                   ) ;


    protected
      // destructor

      /// <summary>
      ///   Destroy a layer instance.
      /// </summary>
      procedure doDestroy        ; override;
    public
      // constructors

      /// <summary>
      ///   Create layer.
      /// </summary>
      /// <remarks>
      ///   <note type="note">
      ///    Remember to set name property to easy recognize and locate it
      ///    in the viewer.
      ///    </note>
      ///   <para>
      ///     Use this method to create a layer with default parameters.
      ///   </para>
      ///   <para>
      ///      See ImportStructure for example.
      ///   </para>
      /// </remarks>
      constructor Create           ; override;
    public // API

      /// <summary>
      ///   Builds a new layer - prepares storage.
      /// </summary>
      /// <param name="_path">
      ///   full path of layer to be built; a connection string for SQL
      ///   base shapes;
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNIMPLEMENTED
      /// </exception>
      /// <remarks>
      ///   <para>
      ///     Use this method to build a new layer (prepare storage).
      ///     Depending on the layer type, different files are created or used.
      ///     For GIS_LayerSHP there are .shp and .dbf files.
      ///     GIS_LayerSQLAbstract uses .ttkls files.
      ///   </para>
      ///   <para>
      ///     To add a new layer to the viewer, simply create a layer, use
      ///     Build method with proper params, fill needed layer
      ///     properties, and use the viewer Add method.
      ///   </para>
      /// </remarks>
      procedure Build          ( const _path        : String      ;
                                 const _extent      : TGIS_Extent ;
                                 const _type        : TGIS_ShapeType
                               ) ; overload; virtual;

      /// <summary>
      ///   Builds s new layer - prepare storage.
      /// </summary>
      /// <param name="_path">
      ///   full path of layer to be built; a connection string for SQL base
      ///   shapes;
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer
      /// </param>
      /// <param name="_dim">
      ///   dimension; for default layer dimension use TGIS_DimensionType.Unknown
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNIMPLEMENTED
      /// </exception>
      /// <remarks>
      ///   <para>
      ///     Use this method to build a new layer (prepare storage).
      ///     Depending on layer type different files are created or used.
      ///     For GIS_LayerSHP there are .shp and .dbf, GIS_LayerSQLAbstract
      ///     uses .ttkls files.
      ///   </para>
      ///   <para>
      ///     To add a new layer to the viewer simply create one, use Build
      ///     method with proper params, fill needed layer properties and
      ///     use the viewer Add method.
      ///   </para>
      /// </remarks>
      procedure Build          ( const _path        : String           ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _dim         : TGIS_DimensionType
                               ) ; overload; virtual;

      /// <summary>
      ///   Builds a new layer - prepares storage for direct writing.
      /// </summary>
      /// <param name="_path">
      ///   full path of layer to be built; a connection string for SQL base
      ///   shapes;
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer
      /// </param>
      /// <param name="_dim">
      ///   dimension; for default layer dimension use TGIS_DimensionType.Unknown
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNIMPLEMENTED
      /// </exception>
      /// <remarks>
      ///   Use this method to build a new layer (prepare storage) for
      ///   direct write.
      /// </remarks>
      procedure InitializeDirectWrite(
                                 const _path        : String           ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _dim         : TGIS_DimensionType
                               ) ; virtual;

      /// <summary>
      ///   Finalizes direct writing into layer storage.
      /// </summary>
      procedure FinalizeDirectWrite    ; virtual;

      /// <summary>
      ///   Finalizes reading trying to close active queries.
      /// </summary>
      procedure FinalizeRead    ; virtual;

      /// <summary>
      ///   Imports the field structure from another layer
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <remarks>
      ///   Use this method to import the existing field structure from another
      ///   layer. To do this, simply create a new layer (or use existing
      ///   layer), choose another layer to import from, and use
      ///   ImportStructure method passing the chosen layer as a param.
      /// </remarks>
      procedure ImportStructure( const _layer       : TGIS_LayerVector
                               ) ; virtual;

      /// <summary>
      ///   Merges the field structure from another layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <param name="_restrict">
      ///   if True, any field structure modification will raise error,
      ///   otherwise allow to resize fields
      /// </param>
      /// <remarks>
      ///   Use this method to import existing field structure from
      ///   another layer.
      /// </remarks>
      procedure MergeStructure ( const _layer       : TGIS_LayerVector ;
                                 const _restrict    : Boolean
                               ) ; overload; virtual;

      /// <summary>
      ///   Merges the field structure from another layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <param name="_restrict">
      ///   if True, any field structure modification will raise error,
      ///   otherwise allow to resize fields
      /// </param>
      /// <param name="_useExportName">
      ///   if True, field ExportName will be used, otherwise NewName
      /// </param>
      /// <remarks>
      ///   Use this method to import existing field structure from another
      ///   layer.
      /// </remarks>
      procedure MergeStructure ( const _layer         : TGIS_LayerVector ;
                                 const _restrict      : Boolean          ;
                                 const _useExportName : Boolean
                               ) ; overload; virtual;

      /// <summary>
      ///   Exports fields structure to a fld file.
      /// </summary>
      procedure ExportStructureToFLD ; virtual;

      /// <summary>
      ///   Parses the field rules file.
      /// </summary>
      procedure ReadFieldRules ; virtual;

      /// <summary>
      ///   Save field rules file.
      /// </summary>
      procedure SaveFieldRules ; virtual;

      /// <summary>
      ///   Parses the field definition file.
      /// </summary>
      procedure ReadFieldDefinition ; virtual;

      /// <summary>
      ///   Imports a layer from an existing layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   import will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be imported
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if False,
      ///   only the shape visible in _extent will be imported ;
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     Remember to assign 'path' property to the layer you want to import
      ///     from, for proper import of the new layer to a file.
      ///    </note>
      ///   Use this method to import a layer. To do this, simply create a
      ///   new layer, choose a layer to import from and use ImportLayer method
      ///   with proper params. See also the opposite method, ExportLayer.
      /// </remarks>
      procedure ImportLayer    ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _truncated   : Boolean
                               ) ; overload;

      /// <summary>
      ///   Imports a layer from an existing layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   import will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be imported
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if False,
      ///   only the shape visible in _extent will be imported ;
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     Remember to assign 'path' property to the layer you want to import
      ///     from, for proper import of the new layer to a file.
      ///    </note>
      ///   Use this method to import a layer. To do this, simply create a
      ///   new layer, choose a layer to import from and use ImportLayer method
      ///   with proper params. See also the opposite method, ExportLayer.
      /// </remarks>
      procedure ImportLayer    ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _shape       : TGIS_Shape       ;
                                 const _de9im       : String           ;
                                 const _truncated   : Boolean
                               ) ; overload;

      /// <summary>
      ///   Imports a layer from an existing layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   import will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be imported
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if False,
      ///   only the shape visible in _extent will be imported ;
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     Remember to assign 'path' property to the layer you want to import
      ///     from, for proper import of the new layer to a file.
      ///    </note>
      ///   Use this method to import a layer. To do this, simply create a
      ///   new layer, choose a layer to import from and use ImportLayer method
      ///   with proper params. See also the opposite method, ExportLayer.
      /// </remarks>
      procedure ImportLayerEx  ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _shape       : TGIS_Shape       ;
                                 const _de9im       : String           ;
                                 const _truncated   : Boolean
                               ) ; virtual;

      /// <summary>
      ///   Merges layer from an existing layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be merged
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   import will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be imported
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if False,
      ///   only the shape visible in _extent will be imported ;
      /// </param>
      /// <param name="_restrict">
      ///   if True, any field structure modification will raise error,
      ///   otherwise allow to resize fields
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     Remember to assign 'path' property to the layer you want to import
      ///     to, for proper import of the new layer to file.
      ///   </note>
      ///   Use this method to merge layers. Before the merge, SaveData will
      ///   be fired.
      /// </remarks>
      procedure MergeLayer     ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _truncated   : Boolean          ;
                                 const _restrict    : Boolean
                               ) ; overload;

      /// <summary>
      ///   Merges layer with an existing layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   import will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be imported
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if False,
      ///   only the shape visible in _extent will be imported ;
      /// </param>
      /// <param name="_restrict">
      ///   if True, any field structure modification will raise error,
      ///   otherwise allow to resize fields
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    Remember to assign 'path' property to layer you want to import
      ///    from for proper import a new layer to file.
      ///    </note>
      ///   Use this method to merge layers. Before the merge SaveData will
      ///   be fired.
      /// </remarks>
      procedure MergeLayer     ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _shape       : TGIS_Shape       ;
                                 const _de9im       : String           ;
                                 const _truncated   : Boolean          ;
                                 const _restrict    : Boolean
                               ) ; overload;

      /// <summary>
      ///   Merges layer with an existing layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be imported
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   import will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be imported
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if False,
      ///   only the shape visible in _extent will be imported ;
      /// </param>
      /// <param name="_restrict">
      ///   if True, any field structure modification will raise error,
      ///   otherwise allow to resize fields
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    Remember to assign 'path' property to layer you want to import
      ///    from for proper import a new layer to file.
      ///    </note>
      ///   Use this method to merge layers. Before the merge SaveData will
      ///   be fired.
      /// </remarks>
      procedure MergeLayerEx   ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _shape       : TGIS_Shape       ;
                                 const _de9im       : String           ;
                                 const _truncated   : Boolean          ;
                                 const _restrict    : Boolean
                               ) ; virtual;

      /// <summary>
      ///   Exports the layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be exported to
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   export will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be exported
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if
      ///   False, only the shape visible in _extent will be exported ;
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     Remember to assign 'path' property to the layer you want to export
      ///     to, for proper export of the new layer to a file.
      ///   </note>
      ///   Use this method to export a layer. To do this, choose a layer to
      ///   export to, and use ExportLayer method with proper params. See also
      ///   the opposite method, ImportLayer.
      /// </remarks>
      procedure ExportLayer    ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _truncated   : Boolean
                               ) ; overload;

      /// <summary>
      ///   Exports layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be exported to
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   export will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be exported
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if
      ///   False, only the shape visible in _extent will be exported ;
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     Remember to assign 'path' property to the layer you want to export
      ///     to, for proper export of the new layer to a file.
      ///   </note>
      ///   Use this method to export a layer. To do this, choose a layer to
      ///   export to, and use ExportLayer method with proper params. See also
      ///   the opposite method, ImportLayer.
      /// </remarks>
      procedure ExportLayer    ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _shape       : TGIS_Shape       ;
                                 const _de9im       : String           ;
                                 const _truncated   : Boolean
                               ) ; overload;

      /// <summary>
      ///   Exports layer.
      /// </summary>
      /// <param name="_layer">
      ///   layer to be exported to
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer; if gistypeUnknown is used then
      ///   export will try to recognize shape on its own;
      /// </param>
      /// <param name="_scope">
      ///   SQL query for which shape will be exported
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_truncated">
      ///   if True, then all shapes will be truncated in _extent; if
      ///   False, only the shape visible in _extent will be exported ;
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     Remember to assign 'path' property to the layer you want to export
      ///     to, for proper export of the new layer to a file.
      ///   </note>
      ///   Use this method to export a layer. To do this, choose a layer to
      ///   export to, and use ExportLayer method with proper params. See also
      ///   the opposite method, ImportLayer.
      /// </remarks>
      procedure ExportLayerEx  ( const _layer       : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _type        : TGIS_ShapeType   ;
                                 const _scope       : String           ;
                                 const _shape       : TGIS_Shape       ;
                                 const _de9im       : String           ;
                                 const _truncated   : Boolean
                               ) ; virtual;

      /// <summary>
      ///   Adds a copy of shape and makes it editable.
      /// </summary>
      /// <param name="_shape">
      ///   shape to be added
      /// </param>
      /// <returns>
      ///   Created copy of shape or nil.
      /// </returns>
      /// <param name="_shape">
      ///   shape to be added
      /// </param>
      {#ownership:_shape:release}
      function  AddShape       ( const _shape       : TGIS_Shape
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Adds a copy of shape and makes it editable.
      /// </summary>
      /// <param name="_shape">
      ///   shape to be added
      /// </param>
      /// <param name="_copyfield">
      ///   if True, then all fields will be copied (and created if
      ///   necessary). Default value is False.
      /// </param>
      /// <returns>
      ///   Created copy of shape or nil.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to add a new copy of a shape. Depending on
      ///     _copyfield param, the same field structure is copied to the new
      ///     shape.
      ///   </para>
      ///   <para>
      ///     To add a shape, simply create a new shape, choose a layer to
      ///     export it to, and use ImportLayer method with proper params.
      ///   </para>
      /// </remarks>
      {#ownership:_shape:release}
      function  AddShape       ( const _shape       : TGIS_Shape       ;
                                 const _copyfield   : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Writes a shape directly into storage.
      /// </summary>
      /// <param name="_shape">
      ///   shape to be saved
      /// </param>
      /// <remarks>
      ///   Use this method to write a shape into storage.
      /// </remarks>
      procedure WriteShapeDirect( const _shape       : TGIS_Shape
                                ) ; virtual;

      /// <summary>
      ///   Creates a new shape and makes it editable.
      /// </summary>
      /// <param name="_type">
      ///   type of shape to be created; it must be a type supported by
      ///   the layer; if TGIS_ShapeType.Unknown, then the default shape
      ///   type will be created
      /// </param>
      /// <returns>
      ///   Newly created shape or nil.
      /// </returns>
      function  CreateShape    ( const _type      : TGIS_ShapeType
                               ) : TGIS_Shape ; overload;

      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      {#gendoc:hide:GENSCR}
      /// <summary>
      ///   Creates a new shape and makes it editable.
      /// </summary>
      /// <param name="_type">
      ///   extended shape type inherited from TGIS_Shape descendent;
      ///   base shape type must be supported by layer
      /// </param>
      /// <returns>
      ///   Newly created shape or nil.
      /// </returns>
      function  CreateShape    ( const _type      : TGIS_ShapeClass
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Creates a new shape and makes it editable
      /// </summary>
      /// <param name="_type">
      ///   type of shape to be created; it must be a type supported by the
      ///   layer; if TGIS_ShapeType.Unknown, then the default shape  type
      ///   will be created
      /// </param>
      /// <param name="_dim">
      ///   dimension; it must be a type supported by the layer
      /// </param>
      /// <returns>
      ///   Newly created shape or nil
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to create a new shape. Depending on _type
      ///     param, a different shape will be created. If the shape type is not
      ///     supported by the layer, nil is returned. Otherwise an editable
      ///     shape is returned.
      ///   </para>
      ///   <para>
      ///     To create a shape, simply create a new layer, or choose an
      ///     existing layer and use CreateShape method with a proper shape
      ///     type as a param.
      ///   </para>
      /// </remarks>
      function  CreateShape    ( const _type      : TGIS_ShapeType   ;
                                 const _dim       : TGIS_DimensionType
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Finds the first shape in layer. Will use RTree if available.
      /// </summary>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  FindFirst    : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Finds the first occurrence of an item which meets an extent.
      ///   Will use RTree if available.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; the layer has been attached to
      ///   the Viewer then expected _extent units are in a Viewer
      ///   coordinate space; otherwise expected _extent units are in a
      ///   Layer coordinate space
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  FindFirst      ( const _extent      : TGIS_Extent
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Finds the first occurrence of an item which meets an extent
      ///   and query. Will use RTree if available.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; the layer has been attached to
      ///   the Viewer then expected _extent units are in a Viewer
      ///   coordinate space; otherwise expected _extent units are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty
      ///   (default) means that no items will match.
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  FindFirst      ( const _extent      : TGIS_Extent ;
                                 const _query       : String
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Finds the first occurrence of an item which meets an extent, query,
      ///   and additional parameters. Will use RTree if available.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; the layer has been attached to
      ///   the Viewer then expected _extent units are in a Viewer
      ///   coordinate space; otherwise expected _extent units are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty
      ///   (default) means that no items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  FindFirst      ( const _extent      : TGIS_Extent ;
                                 const _query       : String      ;
                                 const _shape       : TGIS_Shape  ;
                                 const _de9im       : String
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Finds the first occurrence of an item which meets an extent, query,
      ///   and additional parameters. Will use RTree if available.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; the layer has been attached to the
      ///   Viewer then expected _extent units are in a Viewer coordinate
      ///   space; otherwise expected _extent units are in a Layer
      ///   coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment; by default deleted items will be
      ///   ignored
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  FindFirst      ( const _extent      : TGIS_Extent ;
                                 const _query       : String      ;
                                 const _shape       : TGIS_Shape  ;
                                 const _de9im       : String      ;
                                 const _skipDeleted : Boolean
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Finds the next occurrence of an item defined in FindFirst. Method
      ///   will use RTree if available.
      /// </summary>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  FindNext       : TGIS_Shape ; virtual;

      /// <summary>
      ///   Prepares enumerator (also known as iterator or cursor) to iterate
      ///   the layer.
      /// </summary>
      /// <returns>
      ///   Shape enumerator'
      /// </returns>
      function  &Loop          : TGIS_LayerVectorEnumeratorFactory ;
                                 overload; virtual;

      /// <summary>
      ///   Prepares enumerator (also known as iterator or cursor) to iterate
      ///   the layer.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units
      ///   are in a Layer coordinate space
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  &Loop          ( const _extent      : TGIS_Extent
                               ) : TGIS_LayerVectorEnumeratorFactory ;
                               overload; virtual;

      /// <summary>
      ///   Prepares enumerator (also known as iterator or cursor) to iterate
      ///   the layer.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units
      ///   are in a Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics
      ///   SQL WHERE clause; for examples you can use
      ///   'AGE >= 18'; empty (default) means that no items will
      ///   match.
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  &Loop          ( const _extent      : TGIS_Extent ;
                                 const _query       : String
                               ) : TGIS_LayerVectorEnumeratorFactory ;
                               overload; virtual;

      /// <summary>
      ///   Prepares enumerator (also known as iterator or cursor) to iterate
      ///   the layer.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units
      ///   are in a Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics
      ///   SQL WHERE clause; for examples you can use
      ///   'AGE >= 18'; empty (default) means that no items will
      ///   match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  &Loop          ( const _extent      : TGIS_Extent ;
                                 const _query       : String      ;
                                 const _shape       : TGIS_Shape  ;
                                 const _de9im       : String
                               ) : TGIS_LayerVectorEnumeratorFactory ;
                               overload; virtual;

      /// <summary>
      ///   Prepares enumerator (also known as iterator or cursor) to iterate
      ///   the layer.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units
      ///   are in a Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics
      ///   SQL WHERE clause; for examples you can use
      ///   'AGE >= 18'; empty (default) means that no items will
      ///   match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment; by default deleted items
      ///   will be ignored
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  &Loop         ( const _extent      : TGIS_Extent ;
                                const _query       : String      ;
                                const _shape       : TGIS_Shape  ;
                                const _de9im       : String      ;
                                const _skipDeleted : Boolean
                               ) : TGIS_LayerVectorEnumeratorFactory ;
                               overload; virtual;

      /// <summary>
      ///   Fetches all shapes from the layer using callback function.
      /// </summary>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment; by default deleted items will be
      ///   ignored
      /// </param>
      /// <param name="_scale">
      ///   required to properly prepare shape parameters according
      ///   ParamsList section visibility; meaningless if layer is not
      ///   attached to the Viewer
      /// </param>
      /// <param name="_callback">
      ///   procedure to be called on each shape
      /// </param>
      /// <returns>
      ///   True if all shapes are passed. False if operation was interrupted.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///     Fetched shapes will have colors, sizes parameters setup
      ///     according to rendering layout
      ///   </note>
      /// </remarks>
      function   ForEach         (  const _extent      : TGIS_Extent ;
                                    const _query       : String      ;
                                    const _shape       : TGIS_Shape  ;
                                    const _de9im       : String      ;
                                    const _skipDeleted : Boolean     ;
                                    const _scale       : Double      ;
                                    const _callback    : TGIS_ForEachShapeEvent
                                  ) : Boolean ; virtual;

      /// <summary>
      ///   Gets a shape by its unique identifier on default cursor (0).
      /// </summary>
      /// <param name="_uid">
      ///   identifier /same as current record for SHP file/
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function  GetShape           ( const _uid         : TGIS_Uid
                                   ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Gets a shape by unique identifier.
      /// </summary>
      /// <param name="_uid">
      ///   identifier /same as current record for SHP file/
      /// </param>
      /// <param name="_cursor">
      ///   cursor allocated by cursorOpen()
      /// </param>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to get a shape by using its unique id. We can
      ///     locate a shape by id, change or read its attributes, etc.
      ///      See example.
      ///   </para>
      ///   <para>
      ///      When using this operation, never call any function which uses
      ///     FindFirst..FindNext (any function which iterates through the
      ///     shapes using it - so never use inside an operation like
      ///     Locate etc.).
      ///   </para>
      /// </remarks>
      function  GetShape           ( const _uid         : TGIS_Uid       ;
                                     const _cursor      : Integer
                                   ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Gets the Uid of the last shape.
      /// </summary>
      /// <returns>
      ///   0 if Uid not assigned (in fact, only for pixel layers)
      ///   or Uid value.
      /// </returns>
      /// <remarks>
      ///   Use this method to peek at the last attached Uid. Be aware that the
      ///   Uid can point to a non-existing (for example, already deleted) shape.
      /// </remarks>
      function  GetLastUid         : TGIS_Uid ; virtual;

      /// <summary>
      ///   Gets the Uid for a new shape.
      /// </summary>
      /// <returns>
      ///   0 if Uid not assigned (in fact, only for pixel layers)
      ///   or Uid value.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to find the Uid for a new shape. It simply uses
      ///     GetLastUid method to determine the next available id. See example
      ///     in GetLastUid.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which uses
      ///     FindFirst..FindNext (i.e., any function which iterates through the
      ///     shapes using it). So never use inside an operation like
      ///     Locate etc.
      ///   </para>
      /// </remarks>
      function  GetNewUid          : TGIS_Uid ; virtual;

      /// <summary>
      ///   Gets a field value for a shape determined by its unique identity.
      /// </summary>
      /// <param name="_uid">
      ///   identity
      /// </param>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <returns>
      ///   Field value. If field value is Null then function will return
      ///   default value. GetFieldEx will return raw value instead.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to get a field value for a shape given by its
      ///     unique identity.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which
      ///     uses FindFirst..FindNext (i.e., any function which iterates
      ///     through the shapes using it). So never use inside an
      ///     operation like Locate etc.
      ///   </para>
      /// </remarks>
      function  GetField           ( const _uid         : TGIS_Uid       ;
                                     const _name        : String
                                   ) : Variant ; virtual;

      /// <summary>
      ///   Gets a field value for a shape determined by its unique identity.
      /// </summary>
      /// <param name="_uid">
      ///   identity
      /// </param>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <returns>
      ///   Field value. If field value is Null then function will return
      ///   Null default value. GetField will return a default value
      ///   instead.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to get a field value for a shape given by its
      ///     unique identity.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which
      ///     uses FindFirst..FindNext (i.e., any function which iterates
      ///     through the shapes using it). So never use inside an
      ///     operation like Locate etc.
      ///   </para>
      /// </remarks>
      function  GetFieldEx         ( const _uid         : TGIS_Uid       ;
                                     const _name        : String
                                   ) : Variant ; virtual;


      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      {#gendoc:hide:GENSCR}
      /// <summary>
      ///   Binds layer to SQL query object to provided field access methods.
      /// </summary>
      /// <param name="_sqlquery">
      ///   SQL query object
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    This method is for internal use only.
      ///    </note>
      /// </remarks>
      procedure BindSqlQueryInternal(
                                     const _sqlquery    : TGIS_SqlQuery
                                   ) ; virtual ;

      /// <inheritdoc/>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_LAYERBADFORMAT
      /// </exception>
      /// <remarks>
      ///   <para>
      ///     Use this method to draw a layer. Normally called by Paint.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which
      ///     uses FindFirst..FindNext (any function which iterates
      ///     through the shapes using it - so never use inside an
      ///     operation like Locate etc.).
      ///   </para>
      ///   <para>
      ///     See Paint for example.
      ///   </para>
      /// </remarks>
      function  DrawEx             ( const _extent      : TGIS_Extent
                                   ) : Boolean ; override;

      /// <inheritdoc/>
      /// <remarks>
      ///   <para>
      ///     Use this method to draw a layer. Normally this method is called
      ///     by Paint.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which uses
      ///     FindFirst..FindNext (i.e., any function which iterates through the
      ///     shapes using it). So never use inside an operation like
      ///     Locate etc.
      ///   </para>
      ///   <para>
      ///      See Paint for example.
      ///   </para>
      /// </remarks>
      function  DrawSelectedEx     ( const _extent      : TGIS_Extent
                                   ) : Boolean ; override;

      /// <summary>
      ///   Flashes queued shapes.
      /// </summary>
      procedure DrawFlash          ; override;

      /// <summary>
      ///   Draws only shapes that meet a scope criterion.
      /// </summary>
      /// <param name="_query">
      ///   Query closely mimics the SQL WHERE clause
      /// </param>
      /// <param name="_style">
      ///   Name of the style to be used. If Empty, default style will be
      ///   used.
      /// </param>
      /// <returns>
      ///   True if something was drawn.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to draw only shapes that meet a scope
      ///     criteria.
      ///   </para>
      ///   <para>
      ///     This operation can only be used in the context of the renderer,
      ///     i.e. only inside handlers of the following events:
      ///     BeforePaint, BeforePaintRenderer, PaintLayer, PaintExtra,
      ///     AfterPaintRenderer, AfterPaint.
      ///   </para>
      /// </remarks>
      function  DrawScope          ( const _query       : String      ;
                                     const _style       : String
                                   ) : Boolean ;

      /// <summary>
      ///   Draws layer charts.
      /// </summary>
      /// <returns>
      ///   True if something was drawn.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to draw layer charts. Normally this method is used
      ///     by PaintChart. Using charts, we can make simple statistics by
      ///     adding numbers to the charts' values property, e.g., a simple
      ///     legend of population density for a given area.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which uses
      ///     FindFirst..FindNext (any function which iterates through the
      ///     shapes using it). So never use inside an operation like
      ///     Locate etc.
      ///   </para>
      /// </remarks>
      function  DrawChart          : Boolean ;

      /// <summary>
      ///   Flashes shape several times
      /// </summary>
      /// <param name="_uid">
      ///   uid  of the shape to be flashed
      /// </param>
      /// <param name="_times">
      ///   the number of times the shape will flash
      ///   (maximum is 20)
      /// </param>
      /// <param name="_delay">
      ///   delay  time in msec. between each color change
      ///   (maximum is 10000)
      /// </param>
      procedure FlashShape         ( const _uid         : TGIS_Uid       ;
                                     const _times       : Integer     ;
                                     const _delay       : Integer
                                   ) ; virtual ;

      /// <summary>
      ///   Invalidates all selected shapes (but only to redraw the selection,
      ///   not the shapes themselves).
      /// </summary>
      procedure InvalidateSelection ;

      /// <summary>
      ///   Invalidates shapes in the scope.
      /// </summary>
      /// <param name="_query">
      ///   Query closely mimics the SQL WHERE clause
      /// </param>
      /// <param name="_style">
      ///   Name of style to be used. If Empty, default style will be
      ///   used. Important to correctly calculate shape sizes.
      /// </param>
      procedure InvalidateScope  ( const _query       : String      ;
                                   const _style       : String
                                 ) ; overload;

      /// <summary>
      ///   Calculates a centroid for a scope.
      /// </summary>
      /// <param name="_query">
      ///   Query closely mimics the SQL WHERE clause
      /// </param>
      /// <param name="_centroid">
      ///   Current centroid - to be returned if not found
      /// </param>
      /// <returns>
      ///   Found centroid or untouched _centroid value.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to calculate a centroid for a scope. It, in fact,
      ///     finds the centroid for the first shape.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which
      ///     uses FindFirst..FindNext (i.e., any function which iterates
      ///     through the shapes using it). So never use it inside an
      ///     operation like Locate etc.
      ///   </para>
      /// </remarks>
      function  CentroidScope      ( const _query       : String      ;
                                     const _centroid    : TGIS_Point
                                   ) : TGIS_Point ;

      /// <summary>
      ///   Deletes a shape.
      /// </summary>
      /// <param name="_uid">
      ///   Uid of a shape to be deleted
      /// </param>
      /// <remarks>
      ///   Use this method to delete a shape indicated by Uid. Shape will
      ///   be marked as deleted but the real deletion will be performed
      ///   upon save.
      /// </remarks>
      procedure Delete             ( const _uid         : TGIS_Uid
                                   ) ; virtual;

      /// <summary>
      ///   Reverts a shape to its original state.
      /// </summary>
      /// <param name="_uid">
      ///   Uid of a shape to be reverted
      /// </param>
      /// <remarks>
      ///   Use this method to revert a shape indicated by Uid to its file
      ///   based original state. If shape is not saved, it will be deleted.
      ///   See MakeEditable.
      /// </remarks>
      procedure Revert             ( const _uid         : TGIS_Uid
                                   ) ; virtual;

      /// <summary>
      ///   Reverts all shapes to their original state.
      /// </summary>
      /// <remarks>
      ///   Use this method to revert all shapes to their file based original
      ///   state. All unsaved shapes will be deleted and changes not applied.
      ///   See RevertAll.
      /// </remarks>
      procedure RevertShapes       ; virtual;

      /// <inheritdoc/>
      procedure RevertAll          ; override;

      /// <summary>
      ///   Clears selection of shape.
      /// </summary>
      /// <param name="_uid">
      ///   Uid of a shape to be deselected
      /// </param>
      /// <remarks>
      ///   <para>
      ///     Use this method to clear selection of a shape indicated by
      ///     Uid. Internally it sets IsSelected shape property to False.
      ///   </para>
      ///   <para>
      ///      See Shape for example.
      ///   </para>
      /// </remarks>
      procedure Deselect           ( const _uid         : TGIS_Uid
                                   ) ; virtual;

      /// <summary>
      ///   Clears selection of all shapes.
      /// </summary>
      /// <remarks>
      ///   <para>
      ///     Use this method to clear the selection of all shapes.
      ///     Internally it sets IsSelected shape property to False for all
      ///     shapes.
      ///   </para>
      ///   <para>
      ///      See Shape for example.
      ///   </para>
      /// </remarks>
      procedure DeselectAll        ; virtual;

      /// <inheritdoc/>
      procedure SaveData           ; override;

      /// <inheritdoc/>
      function  MustSave           : Boolean ; override;

      /// <summary>
      ///   Recalculates extent.
      /// </summary>
      procedure RecalcExtent       ; override;

      /// <summary>
      ///   Locates a shape.
      /// </summary>
      /// <param name="_ptg">
      ///   reference point /searching point/; if the layer has been
      ///   attached to the Viewer then expected _ptg units are in a
      ///   Viewer coordinate space; otherwise expected _ptg units are in
      ///   a Layer coordinate space
      /// </param>
      /// <param name="_prec">
      ///   precision /not a longer distance than/; for points inside the
      ///   polygon (if _prec &gt;= 0) the distance will be multiply by
      ///   0.95 (to prefer points inside the polygon) but will not be
      ///   bigger then _prec; for point distance will be multiplied by
      ///   0.9 to prefer points over lines and polygons _prec units are
      ///   calculated same way as _ptg
      /// </param>
      /// <returns>
      ///   Found shape or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to locate a shape that is closest to point
      ///   _ptg but also on _prec distance. Internally it calls LocateEx
      ///   method.
      /// </remarks>
      function  Locate         ( const _ptg     : TGIS_Point ;
                                 const _prec    : Double
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Locates a shape.
      /// </summary>
      /// <param name="_ptg">
      ///   reference point /searching point/; if the layer has been
      ///   attached to the Viewer then expected _ptg units are in a Viewer
      ///   coordinate space; otherwise expected _ptg units are in a Layer
      ///   coordinate space
      /// </param>
      /// <param name="_prec">
      ///   precision /not a longer distance than/; for points inside the
      ///   polygon (if _prec &gt;= 0) the distance will be multiply by 0.95
      ///   (to prefer points inside the polygon) but will not be bigger
      ///   then _prec; for point distance will be multiplied by 0.9 to
      ///   prefer points over lines and polygons _prec units are calculated
      ///   same way as _ptg
      /// </param>
      /// <param name="_visible">
      ///   if true the only visible shapes will be evaluated; shapes turned
      ///   of by query of hidden will be ignored
      /// </param>
      /// <returns>
      ///   Found shape or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to locate a shape that is closest to point _ptg
      ///   but also on _prec distance. Internally it calls LocateEx method.
      /// </remarks>
      function  Locate         ( const _ptg     : TGIS_Point ;
                                 const _prec    : Double     ;
                                 const _visible : Boolean
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Locates a shape (more precise).
      /// </summary>
      /// <param name="_ptg">
      ///   reference point /searching point/ if the layer has been
      ///   attached to the Viewer then expected _ptg units are in a
      ///   Viewer coordinate space; otherwise expected _ptg units are in
      ///   a Layer coordinate space
      /// </param>
      /// <param name="_prec">
      ///   precision /not a longer distance than/; point inside a polygon
      ///   is always not greater than _dist; if _prec is less then 0,
      ///   then being outside/inside polygon means the same _prec units
      ///   are calculated same way as _ptg
      /// </param>
      /// <param name="_uid">
      ///   Uid of reference shape or -1; thanks to this, is possible to
      ///   find nearest shape, excluding shape given by _uid.
      /// </param>
      /// <param name="_dist">
      ///   reached distance between _pt and shape in Result; for points
      ///   inside the polygon (if _prec &gt;= 0) the distance will be
      ///   multiply by 0.95 (to prefer points inside the polygon) but
      ///   will not be bigger then _prec; for point distance will be
      ///   multiplied by 0.9 to prefer points over lines and polygons
      ///   _dist units are calculated same way as _ptg
      /// </param>
      /// <param name="_part">
      ///   number of the part closest to a given point
      /// </param>
      /// <param name="_proj">
      ///   point projected to the nearest element of a shape
      /// </param>
      /// <returns>
      ///   Found shape or nil.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to locate a shape that is near _ptg but also
      ///     on _prec distance. It finds a shape using FindFirst method
      ///     in extent corrected by _prec and _ptg params.
      ///   </para>
      ///   <para>
      ///      See Locate for example.
      ///   </para>
      /// </remarks>
      function  LocateEx       ( const _ptg     : TGIS_Point ;
                                 const _prec    : Double     ;
                                 const _uid     : TGIS_Uid      ;
                                 var   _dist    : Double     ;
                                 var   _part    : Integer    ;
                                 var   _proj    : TGIS_Point
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Locates a shape (more precise).
      /// </summary>
      /// <param name="_ptg">
      ///   reference point /searching point/ in a layer; if the layer has
      ///   been attached to the Viewer then expected _ptg units are in a
      ///   Viewer coordinate space; otherwise expected _ptg units are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_prec">
      ///   precision /not a longer distance than/; point inside a polygon
      ///   is always not greater than _dist; if _prec is less then 0, then
      ///   being outside/inside polygon means the same; _prec units are
      ///   calculated same way as _ptg
      /// </param>
      /// <param name="_uid">
      ///   Uid of reference shape or -1; thanks to this, is possible to
      ///   find nearest shape, excluding shape given by _uid.
      /// </param>
      /// <param name="_dist">
      ///   reached distance between _pt and shape in Result; for points
      ///   inside the polygon (if _prec &gt;= 0) the distance will be
      ///   multiply by 0.95 (to prefer points inside the polygon) but will
      ///   not be bigger then _prec; for point distance will be multiplied
      ///   by 0.9 to prefer points over lines and polygons _dist units are
      ///   calculated same way as _ptg
      /// </param>
      /// <param name="_part">
      ///   number of the part closest to a given point
      /// </param>
      /// <param name="_proj">
      ///   point projected to the nearest element of a shape
      /// </param>
      /// <param name="_visible">
      ///   if true the only visible shapes will be evaluated; shapes turned
      ///   of by query of hidden will be ignored
      /// </param>
      /// <returns>
      ///   Found shape or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to locate a shape that is near _ptg but also on
      ///   _prec distance. It finds a shape using FindFirst method in
      ///   extent corrected by _prec and _ptg params.
      /// </remarks>
      function  LocateEx       ( const _ptg     : TGIS_Point ;
                                 const _prec    : Double     ;
                                 const _uid     : TGIS_Uid   ;
                                 var   _dist    : Double     ;
                                 var   _part    : Integer    ;
                                 var   _proj    : TGIS_Point ;
                                 const _visible : Boolean
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Locates a shape (more precise).
      /// </summary>
      /// <param name="_ptg">
      ///   reference point /searching point/ in a layer; if the layer has
      ///   been attached to the Viewer then expected _ptg units are in a
      ///   Viewer coordinate space; otherwise expected _ptg units are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_prec">
      ///   precision /not a longer distance than/; point inside a polygon
      ///   is always not greater than _dist; if _prec is less then 0, then
      ///   being outside/inside polygon means the same; _prec units are
      ///   calculated same way as _ptg
      /// </param>
      /// <param name="_uid">
      ///   Uid of reference shape or -1; thanks to this, is possible to
      ///   find nearest shape, excluding shape given by _uid.
      /// </param>
      /// <param name="_dist">
      ///   reached distance between _pt and shape in Result; for points
      ///   inside the polygon (if _prec &gt;= 0) the distance will be
      ///   multiply by 0.95 (to prefer points inside the polygon) but will
      ///   not be bigger then _prec; for point distance will be multiplied
      ///   by 0.9 to prefer points over lines and polygons _dist units are
      ///   calculated same way as _ptg
      /// </param>
      /// <param name="_part">
      ///   number of the part closest to a given point
      /// </param>
      /// <param name="_proj">
      ///   point projected to the nearest element of a shape
      /// </param>
      /// <param name="_dist_prefer">
      ///   preferred distance (including shape type priority :
      ///   points over lines and polygons)
      /// </param>
      /// <param name="_visible">
      ///   if true the only visible shapes will be evaluated; shapes turned
      ///   of by query of hidden will be ignored
      /// </param>
      /// <returns>
      ///   Found shape or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to locate a shape that is near _ptg but also on
      ///   _prec distance. It finds a shape using FindFirst method in
      ///   extent corrected by _prec and _ptg params.
      /// </remarks>
      function  LocateEx       ( const _ptg        : TGIS_Point ;
                                 const _prec       : Double     ;
                                 const _uid        : TGIS_Uid   ;
                                 var   _dist       : Double     ;
                                 var   _part       : Integer    ;
                                 var   _proj       : TGIS_Point ;
                                 var   _dist_prefer: Double     ;
                                 const _visible    : Boolean
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Finds a field in the fields list.
      /// </summary>
      /// <param name="_name">
      ///   name of field to be found
      /// </param>
      /// <returns>
      ///   Field index (staring for 0) or -1 if not found.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    Virtual fields starting from 100000.
      ///    </note>
      /// </remarks>
      function  FindField          ( const _name        : String
                                   ) : Integer ; virtual ;

      /// <summary>
      ///   Finds a field in the fields list (for internal use).
      /// </summary>
      /// <param name="_name">
      ///   name of field to be found
      /// </param>
      /// <returns>
      ///   Field index (staring for 0) or -1 if not found.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    This method is for internal use only.
      ///    </note>
      ///   Internal version is searching for field using same name as was
      ///   used in saved file.
      /// </remarks>
      function  FindFieldInternal  ( const _name        : String
                                   ) : Integer ; virtual;

      /// <summary>
      ///   Suggests a unique field name.
      /// </summary>
      /// <param name="_name">
      ///   field name to be tested
      /// </param>
      /// <returns>
      ///   Original field name if not exists in a layer or a suggest
      ///   replacement.
      /// </returns>
      /// <remarks>
      ///   If provided name already exists in a layer then function will
      ///   return field name like 'name_A', 'name_B' etc.
      /// </remarks>
      function  GetUniqueFieldName ( const _name        : String
                                   ) : String ; virtual;

      /// <summary>
      ///   Adds a new field.
      /// </summary>
      /// <param name="_name">
      ///   name of field to be added
      /// </param>
      /// <param name="_type">
      ///   type of field
      /// </param>
      /// <param name="_width">
      ///   width of field; not important for fields other then
      ///   TGIS_FieldType.Number or TGIS_FieldType.String;
      /// </param>
      /// <param name="_decimal">
      ///   decimal places; not important for fields other then
      ///   TGIS_FieldType.Number;
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDEXIST
      /// </exception>
      procedure AddField           ( const _name        : String      ;
                                     const _type        : TGIS_FieldType ;
                                     const _width       : Integer     ;
                                     const _decimal     : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Adds new field; for internal use.
      /// </summary>
      /// <param name="_name">
      ///   name of field to be add
      /// </param>
      /// <param name="_type">
      ///   type of field
      /// </param>
      /// <param name="_width">
      ///   width of field
      /// </param>
      /// <param name="_decimal">
      ///   decimal places
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDEXIST
      /// </exception>
      /// <remarks>
      ///   <note type="note">
      ///    This method is used internally only for layer reading.
      ///    </note>
      /// </remarks>
      procedure AddFieldInternal   ( const _name        : String      ;
                                     const _type        : TGIS_FieldType ;
                                     const _width       : Integer     ;
                                     const _decimal     : Integer
                                   ) ; overload; virtual;

      /// <summary>
      ///   Adds new field; for internal use.
      /// </summary>
      /// <param name="_name">
      ///   name of field to be add
      /// </param>
      /// <param name="_type">
      ///   type of field
      /// </param>
      /// <param name="_width">
      ///   width of field
      /// </param>
      /// <param name="_decimal">
      ///   decimal places
      /// </param>
      /// <param name="_saved">
      ///   True if field exist in an original file
      /// </param>
      /// <param name="_binary">
      ///   binary width (used only for TAB/DAT files)
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDEXIST
      /// </exception>
      /// <remarks>
      ///   <note type="note">
      ///    This method is used only for internal use on layer reading.
      ///    </note>
      /// </remarks>
      procedure AddFieldInternal   ( const _name        : String      ;
                                     const _type        : TGIS_FieldType ;
                                     const _width       : Integer     ;
                                     const _decimal     : Integer     ;
                                     const _saved       : Boolean     ;
                                     const _binary      : Integer
                                   ) ; overload; virtual;

      /// <summary>
      ///   Renames a field.
      /// </summary>
      /// <param name="_name">
      ///   name of field to be renamed
      /// </param>
      /// <param name="_newname">
      ///   new name
      /// </param>
      /// <param name="_width">
      ///   new width
      /// </param>
      /// <param name="_decimal">
      ///   new decimal position
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDNOEXIST
      /// </exception>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDEXIST
      /// </exception>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDREADONLY
      /// </exception>
      /// <remarks>
      ///   Use this method to rename a field, which will be marked as
      ///   changed and the final restructure will be performed upon save.
      ///   UnRename can be performed by using RevertAll.
      /// </remarks>
      procedure RenameField        ( const _name        : String      ;
                                     const _newname     : String      ;
                                     const _width       : Integer     ;
                                     const _decimal     : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Deletes a field.
      /// </summary>
      /// <param name="_name">
      ///   name of field to be deleted
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDNOEXIST
      /// </exception>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDREADONLY
      /// </exception>
      /// <remarks>
      ///   <para>
      ///     Use this method to delete a field, which will be marked as
      ///     deleted and final restructure will be performed upon save.
      ///   </para>
      ///   <para>
      ///      UnDelete can be performed by RevertAll.
      ///   </para>
      ///   <para>
      ///      Internally it uses FieldInfo method with _name param.
      ///   </para>
      /// </remarks>
      procedure DeleteField        ( const _name        : String
                                   ) ; virtual;

      /// <summary>
      ///   Returns pointer to GIS_FieldInfo structure.
      /// </summary>
      /// <param name="_id">
      ///   id of field to be returned
      /// </param>
      /// <returns>
      ///   Field description or nil.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     Use this method to get pointer to GIS_FieldInfo structure.
      ///   </para>
      ///   <para>
      ///     See RenameField for example.
      ///   </para>
      /// </remarks>
      function  FieldInfo          ( const _id          : Integer
                                   ) : TGIS_FieldInfo ; virtual;

      /// <summary>
      ///   Prepares field names to export.
      /// </summary>
      /// <param name="_maxwidth">
      ///   max width of field; should be &gt;= 4
      /// </param>
      procedure PrepareExportFieldNames
                                   ( const _maxwidth    : Integer
                                   ) ; overload; virtual;

      /// <summary>
      ///   Prepares field names to export.
      /// </summary>
      /// <param name="_maxwidth">
      ///   max width of field; should be &gt;= 4
      /// </param>
      /// <param name="_forced">
      ///   if _false (default) export names will be constructed for new
      ///   fields; otherwise saved fields will be ignored
      /// </param>
      procedure PrepareExportFieldNames
                                     ( const _maxwidth    : Integer ;
                                       const _forced      : Boolean
                                     ) ; overload; virtual ;

      /// <summary>
      ///   Prepares field names to export.
      /// </summary>
      /// <param name="_maxwidth">
      ///   max width of field; should be &gt;= 4
      /// </param>
      /// <param name="_forced">
      ///   if _false (default) export names will be constructed for new
      ///   fields; otherwise saved fields will be ignored
      /// </param>
      /// <param name="_useUpperCase">
      ///   convert field name to uppercase format
      /// </param>
      procedure PrepareExportFieldNames
                                   ( const _maxwidth    : Integer ;
                                     const _forced      : Boolean ;
                                     const _useUpperCase: Boolean
                                   ) ; overload; virtual;

      /// <summary>
      ///   Returns current parameters filled with the renderer styling.
      /// </summary>
      /// <param name="_id">
      ///   index of sub legend to be returned (number of legends are determined
      ///   by RenderZones); negative index indicates extended band (Ex).
      /// </param>
      /// <param name="_params">
      ///   params to be set (must be allocated)
      /// </param>
      /// <remarks>
      ///   <note type="important">
      ///    The method is deprecated. Use rather the overloaded version.
      ///   </note>
      ///   <note type="note">
      ///    The Legend property will be set with text representing a zone value.
      ///    </note>
      /// </remarks>
      procedure  LegendInfo        ( const _id          : Integer ;
                                     const _params      : TGIS_ParamsSectionVector
                                   ) ; overload ;
                                   {$IFNDEF GENDOC} deprecated ; {$ENDIF}

      /// <summary>
      ///   Returns parameters filled with the renderer styling.
      /// </summary>
      /// <param name="_sectionIdx">
      ///   index of parameters section to retrieve
      /// </param>
      /// <param name="_id">
      ///   index of sub legend to be returned (number of legends are determined
      ///   by RenderZones); negative index indicates extended band (Ex).
      /// </param>
      /// <param name="_params">
      ///   params to be set (must be allocated)
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    The Legend property will be set with text representing a zone value.
      ///    </note>
      /// </remarks>
      /// <returns>
      ///   True, if the data has been retrieved properly
      /// </returns>
      function   LegendInfo        ( const _sectionIdx  : Integer ;
                                     const _id          : Integer ;
                                     const _params      : TGIS_ParamsSectionVector
                                   ) : Boolean ; overload ;

      /// <summary>
      ///   Gets a shape's styling parameters that are used during drawing
      ///   in the viewer, and fills the _params parameter.
      /// </summary>
      /// <param name="_shp">
      ///   shape to evaluate when preparing params
      /// </param>
      /// <param name="_params">
      ///   params to be set (must be allocated)
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    The resulting parameters are resolved using the current viewer context.
      ///   </note>
      /// </remarks>
      procedure ParamsAsDrawn      ( const _shp         : TGIS_Shape ;
                                     const _params      : TGIS_ParamsSectionVector
                                   ) ;
      /// <summary>
      ///   Returns the quantity of selected shapes.
      /// </summary>
      /// <returns>
      ///   Quantity of selected shapes.
      /// </returns>
      function GetSelectedCount    : Integer ;

      /// <inheritdoc/>
      function  GetAvailableLayers : TGIS_LayerInfoList  ; override;

      /// <inheritdoc/>
      function IsVector            : Boolean ; override;

      /// <inheritdoc/>
      function IsVector3D          : Boolean ; override;

      /// <inheritdoc/>
      function MustCalculateStatistics
                                   : Boolean ; override;

      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      {#gendoc:hide:GENSCR}
      /// <summary>
      ///   This method is used only for internal use on layer reading.
      /// </summary>
      procedure LockRenderInternal ;

      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      {#gendoc:hide:GENSCR}
      /// <summary>
      ///   This method is used only for internal use on layer reading.
      /// </summary>
      procedure UnlockRenderInternal ;

      {$IFDEF CLR}
        /// <summary>
        ///   Check if the LabelPosEvent event is assigned.
        /// </summary>
        /// <returns>
        ///   True if assigned.
        /// </returns>
        function  AssignedLabelPosEvent : Boolean ;

        /// <summary>
        ///   Raise the LabelPosEvent event.
        /// </summary>
        /// <param name="_sender">
        ///   event sender
        /// </param>
        /// <param name="_e">
        ///   event arguments
        /// </param>
        procedure RaiseLabelPosEvent(  _sender : Object ;
                                       _e      : TGIS_ShapePosEventArgs
                                    ) ;
      {$ENDIF}

      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      {#gendoc:hide:GENSCR}
      /// <summary>
      ///   Internal method to rebuild shape&apos;s uid values and ensure ascending order.
      ///   Call this method after changing the order of shapes in the Items list to
      ///   make the GetShape function working correctly.
      ///   Valid only for in-memory layers.
      /// </summary>
      procedure ReorderShapeUids ;

    public // properties

      /// <summary>
      ///   Forces multipass rendering.
      /// </summary>
      /// <remarks>
      ///   Multipass rendering is much slower because all section
      ///   optimization is turned off, but it guarantees that all sections
      ///   are rendered in the order specified in ParamsList and that lines
      ///   with outlines are with nicely drawn junction points.
      /// </remarks>
      property MultipassRendering : Boolean read  FMultipassRendering
                                            write FMultipassRendering ;

      /// <summary>
      ///   Scope zone.
      /// </summary>
      /// <remarks>
      ///   Use this property as a SQL-like query (WHERE clause) to limit
      ///   active layer objects. Treat is as a filter.
      /// </remarks>
      property Scope : String read FScope write FScope ;

      /// <summary>
      ///   Scope extent.
      /// </summary>
      /// <remarks>
      ///   Use this limit active layer objects to provided extent. Treat
      ///   this as a filter.
      /// </remarks>
      property ScopeExtent : TGIS_Extent read  FScopeExtent
                                         write FScopeExtent ;

      /// <summary>
      ///   Path to RTree index.
      /// </summary>
      property PathRTree : String read fget_PathRTree ;

      /// <summary>
      ///   Path to field definitions ini file.
      /// </summary>
      property PathFLD   : String read fget_PathFLD ;

      /// <summary>
      ///   Path to field rules file.
      /// </summary>
      property PathFLDX   : String read fget_PathFLDX ;

      /// <summary>
      ///   A list of all ghost items.
      /// </summary>
      /// <remarks>
      ///   <para>
      ///     After MakeEditable, the called shape is handled in this list.
      ///     The shape can be removed fully from the list by calling Revert on
      ///     the shape level. In such case, all subsequent operations on the
      ///     shape will be performed via disk image.
      ///   </para>
      ///   <para>
      ///      Another way of clearing this list is to call Save, which
      ///     will transfer all information back to the file.
      ///   </para>
      ///   <para>
      ///      See Build for an example.
      ///   </para>
      /// </remarks>
      property Items : TGIS_ShapeList read fget_Items ;

      /// <summary>
      ///   List of database field definitions.
      /// </summary>
      /// <remarks>
      ///   See RenameField for example.
      /// </remarks>
      property Fields : TGIS_FieldInfoList read fget_Fields ;

      /// <summary>
      ///   List of virtual fields.
      /// </summary>
      /// <remarks>
      ///   <note type="note">
      ///    Virtual fields starting from 100000.
      ///    </note>
      /// </remarks>
      property FieldsVirtual : TGIS_FieldInfoList read fget_FieldsVirtual ;

      /// <summary>
      ///   Sets the use of an index based on RTree structure. Setting to
      ///   True will always rebuild index for in-memory shapes.
      /// </summary>
      /// <remarks>
      ///   If Viewer is attached and has UseRtree=True, then layer.UseRTree
      ///   will inherit value. Use BlocRTree to avoid this behavior.
      /// </remarks>
      property UseRTree : Boolean read fget_UseRTree write fset_UseRTree ;

      /// <summary>
      ///   If true, then Rtree for the layer cannot be enabled and
      ///   UseRtree is ignored.
      /// </summary>
      property BlockRTree : Boolean read FBlockRTree write FBlockRTree ;

      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      {#gendoc:hide:GENSCR}
      /// <summary>
      ///   Rtree based index.
      /// </summary>
      property RTreeFile : TGIS_RTree read fget_RTree write FRTreeFile ;

      /// <summary>
      ///   True if RTree file will be created in-memory. Only used when
      ///   opening the layer.
      /// </summary>
      property InMemoryRTree : Boolean read  FInMemoryRTree
                                       write FInMemoryRTree ;

      /// <summary>
      ///   Set of shapes supported by a layer. The meaning of this is shapes
      ///   that can be created, saved etc.
      /// </summary>
      property SupportedShapes : TGIS_ShapeTypes
                                 read  FSupportedShapes
                                 write FSupportedShapes ;

      /// <summary>
      ///   Similar to SupportedShapesSet, but this lists also includes shape
      ///   types added temporarily by the aggregator.
      /// </summary>
      property SupportedShapesAll : TGIS_ShapeTypes
                                    read  fget_SupportedShapesAll ;

      /// <summary>
      ///   Set of dimensions supported by a layer.
      /// </summary>
      property SupportedDimensions : TGIS_DimensionTypes
                                     read  FSupportedDimensions
                                     write FSupportedDimensions ;

      /// <summary>
      ///   Default shape type for the layer. Can be set only to one of
      ///   SupportedShapes.
      /// </summary>
      property DefaultShapeType : TGIS_ShapeType
                                  read fget_DefaultShapeType
                                  write fset_DefaultShapeType ;

      /// <summary>
      ///   Default shape dimension for the layer. Can be set only to one of
      ///   SupportedDimension.
      /// </summary>
      property DefaultDimension : TGIS_DimensionType
                                  read fget_DefaultDimension
                                  write fset_DefaultDimension ;

      /// <summary>
      ///   List of uids of the selected shapes.
      /// </summary>
      property SelectedList : TGIS_SelectedShapeList
                              read fget_SelectedList ;


      /// <summary>
      ///   Returns parameters (colors, fills, etc.) object.
      /// </summary>
      /// <remarks>
      ///   <para>
      ///     If object was not allocated then Layer level parameters will
      ///     be returned.
      ///   </para>
      ///   <para>
      ///      See AddShape for example.
      ///   </para>
      /// </remarks>
      property Params : TGIS_ParamsSectionVector read fget_ParamsVector
                                                 write fset_ParamsVector ;
                                                 {$IFDEF OXYGENE}
                                                   reintroduce ;
                                                 {$ENDIF}

      {$IFDEF CLR}
        /// <summary>
        ///   ADO.NET Query to be joined. Used only if JoinDB is not
        ///   assigned.
        /// </summary>
        property JoinNET : Object read FJoinNET write fset_JoinNET ;
      {$ENDIF}

      {$IFNDEF GIS_NOADO_JOIN}
        /// <summary>
        ///   ADO Query to be joined. Used only if JoinDB is not assigned.
        /// </summary>
        property JoinADO :
        {$IFDEF CLR}
            Object read FJoinADO write fset_JoinADO ;
        {$ELSE}
            _Recordset read FJoinADO write fset_JoinADO ;
        {$ENDIF}
      {$ENDIF}
      {$IFNDEF GIS_NOJDBC}
        /// <summary>
        ///   JDBC ResultSet of Query to be joined. Used only if JoinDB is not assigned.
        /// </summary>
         property JoinJDBC       : Object read FJoinJDBC write fset_JoinJDBC ;
        /// <summary>
        ///   JDBC Query to be joined. Used only if JoinDB is not assigned.
        /// </summary>
         property JoinJDBCQuery  : String read FJoinJDBCQuery write fset_JoinJDBCQuery ;
      {$ENDIF}
      {$IFNDEF GIS_NODB}
         /// <summary>
         ///   DB Query to be joined.
         /// </summary>
         property JoinDB : TDataSet read FJoinDB write fset_JoinDB ;
      {$ENDIF}
      {$IFDEF GIS_PDK}
         /// <summary>
         ///   DB-API 2.0 Cursor (e.g. SQLite cursor) to be joined.
         /// </summary>
         property JoinDBAPI2 : {$IFDEF GENPDK} cursor
                               {$ELSE}         PPyObject
                               {$ENDIF}
                               read FJoinDBAPI2 write fset_JoinDBAPI2 ;
      {$ENDIF}

      /// <summary>
      ///   Field from feature table to be joined. Field value must be a
      ///   unique and be the same type as JoinForeign. Table must be
      ///   ordered by this value.
      /// </summary>
      property JoinPrimary : String read  FJoinPrimary
                                    write fset_JoinPrimary ;

      /// <summary>
      ///   Field from Query to be joined. Field value must be the same
      ///   type as JoinPrimary. Query must be ordered by this value.
      /// </summary>
      property JoinForeign : String read  FJoinForeign
                                    write fset_JoinForeign ;

      /// <summary>
      ///   Code page for JoinADO/JoinDB.
      /// </summary>
      property JoinCodePage : Integer read  FJoinCodePage
                                      write FJoinCodePage ;

      /// <summary>
      ///   If True, then only layer level params will be used. Any color or
      ///   style defined for a particular shape will be ignored and
      ///   substituted with color or style defined on the layer level.
      /// </summary>
      property IgnoreShapeParams : Boolean read  FIgnoreShapeParams
                                           write FIgnoreShapeParams ;

      /// <summary>
      ///   Labeling mode metadata.
      /// </summary>
      property LabelingMode : Integer read  FLabelingMode ;

      /// <summary>
      ///   Symboling mode metadata.
      /// </summary>
      property SymbolingMode : Integer read FSymbolingMode ;

      /// <summary>
      ///   Aggregation processor is executed upon the drawing process.
      ///   Typical use is to provide dynamic binning or clustering.
      /// </summary>
      /// <remarks>
      ///   Upon assigning DynamicAggregator property, any preexisting instance
      ///   of this property will be disposed.
      /// </remarks>
      property DynamicAggregator : TGIS_DynamicAggregatorAbstract
                                   read  FDynamicAggregator
                                   write fset_DynamicAggregator ;

      /// <summary>
      ///   If true than params style attribute field was defined.
      /// </summary>
      property UseShapeStyleField : Boolean
                                    read  FUseShapeStyleField
                                    write FUseShapeStyleField ;

    published // events
      {$IFDEF OXYGENE}
        {$IFDEF CLR}
          /// <event/>
          /// <summary>
          ///   PaintShape event.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, Draw for each shape will
          ///     not be called internally. Use it to make custom actions when
          ///     drawing individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for example.
          ///   </para>
          /// </remarks>
          event PaintShapeEvent    : TGIS_ShapeEvent
                                     delegate FOnPaintShape ;
        {$ENDIF}
        {$IFDEF JAVA}
          /// <event/>
          /// <summary>
          ///   PaintShape events.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, Draw for each shape will
          ///     not be called internally. Use it to make custom actions when
          ///     drawing individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for example.
          ///   </para>
          /// </remarks>
          event PaintShapeEvent : TGIS_ShapeEvent add addPaintShapeEvent remove removePaintShapeEvent ;
        {$ENDIF}
      {$ELSE}
         /// <event/>
         /// <summary>
         ///   PaintShape event.
         /// </summary>
         /// <remarks>
         ///   <para>
         ///     When attached, Draw for each shape will not be called
         ///     internally. Use it to make custom actions when drawing
         ///     individual shapes.
         ///   </para>
         ///   <para>
         ///      See Paint for example. ;
         ///   </para>
         /// </remarks>
         property PaintShapeEvent    : TGIS_ShapeEvent
                                       read  FOnPaintShape
                                       write FOnPaintShape ;
      {$ENDIF}

      {$IFDEF OXYGENE}
        {$IFDEF CLR}
          /// <event/>
          /// <summary>
          ///   PaintShapeLabel event.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, DrawLabel for each shape will not be called
          ///     internally. Use it to make custom actions when drawing labels for
          ///     individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for example.
          ///   </para>
          /// </remarks>
          event PaintShapeLabelEvent    : TGIS_ShapeEvent
                                          delegate FOnPaintShapeLabel ;
        {$ENDIF}
        {$IFDEF JAVA}
          /// <event/>
          /// <summary>
          ///    OnPaintShapeLabel events.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, DrawLabel for each shape will not be called
          ///     internally. Use it to make custom actions when drawing labels for
          ///     individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for example.
          ///   </para>
          /// </remarks>
          event PaintShapeLabelEvent   : TGIS_ShapeEvent add addPaintShapeLabelEvent remove removePaintShapeLabelEvent ;
        {$ENDIF}
      {$ELSE}
          /// <event/>
          /// <summary>
          ///   PaintShapeLabel event.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, DrawLabel for each shape will not be called
          ///     internally. Use it to make custom actions when drawing
          ///     labels for individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for similar example.
          ///   </para>
          /// </remarks>
          property PaintShapeLabelEvent     : TGIS_ShapeEvent
                                              read  FOnPaintShapeLabel
                                              write FOnPaintShapeLabel ;
      {$ENDIF}
      {$IFDEF OXYGENE}
        {$IFDEF CLR}
          /// <summary>
          ///   PaintShapeChart event.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, DrawChart for each shape will not be called
          ///     internally. Use it to make custom actions when drawing labels for
          ///     individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for similar example.
          ///   </para>
          /// </remarks>
          event PaintShapeChartEvent    : TGIS_ShapeEvent
                                          delegate FOnPaintShapeChart ;
        {$ENDIF}
        {$IFDEF JAVA}
          /// <summary>
          ///   PaintShapeChart event.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, DrawChart for each shape will not be called
          ///     internally. Use it to make custom actions when drawing labels for
          ///     individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for similar example.
          ///   </para>
          /// </remarks>
          event PaintShapeChartEvent : TGIS_ShapeEvent add addPaintShapeChartEvent remove removePaintShapeChartEvent;
        {$ENDIF}
      {$ELSE}
          /// <event/>
          /// <summary>
          ///   PaintShapeChart event.
          /// </summary>
          /// <remarks>
          ///   <para>
          ///     When attached, DrawChart for each shape will not be called
          ///     internally. Use it to make custom actions when drawing
          ///     labels for individual shapes.
          ///   </para>
          ///   <para>
          ///      See Paint for similar example.
          ///   </para>
          /// </remarks>
          property PaintShapeChartEvent     : TGIS_ShapeEvent
                                              read  FOnPaintShapeChart
                                              write FOnPaintShapeChart ;
      {$ENDIF}
      {$IFDEF CLR}
        /// <event/>
        /// <summary>
        ///   LabelPos event.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Will be fired before placing the label. By attaching it you
        ///     can change the Label position on your own.
        ///     See Paint for similar example.
        ///   </para>
        ///   <para>
        ///      See Paint for example.
        ///   </para>
        /// </remarks>
        event LabelPosEvent             : TGIS_ShapePosEvent
                                          delegate FOnLabelPos ;
      {$ELSE}
        /// <event/>
        /// <summary>
        ///   LabelPos event.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Will be fired before placing the label. By attaching it
        ///     you can change the Label position on your own.
        ///   </para>
        ///   <para>
        ///      See Paint for similar example.
        ///   </para>
        /// </remarks>
        property LabelPosEvent            : TGIS_ShapePosEvent
                                            read  FOnLabelPos
                                            write FOnLabelPos ;
      {$ENDIF}

      /// <event/>
      /// <summary>
      ///   CursorOpen event. Will be fired upon cursor open.
      /// </summary>
      property CursorOpenEvent            : TGIS_CursorEvent
                                            read  FOnCursorOpen
                                            write FOnCursorOpen ;

      /// <event/>
      /// <summary>
      ///   CursorClose event. Will be fired upon cursor close.
      /// </summary>
      property CursorCloseEvent           : TGIS_CursorEvent
                                            read  FOnCursorClose
                                            write FOnCursorClose ;

      /// <event/>
      /// <summary>
      ///   CursorBeforeFetch event. Will be fired before data fetch in
      ///   CursorFirst method.
      /// </summary>
      property CursorBeforeFetchEvent     : TGIS_CursorEvent
                                            read  FOnCursorBeforeFetch
                                            write FOnCursorBeforeFetch ;

      /// <event/>
      /// <summary>
      ///   CursorAfterFetch event. This will be fired after data is fetched in
      ///   CursorFirst method.
      /// </summary>
      property CursorAfterFetchEvent      : TGIS_CursorEvent
                                            read  FOnCursorAfterFetch
                                            write FOnCursorAfterFetch ;

      /// <event/>
      /// <summary>
      ///   OnCursorInterrupt event. Will be fired after interrupting reading.
      /// </summary>
      property CursorInterruptEvent       : TGIS_CursorEvent
                                            read  FOnCursorInterrupt
                                            write FOnCursorInterrupt ;

      /// <event/>
      /// <summary>
      ///   CursorShapeFetch event. Will be fired after shape fetch.
      /// </summary>
      property CursorShapeFetchEvent      : TGIS_ShapeEvent
                                            read  FOnCursorShapeFetch
                                            write FOnCursorShapeFetch ;
      {$IFDEF CLR}
        /// <event/>
        /// <summary>
        ///   ShapeGeometryChange event. Will be fired after a shape
        ///   geometry change.
        /// </summary>
        event ShapeGeometryChangeEvent  : TGIS_ShapeEvent
                                          delegate FOnShapeGeometryChange ;
      {$ELSE}
        /// <event/>
        /// <summary>
        ///   ShapeGeometryChange event. Will be fired after a shape
        ///   geometry change.
        /// </summary>
        property ShapeGeometryChangeEvent : TGIS_ShapeEvent
                                            read  FOnShapeGeometryChange
                                            write FOnShapeGeometryChange ;
      {$ENDIF}

      {$IFDEF CLR}
        /// <event/>
        /// <summary>
        ///   ShapeFieldChange event. Will be fired after a shape field change.
        /// </summary>
        event ShapeFieldChangeEvent     : TGIS_ShapeFieldChangeEvent
                                          delegate FOnShapeFieldChange ;
      {$ELSE}
        /// <event/>
        /// <summary>
        ///   ShapeFieldChange event. Will be fired after a shape field
        ///   change.
        /// </summary>
        property ShapeFieldChangeEvent    : TGIS_ShapeFieldChangeEvent
                                            read  FOnShapeFieldChange
                                            write FOnShapeFieldChange ;
      {$ENDIF}
  end ;

  /// <summary>
  ///   Vector layer enumerator.
  /// </summary>
  {$IFDEF ISLAND}[Export]{$ENDIF}
  {#typehint:iterator:TGIS_Shape}
  TGIS_LayerVectorEnumerator = {$IFDEF OXYGENE} public {$ENDIF} class( TObject
                                      {$IFDEF CLR} , IEnumerator<TObject> {$ENDIF}
                                      {$IFDEF JAVA}, java.util.Iterator<TObject> {$ENDIF}
                                     )

    private
    {$IFDEF OXYGENE} unit{$ENDIF}
      oFactory         : TGIS_LayerVectorEnumeratorFactory ;
      paramLayer       : TGIS_LayerVector ;
      paramExtent      : TGIS_Extent      ;
      paramQuery       : String           ;
      paramShape       : TGIS_Shape       ;
      paramDe9im       : String           ;
      paramSkipDeleted : Boolean          ;

      currBof          : Boolean          ;
      currCursor       : Integer          ;
      currShape        : TGIS_Shape       ;

      bSublayer        : Boolean          ;
    private
      {$IFDEF CLR}
        function   fget_current_obj : TObject ;
      {$ENDIF}
    public

      /// <summary>
      ///   Create an enumerator instance.
      /// </summary>
      /// <remarks>
      ///   This override should be used only within internal use of
      ///   TGIS_LayerVectorEnumeratorFactory
      /// </remarks>
      /// <param name="_factory">
      ///   reference to factory object which create this enumerator
      /// </param>
      /// <param name="_lv">
      ///   vector layer handle
      /// </param>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment
      /// </param>
      constructor Create         ( const _factory     : TGIS_LayerVectorEnumeratorFactory ;
                                   const _lv          : TGIS_LayerVector ;
                                   const _extent      : TGIS_Extent      ;
                                   const _query       : String           ;
                                   const _shape       : TGIS_Shape       ;
                                   const _de9im       : String           ;
                                   const _skipDeleted : Boolean
                                 ) ; overload;

      /// <summary>
      ///   Create an enumerator instance.
      /// </summary>
      /// <param name="_lv">
      ///   vector layer handle
      /// </param>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment
      /// </param>
      constructor Create         ( const _lv          : TGIS_LayerVector ;
                                   const _extent      : TGIS_Extent      ;
                                   const _query       : String           ;
                                   const _shape       : TGIS_Shape       ;
                                   const _de9im       : String           ;
                                   const _skipDeleted : Boolean
                                 ) ; overload;
      {$IFNDEF MANAGED}
        /// <summary>
        ///   Destroy an object.
        /// </summary>
        destructor Destroy       ; override;
      {$ELSE}
        /// <summary>
        ///   Destroy an object.
        /// </summary>
        procedure  Dispose       ;
      {$ENDIF}

      /// <summary>
      ///   Reset enumerator.
      /// </summary>
      procedure  Reset           ;

      /// <summary>
      ///   Move to next record
      /// </summary>
      /// <returns>
      ///   If false then there is no more shapes.
      /// </returns>
      function   MoveNext        : Boolean ;

    {$IFDEF GENXDK}
      protected
    {$ENDIF}

      /// <summary>
      ///   Get current enumerator value.
      /// </summary>
      /// <returns>
      ///   Shape itself or nil.
      /// </returns>
      function   GetCurrent      : TGIS_Shape ;

    public

      /// <summary>
      ///   Obtain a bind number for a given field name.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <returns>
      ///   Bind field id staring form 0 or -1 if not found.
      /// </returns>
      function BindField         ( const _name : String
                                 ) : Integer ;

      /// <summary>
      ///   Get field value for a shape given by unique identity.
      /// </summary>
      /// <param name="_field">
      ///   field bind number
      /// </param>
      /// <returns>
      ///   Field value.
      /// </returns>
      /// <remarks>
      ///   <para>
      ///     To obtain such identify call BindField.
      ///   </para>
      /// </remarks>
      function GetField          ( const _field : Integer
                                 ) : Variant ;

      {$IFDEF JAVA}
        /// <summary>
        ///   Java specific enumerator support method.
        /// </summary>
        /// <returns>
        ///   Java specific enumerator return value.
        /// </returns>
        method hasNext : Boolean ;

        /// <summary>
        ///   Java specific enumerator support method.
        /// </summary>
        /// <returns>
        ///   Java specific enumerator return value.
        /// </returns>
        method next : TObject;

        /// <summary>
        ///   Java specific enumerator support method.
        /// </summary>
        /// <returns>
        ///   Java specific enumerator return value.
        /// </returns>
        method &remove ;
      {$ENDIF}

    public

      /// <summary>
      ///   Current enumerator value.
      /// </summary>
      property  Current :
      {$IFNDEF CLR}
        TGIS_Shape  read GetCurrent      ;
      {$ELSE}
        TObject     read fget_current_obj ;
      {$ENDIF}

        /// <summary>
        ///   Current cursor index.
        /// </summary>
        property Cursor : Integer         read currCursor ;
  end;

  {$IFDEF CLR}
    /// <summary>
    ///   Enumerator class for LINQ.
    /// </summary>
    TGIS_LayerVectorEnumeratorFactoryLinq = {$IFDEF OXYGENE} public {$ENDIF}
                                            class( TObject, IEnumerable )
      private
       en : TGIS_LayerVectorEnumerator ;
      public

        /// <summary>
        ///   Constructor.
        /// </summary>
        /// <param name ="_en">
        ///   Enumerator reference
        /// </param>
        constructor Create( const _en : TGIS_LayerVectorEnumerator
                           ) ;

        /// <summary>
        ///   Get constructed enumerator.
        /// </summary>
        /// <returns>
        ///   Linq enumerator.
        /// </returns>
        function  GetEnumerator : IEnumerator ;
    end ;
  {$ENDIF}

  /// <summary>
  ///   Factory class for TGIS_LayerVectorEnumerator.
  /// </summary>
  /// <remarks>
  ///   To be used internally by TGIS_LayerVector.Loop().
  /// </remarks>
  {#typehint:iterator:TGIS_Shape}
  TGIS_LayerVectorEnumeratorFactory = {$IFDEF OXYGENE} public {$ENDIF} class
                                      {$IFDEF JAVA} (Iterable<TObject>) {$ENDIF}

    private
      stateLayer       : TGIS_LayerVector ;
      stateExtent      : TGIS_Extent      ;
      statequery       : String           ;
      stateShape       : TGIS_Shape       ;
      stateDe9im       : String           ;
      stateSkipDeleted : Boolean          ;
    public

      /// <summary>
      ///   Prepare enumerator.
      /// </summary>
      /// <param name="_lv">
      ///   vector layer handle
      /// </param>
      /// <param name="_extent">
      ///   extent of items to be found; expected _extent units  are in a
      ///   Layer coordinate space
      /// </param>
      /// <param name="_query">
      ///   query which must be matched by item; closely mimics SQL WHERE
      ///   clause; for examples you can use 'AGE &gt;= 18'; empty (default)
      ///   means that no items will match.
      /// </param>
      /// <param name="_shape">
      ///   if not nil, then only shapes matched _de9im matrix with _shape
      ///   will be found
      /// </param>
      /// <param name="_de9im">
      ///   DE-9IM matrix of comparison
      /// </param>
      /// <param name="_skipDeleted">
      ///   set a skip deleted treatment
      /// </param>
      procedure SetUp          ( const _lv          : TGIS_LayerVector ;
                                 const _extent      : TGIS_Extent      ;
                                 const _query       : String           ;
                                 const _shape       : TGIS_Shape       ;
                                 const _de9im       : String           ;
                                 const _skipDeleted : Boolean
                               ) ;
      {$IFDEF JAVA}
        /// <summary>
        ///   Java specific enumerator support method.
        /// </summary>
        /// <returns>
        ///   Java enumerator.
        /// </returns>
        method &iterator : java.util.Iterator<TObject> ;
      {$ENDIF}

      /// <summary>
      ///   Get constructed enumerator.
      /// </summary>
      /// <returns>
      ///   Enumerator object.
      /// </returns>
      function  GetEnumerator  : TGIS_LayerVectorEnumerator ;
      {$IFDEF CLR}

      /// <summary>
      ///   Get constructed enumerator for LINQ.
      /// </summary>
      /// <returns>
      ///   Linq enumerator.
      /// </returns>
      function  ToLinq         : TGIS_LayerVectorEnumeratorFactoryLinq ;
      {$ENDIF}
  end;

  /// <summary>
  ///   List of all shapes.
  /// </summary>
  TGIS_SelectedShapeList = {$IFDEF OXYGENE} public {$ENDIF}
                            class( TGIS_Object )
    public
      /// <summary>
      ///   Standard constructor.
      /// </summary>
      constructor Create ;

    protected
      procedure doDestroy ; override ;

    private
      oDictionary : TDictionary<TGIS_Uid,Boolean> ;
      arKeys : TArray<TGIS_Uid> ;

      function fget_Count : Integer ;
                          {$IFDEF GIS_INLINE} inline ; {$ENDIF}
      function fget_Item  ( const _index : Integer
                          ) : TGIS_Uid ;
                          {$IFDEF GIS_INLINE} inline ; {$ENDIF}

    public
      /// <summary>
      ///   Clear list.
      /// </summary>
      procedure Clear      ;

      /// <summary>
      ///   Test if UID is already in dictionary.
      /// </summary>
      /// <param name="_key">
      ///   UID of a shape
      /// </param>
      /// <returns>
      ///   True if item already exists.
      /// </returns>
      function  ContainsKey ( const _key   : TGIS_Uid
                            ) : Boolean  ;
                            {$IFDEF GIS_INLINE} inline ; {$ENDIF}

      /// <summary>
      ///   Add a new element to the list.
      /// </summary>
      /// <param name="_key">
      ///   UID of a shape
      /// </param>
      procedure Add         ( const _key   : TGIS_Uid
                            ) ;
                            {$IFDEF GIS_INLINE} inline ; {$ENDIF}

      /// <summary>
      ///   Remove an item from the dictionary.
      /// </summary>
      /// <param name="_key">
      ///   UID of an item to be removed
      /// </param>
      procedure Remove      ( const _key   : TGIS_Uid
                            ) ;
                            {$IFDEF GIS_INLINE} inline ; {$ENDIF}

      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      /// <summary>
      ///   Get enumerator.
      /// </summary>
      /// <returns>
      ///   Enumerator object.
      /// </returns>
      function GetEnumerator   : TEnumerator<TGIS_Uid> ;
                                 {$IFDEF GIS_INLINE} inline ; {$ENDIF}

      /// <summary>
      ///   Number of elements on the list.
      /// </summary>
      property Count        : Integer read fget_Count ;

      /// <summary>
      ///   Uid of shape.
      /// </summary>
      /// <param name="_index">
      ///   position in the list
      /// </param>
      property Items[ const _index : Integer ] : TGIS_Uid
                                                 read fget_Item ;
                                                 default ;
  end ;

  {#gendoc:hide:GENXDK}
  {#gendoc:hide:GENPDK}
  /// <summary>
  ///   Shapes list for Items.
  /// </summary>
  TGIS_ShapeList = {$IFDEF OXYGENE} public {$ENDIF} class( TObjectList<TGIS_Shape> )
    // must be defined as a full class not as an alias due to C++Builder < XE8  bug
  end;

  /// <summary>
  ///   Helper for merging the data into an existing layer.
  /// </summary>
  TGIS_LayerVectorMergeHelper = {$IFDEF OXYGENE} public  {$ENDIF}
                                class( TGIS_LayerVector )
    private
      oLayer     : TGIS_LayerVector ;
      iThreshold : Integer ;
    protected
      // destructor

      /// <summary>
      ///   Destructor.
      /// </summary>
      procedure doDestroy ; override;
    public

      /// <summary>
      ///   Constructor.
      /// </summary>
      constructor Create ; override;

      /// <summary>
      ///   Constructor.
      /// </summary>
      /// <param name="_layer">
      ///   existing layer handle
      /// </param>
      /// <param name="_threshold">
      ///   number of shapes that will be saved upon commit
      /// </param>
      constructor Create( const _layer     : TGIS_LayerVector ;
                          const _threshold : Integer
                        ) ; overload;

      /// <summary>
      ///   Commit data to a destination layer. The data write occurs if
      ///   number of shapes is greater than used threshold.
      /// </summary>
      procedure   Commit ;

      /// <summary>
      ///   Merge data with a destination layer.
      /// </summary>
      procedure   SaveData ; override;

    public

      /// <summary>
      ///   attached layer
      /// </summary>
      property Layer      : TGIS_LayerVector read  oLayer;

      /// <summary>
      ///   number of shapes that will be saved upon commit
      /// </summary>
      property Threshold  : Integer          read  iThreshold;
  end ;

  /// <summary>
  ///   Helper for direct writing into a layer storage.
  /// </summary>
  TGIS_LayerVectorDirectWriteHelper = {$IFDEF OXYGENE} public {$ENDIF} class
    private
      oLayer : TGIS_LayerVector ;
    public

      /// <summary>
      ///   Constructor.
      /// </summary>
      /// <param name="_layer">
      ///   existing layer handle
      /// </param>
      constructor Create( const _layer     : TGIS_LayerVector
                        ) ;

      /// <summary>
      ///   Adds a new shape to a storage.
      /// </summary>
      /// <param name="_shape">
      ///   shape to be added
      /// </param>
      procedure AddShape( const _shape : TGIS_Shape
                         ) ;

      /// <summary>
      ///   Builds new layer - prepares storage for direct writing.
      /// </summary>
      /// <param name="_path">
      ///   full path of layer to be built; a connection string for SQL base
      ///   shapes;
      /// </param>
      /// <param name="_extent">
      ///   starting extent of layer - can't be zero sized
      /// </param>
      /// <param name="_type">
      ///   shape type supported by a layer
      /// </param>
      /// <param name="_dim">
      ///   dimension; for default layer dimension use TGIS_DimensionType.Unknown
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNIMPLEMENTED
      /// </exception>
      /// <remarks>
      ///   Use this method to build a new layer (prepare storage) for direct
      ///   write.
      /// </remarks>
      procedure Build   ( const _path        : String           ;
                          const _extent      : TGIS_Extent      ;
                          const _type        : TGIS_ShapeType   ;
                          const _dim         : TGIS_DimensionType
                        ) ;

      /// <summary>
      ///   Finalizes direct writing into a layer storage.
      /// </summary>
      procedure Close ;
    public
      /// <summary>
      ///  Attached layer
      /// </summary>
      property Layer : TGIS_LayerVector read oLayer ;
  end ;
{$ENDREGION 'LayerVector and relative types'}

{$REGION 'TGIS_DynamicAggregatorAbstract'}
  /// <summary>
  ///   Base class for TGIS_LayerVector.DynamicAggregator implementation.
  ///   Purpose of this class is to dynamically add and hide shapes upon drawing
  ///   process. Sample use is dynamic binning or clustering.
  /// </summary>
  TGIS_DynamicAggregatorAbstract = {$IFDEF OXYGENE} public abstract {$ENDIF}
                                   class( TGIS_BaseObjectDisposable )
    private const
      AGGREGATOR_MIN_THRESHOLD = 0           ;
      AGGREGATOR_THRESHOLD     = 1           ;
      AGGREGATOR_RADIUS_TXT    = 'SIZE:80px' ;

    private
      iUidOffset    : Integer          ;

    private
    {$IFDEF OXYGENE} unit {$ENDIF}
      FName         : String           ;

    private
      FIsPreparing  : Boolean          ;
      FLayer        : TGIS_LayerVector ;

      FRadius       : Integer ;
      FRadiusAsText : String  ;
      FThreshold    : Integer ;

    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected
      /// <summary>
      ///   If true then initialization of visual appearance is blocked because
      ///   it is going to be read from a project/config file.
      /// </summary>
      useConfig     : Boolean;


    private
      procedure fset_Radius       ( const _value : Integer ) ;
      procedure fset_RadiusAsText ( const _value : String ) ;
      procedure fset_Threshold    ( const _value : Integer ) ;

    protected
      function  fget_Caption      : String ; virtual ;

    private
    {$IFDEF OXYGENE} unit {$ENDIF}
      /// <summary>
      ///   Clear processor context. Should be called at the and of any draw
      ///   process.
      /// </summary>
      procedure clearContext ;

      /// <summary>
      ///   Prepare processor context. Should be called upon Prepare().
      /// </summary>
      procedure prepareContext ;

    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected
      /// <summary>
      ///   Read config option parameters.
      /// </summary>
      /// <param name="_cfg">
      ///   configuration file object
      /// </param>
      procedure applyConfigOptions  ( const _cfg         : TGIS_ConfigAbstract
                                    ) ; virtual ;

       /// <summary>
       ///   Write config option parameters.
       /// </summary>
       /// <param name="_cfg">
       ///   configuration file object
       /// </param>
      procedure storeConfigOptions  ( const _cfg         : TGIS_ConfigAbstract
                                    ) ; virtual ;

       /// <summary>
       ///   Set shape type t be used by aggregator. Mainly for Legend control
       ///   and TGIS_LayerVector.SupportedShapesAll purposes.
       /// </summary>
       /// <param name="_type">
       ///   shape type to be used by aggregator.
       /// </param>
      procedure useShapeType        ( const _type        : TGIS_ShapeType
                                    ) ;

    public

      /// <summary>
      ///   Create a processor instance.
      /// </summary>
      /// <param name="_layer">
      ///   layer on which processor is constructed.
      /// </param>
      constructor Create             ( const _layer  : TGIS_LayerVector
                                     ) ; virtual ;

      /// <summary>
      ///   Perform internal aggregator setup. Called upon assigning object to
      ///   the DynamicAggregator property.
      /// </summary>
      /// <remarks>
      ///   It is important to call inherited method in a descendent objects
      ///   to support proper parameters restore.
      /// </remarks>
      procedure   SetUp              ; virtual ;

      /// <summary>
      ///   Prepares dynamic shapes. Implementation of this method should call
      ///   HideShape() and AddShape() methods.
      /// </summary>
      /// <param name="_extent">
      ///   extent for which layer should be looped
      /// </param>
      /// <param name="_query">
      ///   optional filter (e.g. scope value)
      /// </param>
      /// <remarks>
      ///   This method is called upon begging of each draw and dynamic shapes
      ///   are active only within draw.
      /// </remarks>
      procedure   Prepare            ( const _extent : TGIS_Extent ;
                                       const _query  : String
                                     ) ;  virtual ; abstract ;
      /// <summary>
      ///   Hide a shape against being drawn.
      /// </summary>
      /// <param name="_uid">
      ///   UID of shape to be hidden
      /// </param>
      procedure   HideShape          ( const _uid    : TGIS_Uid
                                     ) ;
      /// <summary>
      ///   Adds a new shape to be drawn
      /// </summary>
      /// <param name="_shape">
      ///   shape to be added be drawn
      /// </param>
      /// <param name="_attr">
      ///   optional shape attribute object to associate with _shape.TagPointer
      /// </param>
      /// <remarks>
      ///   Object _attr is own by processor and will be automatically
      ///   released.
      /// </remarks>
      procedure   AddShape           ( const _shape  : TGIS_Shape ;
                                       const _attr   : TObject
                                     ) ; overload ;

      /// <summary>
      ///   Adds a new shape to be drawn
      /// </summary>
      /// <param name="_shape">
      ///   shape to be added be drawn
      /// </param>
      /// <param name="_value">
      ///   aggregated value like number of aggregated shapes etc.
      /// </param>
      /// <param name="_uids">
      ///   list of shapes uid which shape aggregates.
      /// </param>
      procedure AddShape             ( const _shape  : TGIS_Shape ;
                                       const _value  : Variant    ;
                                       const _uids   : TGIS_UidArray
                                     ) ; overload ;

    public
      /// <summary>
      ///   Layer on which the processor is constructed.
      /// </summary>
      property Layer                 : TGIS_LayerVector read FLayer ;

      /// <summary>
      ///   True if aggregator is executing Prepare().
      /// </summary>
      property IsPreparing           : Boolean read FIsPreparing ;

      /// <summary>
      ///   Unique aggregator name.
      /// </summary>
      property Name                  : String read FName ;

      /// <summary>
      ///   User friendly name (translated).
      /// </summary>
      property Caption               : String
                                       read fget_Caption ;


      /// <summary>
      ///   Minimum number of shapes to form an aggregator.
      /// </summary>
      property Threshold             : Integer
                                       read  FThreshold
                                       write fset_Threshold ;

      /// <summary>
      ///   A radius within which shapes will be aggregated.
      /// </summary>
      property Radius                : Integer
                                       read  FRadius
                                       write fset_Radius ;

      /// <summary>
      ///   A radius within which shapes will be aggregated
      ///   expressed in human readable form, like '10pt', '3in'.
      ///   <para>
      ///     Uses AsText parameter syntax.
      ///   </para>
      /// </summary>
      property RadiusAsText          : String
                                       read  FRadiusAsText
                                       write fset_RadiusAsText;
  end;

  /// <summary>
  ///   Aggregated value to be stored in shape TagPointer property.
  /// </summary>
  TGIS_DynamicAggregatorValue = class
    public
     /// <summary>
     ///   Aggregated value like number of aggregated shapes etc.
     /// </summary>
     Value : Variant ;

     /// <summary>
     /// List of shapes uid which shape aggregates.
     /// </summary>
     Uids  : TGIS_UidArray ;
  end;

  /// <summary>
  ///   Factory to manage registration and initialization of aggregators.
  /// </summary>
  TGIS_DynamicAggregatorFactory = {$IFDEF OXYGENE} public {$ENDIF} class
    private
      class function fget_Names      : TStringList ; static ;
      class function allAggregators  : TDictionary<
                                         String,
                                         TGIS_DynamicAggregatorAbstractClass
                                       > ; static ;
    public
      {#gendoc:hide:GENXDK}
      {#gendoc:hide:GENPDK}
      {#gendoc:hide:GENSCR}
      /// <summary>
      ///   Register aggregator class
      /// </summary>
      /// <param name="_name">
      ///   unique aggregator name
      /// </param>
      /// <param name="_class">
      ///   aggregator class
      /// </param>
      class procedure &Register      ( const _name  : String ;
                                       const _class : TGIS_DynamicAggregatorAbstractClass
                                     ) ;

      /// <summary>
      ///   Create an instance of aggregator.
      /// </summary>
      /// <param name="_name">
      ///   unique aggregator name
      /// </param>
      /// <param name="_layer">
      ///   layer to be associated with aggregator instance
      /// </param>
      /// <returns>
      ///   Newly created instance or nil, if name not found
      /// </returns>
      class function  CreateInstance ( const _name  : String ;
                                       const _layer : TGIS_LayerVector
                                     ) : TGIS_DynamicAggregatorAbstract ;

    public
      /// <summary>
      ///   List off all names of registered aggregators.
      /// </summary>
      class property Names           : TStringList read fget_Names ;
   end ;

{$ENDREGION 'TGIS_DynamicAggregatorAbstract'}

{$REGION 'Shapes types'}
  /// <summary>
  ///   Generic shape class. This class keeps all functionality of a shape.
  /// </summary>
  {$IFDEF ISLAND}[Export]{$ENDIF}
  TGIS_Shape = {$IFDEF OXYGENE} public abstract {$ENDIF}
               class( TGIS_ShapeAbstract )

    // property internal values
    {$IFNDEF OXYGENE} private {$ELSE} assembly or protected {$ENDIF}
       /// <summary>
       ///   Tag value.
       /// </summary>
       FTag         : NativeInt ;

       /// <summary>
       ///   Pointer Tag value.
       /// </summary>
       FTagPointer  :
         {$IFDEF MANAGED}
           Object ;
         {$ELSE}
           Pointer ;
         {$ENDIF}

       /// <summary>
       ///   Internal Tag value.
       /// </summary>
       FTagInternal : NativeInt ;


       /// <summary>
       ///   which cursor owns the shape.
       /// </summary>
       FCursor : Integer ;

       /// <summary>
       ///   Is shape 3D ?
       /// </summary>
       FShape3D : Boolean ;

       /// <summary>
       ///   Is shape empty ?
       /// </summary>
       FIsEmpty : Boolean ;

       /// <summary>
       ///   Layer which own this shape.
       /// </summary>
       {$IFDEF DCC} [unsafe] {$ENDIF}
       FLayer : TGIS_LayerVector ;

       /// <summary>
       ///   True if the Shape rtree index must be managed.
       /// </summary>
       FManageRTree : Boolean ;

       /// <summary>
       ///   Parameters (color, fills) etc.
       /// </summary>
       FParams : TGIS_ParamsSectionVector ;

       /// <summary>
       ///   Parent shape handle.
       /// </summary>
       FParent : TGIS_Shape ;

    // properties access function
    {$IFDEF OXYGENE} assembly or protected {$ELSE} protected {$ENDIF}
      function  fget_Uid          : TGIS_Uid ;
      procedure fset_Tag          ( const _value : NativeInt ) ;
      function  fget_Tag          : NativeInt ;
      {$IFDEF MANAGED}
        procedure fset_TagPointer ( const _value : Object  ) ;
        function  fget_TagPointer : Object ;
      {$ELSE}
        procedure fset_TagPointer ( const _value : Pointer ) ;
        function  fget_TagPointer : Pointer ;
      {$ENDIF}
      procedure fset_TagInternal  ( const _value : NativeInt ) ;
      function  fget_TagInternal  : NativeInt ;
      function  fget_Viewer       : TGIS_ViewerRef     ;
                                    {$IFDEF GIS_INLINE} inline ; {$ENDIF}
      function  fget_Params       : TGIS_ParamsSectionVector ;
                                    {$IFDEF GIS_INLINE}
                                      {$IFNDEF GIS_INLINE_BUG}
                                        inline ;
                                      {$ENDIF}
                                    {$ENDIF}
      procedure fset_Params       ( const _value : TGIS_ParamsSectionVector ) ;
      {$IFDEF MANAGED}
        function  fget_Parts      : TBytes             ;
        function  fget_PartTypes  : TBytes             ;
      {$ENDIF}
      function  fget_PartsSize    : Integer            ;
      {$IFDEF MANAGED}
        function  fget_Points     : TBytes             ;
        function  fget_PointsZ    : TBytes             ;
        function  fget_PointsM    : TBytes             ;
      {$ENDIF}
      function  fget_PointsSize   : Integer            ;
      function  fget_PointsZSize  : Integer            ;
      function  fget_PointsMSize  : Integer            ;
      function  fget_PointsZMin   : Double             ; virtual;
      function  fget_PointsZMax   : Double             ; virtual;
      function  fget_PointsMMin   : Double             ; virtual;
      function  fget_PointsMMax   : Double             ; virtual;
      function  fget_PartTypesSize: Integer            ;
      function  fget_GeometrySize : Integer            ;
      function  fget_IsEditable   : Boolean            ;
      function  fget_LocalParams  : Boolean            ;
      procedure fset_LocalParams  ( const _value : Boolean
                                  ) ;
      function  fget_ManageRTree  : Boolean            ;
      procedure fset_Layer        ( const _layer : TGIS_LayerVector
                                  ) ; virtual;
      function  fget_GeometryChanged : Boolean         ;
      function  fget_FieldChanged : Boolean            ;
      function  fget_IsSelected   : Boolean            ;
      procedure fset_IsSelected   ( const _value : Boolean
                                  ) ; virtual;
      function  fget_Extent          : TGIS_Extent     ; virtual;
      function  fget_Extent3D        : TGIS_Extent3D   ; virtual;
      function  fget_ProjectedExtent : TGIS_Extent     ; virtual;
      function  fget_SmartSize       : Integer         ; virtual; abstract;

    // other protected function
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <summary>
      ///   Calculate a part offset. Not Valid for TGIS_Point and
      ///   TGIS_MultiPoint.
      /// </summary>
      /// <param name="_part">
      ///   number of part
      /// </param>
      /// <returns>
      ///   Offset of part within shape geometry..
      /// </returns>
      function  getPartOffset      ( _part : Integer
                                   ) : Integer ; virtual;

      /// <summary>
      ///   Check if shape is geometry is empty.
      /// </summary>
      /// <returns>
      ///   True if geometry is empty.
      /// </returns>
      function  checkIsEmpty       : Boolean ; virtual;

    // other private values
    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}

        /// <summary>
        ///   mode of locking
        /// </summary>
        lockMode : TGIS_Lock ;

        /// <summary>
        ///   True if extent should be recalculated upon unlock. Provided
        ///   to optimize Unlocking of shape which has not been modified
        ///   within Lock..Unlock block.
        /// </summary>
        lockModified : Boolean ;

    // ordinal internal values
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

        /// <summary>
        ///   list of fields.
        /// </summary>
        mappedFields : TGIS_FieldList ;

        /// <summary>
        ///   Get old extent for current shape (before editing). Used for
        ///   UpdateIndex.
        /// </summary>
        oldIndexExtent : TGIS_Extent  ;

        /// <summary>
        ///   Used to limit Distance2PartCS to the neighborhood of a specific
        ///   point. Don't use outside Distance2PartCS!}
        /// </summary>
        indexDist2PartCS : Integer ;

    // property internal values
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <summary>
      ///   Internal storage of points. Closely matches SHP representation
      ///   for fast mapped file purposes.
      /// </summary>
      FPoints :
      {$IFDEF MANAGED}
        TGIS_Bytes ;
      {$ELSE}
        Pointer ;
      {$ENDIF}

      /// <summary>
      ///   Internal storage of parts. Closely matches SHP representation
      ///   for fast mapped file purposes.
      /// </summary>
      FParts :
      {$IFDEF MANAGED}
        TGIS_Bytes ;
      {$ELSE}
        Pointer ;
      {$ENDIF}

      /// <summary>
      ///   Internal storage of points. Closely matches SHP representation
      ///  for fast mapped file purposes.
      /// </summary>
      FPointsZ :
      {$IFDEF MANAGED}
        TGIS_Bytes ;
      {$ELSE}
        Pointer ;
      {$ENDIF}

        /// <summary>
        ///   Minimum Z value.
        /// </summary>
        FPointsZMin : Double ;

        /// <summary>
        ///   Maximum Z value.
        /// </summary>
        FPointsZMax : Double ;

      /// <summary>
      ///   Internal storage of points. Closely matches SHP
      ///   representation for fast mapped file purposes.
      /// </summary>
      FPointsM :
      {$IFDEF MANAGED}
         TGIS_Bytes ;
      {$ELSE}
         Pointer ;
      {$ENDIF}

        /// <summary>
        ///   Minimum M value.
        /// </summary>
        FPointsMMin : Double ;

        /// <summary>
        ///   Maximum M value.
        /// </summary>
        FPointsMMax : Double ;

      /// <summary>
      ///   Internal storage of part types. Closely matches SHP
      ///   representation for fast mapped file purposes.
      /// </summary>
      FPartTypes :
      {$IFDEF MANAGED}
         TGIS_Bytes ;
      {$ELSE}
         Pointer ;
      {$ENDIF}

        /// <summary>
        ///   Unique identifier across a single layer.
        /// </summary>
        FUid         : TGIS_Uid ;

        /// <summary>
        ///   Object type.
        /// </summary>
        FShapeType   : TGIS_ShapeType ;

        /// <summary>
        ///   True if geometry not allocated but mapped to a file.
        /// </summary>
        FIsMapped    : Boolean ;

        /// <summary>
        ///   True if the Shape needs to be reverted to version saved in
        ///   file.
        /// </summary>
        FIsReverted  : Boolean ;

        /// <summary>
        ///   True if the Shape needs to be deleted. Deleted will still
        ///   exist up to nearest save, but will not be displayed.
        /// </summary>
        FIsDeleted   : Boolean ;

        /// <summary>
        ///   True if the Shape has checked and fixed winding.
        /// </summary>
        FIsFixed     : Boolean ;

        /// <summary>
        ///   Is shape hidden. Treat it as turn On/Off.
        /// </summary>
        FIsHidden    : Boolean ;

        /// <summary>
        ///   Is shape editable.
        /// </summary>
        FIsEditable  : Boolean ;

        /// <summary>
        ///   Is shape a independent object or is a mirror of disk based
        ///   shape.
        /// </summary>
        FIsNewShape  : Boolean ;

        /// <summary>
        ///   Is shape (geometry or fields) modified.
        /// </summary>
        FIsModified  : Boolean ;

        /// <summary>
        ///   Has shape geometry changed.
        /// </summary>
        FGeometryChanged : Boolean ;

        /// <summary>
        ///   Dimensions supported by a shape.
        /// </summary>
        FDimension   : TGIS_DimensionType ;

    // Geometry access supporting function
    {$IFNDEF OXYGENE} protected {$ELSE} assembly {$ENDIF}

      /// <summary>
      ///   Copy internal mapped fields from one shape to another.
      /// </summary>
      /// <param name="_src">
      ///   source shape
      /// </param>
      /// <param name="_dst">
      ///   destination shape
      /// </param>
      procedure copyInternalFields  ( const _src : TGIS_Shape ;
                                      const _dst : TGIS_Shape
                                    ) ;
      /// <summary>
      ///   Copy internal Params from one shape to another.
      /// </summary>
      /// <param name="_src">
      ///   source shape
      /// </param>
      /// <param name="_dst">
      ///   destination shape
      /// </param>
      procedure copyInternalParams  ( const _src : TGIS_Shape ;
                                      const _dst : TGIS_Shape
                                    ) ;
    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}
      /// <summary>
      ///   Set new point value.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   point number; if -1, then point will be added at tail
      /// </param>
      /// <param name="_ptg">
      ///   point to be set; in layer units
      /// </param>
      procedure setPoint           ( const _part : Integer ;
                                     const _pos  : Integer ;
                                     const _ptg  : TGIS_Point
                                   ) ; virtual;

      /// <summary>
      ///   Set new point value in 3D.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   point number; if -1, then point will be added at tail
      /// </param>
      /// <param name="_ptg">
      ///   point to be set; in layer units
      /// </param>
      procedure setPoint3D         ( const _part : Integer ;
                                     const _pos  : Integer ;
                                     const _ptg  : TGIS_Point3D
                                   ) ; virtual;

      /// <summary>
      ///   Insert new point.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   position before that the point will be inserted ; if -1, then
      ///   point will be added at tail of part
      /// </param>
      /// <param name="_ptg">
      ///   point to be insert; in layer units
      /// </param>
      procedure insertPoint        ( const _part : Integer ;
                                     const _pos  : Integer ;
                                     const _ptg  : TGIS_Point
                                   ) ; virtual;

      /// <summary>
      ///   Insert new point.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   position before that the point will be inserted ; if -1, then
      ///   point will be added at tail of part
      /// </param>
      /// <param name="_ptg">
      ///   point to be insert; in layer units
      /// </param>
      procedure insertPoint3D      ( const _part : Integer ;
                                     const _pos  : Integer ;
                                     const _ptg  : TGIS_Point3D
                                   ) ; virtual;

      /// <summary>
      ///   Delete point.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   position that the point will be removed ; if -1, then point will
      ///   be removed from tail of part
      /// </param>
      procedure deletePoint        ( const _part : Integer ;
                                     const _pos  : Integer
                                   ) ; virtual;

      /// <summary>
      ///   Delete point.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   position that the point will be removed ; if -1, then point will
      ///   be removed from tail of part
      /// </param>
      procedure deletePoint3D      ( const _part : Integer ;
                                     const _pos  : Integer
                                   ) ; virtual;


    {$IFNDEF OXYGENE} private {$ELSE} unit {$ENDIF}
      /// <summary>
      ///   Create new shape from defined part of Self (copy).
      /// </summary>
      /// <param name="_part">
      ///   defined part index
      /// </param>
      /// <param name="_only_add_part">
      ///   if True, only geometry from defined part is copied to _shape
      ///   as new part;
      ///   if False, new shape is created, fields are copied from Self,
      ///   geometry is copied from defined part
      /// </param>
      /// <param name="_shape">
      ///   the shape to which copy is to be assigned
      /// </param>
      procedure createShapeFromPart( const _part          : Integer ;
                                     const _only_add_part : Boolean ;
                                     var   _shape         : TGIS_Shape
                                   ) ;


      /// <summary>
      ///   Ensure that current polygon part is closed, and current
      ///   line has at least two points.
      /// </summary>
      procedure ensureProperPart ;

    // other protected
    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}

      /// <summary>
      ///   Synchronize the joining on a current shape.
      /// </summary>
      /// <param name="_cursor">
      ///   cursor index
      /// </param>
      /// <returns>
      ///   If true then join is in sync.
      /// </returns>
      function  syncJoin           ( const _cursor : Integer
                                   ) : Boolean ; overload;

      /// <summary>
      ///   Synchronize the joining on a current shape.
      /// </summary>
      /// <returns>
      ///   If true then join is in sync.
      /// </returns>
      function  syncJoin           : Boolean ; overload;

      {$IFDEF MANAGED}

        /// <summary>
        ///   Prepare Parts & Points pointers to the provided geometry.
        /// </summary>
        /// <param name="_ptr">
        ///   pointer to geometry
        /// </param>
        procedure prepareGeometry  ( const _ptr : TGIS_Bytes )  ;
      {$ELSE}

        /// <summary>
        ///   Prepare Parts &amp; Points pointers to the provided geometry.
        /// </summary>
        /// <param name="_ptr">
        ///   pointer to geometry
        /// </param>
        procedure prepareGeometry  ( const _ptr : Pointer )  ;
      {$ENDIF}

      /// <summary>
      ///   Allocate memory and copy data from geometry pointer.
      /// </summary>
      /// <remarks>
      ///   Memory is always allocated in DATA_CHUNCK_SIZE units.
      /// </remarks>
      procedure duplicateGeometry  ;

      /// <summary>
      ///   Copy data from mapped file to allocated geometry.
      /// </summary>
      procedure unmapGeometry      ;

      /// <summary>
      ///   Reallocate geometry.
      /// </summary>
      /// <remarks>
      ///   If a geometry has place only for one TGIS_Point, then a geometry
      ///   will be reallocated to a size greater by DATA_CHUNK_SIZE. If
      ///   geometry is nil then DATA_CHUNK_SIZE will be allocated.
      /// </remarks>
      procedure reallocGeometry    ;

      /// <summary>
      ///   Mark layer as modified. Used to check if a layer should be saved
      ///   and fire events notifying a change.
      /// </summary>
      /// <param name="_geometry">
      ///   if True, a shape geometry was changed
      /// </param>
      procedure layerModified      ( const _geometry      : Boolean
                                   ) ;

      /// <summary>
      ///   Set up extent of base shape on point position.
      /// </summary>
      /// <param name="_ptg">
      ///   point on which extent is set up; in layer units
      /// </param>
      /// <remarks>
      ///   If point is outside an extent, then the extent will be extended.
      ///   For an empty shape, the extent is initiating to the given point.
      /// </remarks>
      procedure setExtentByPoint   ( const _ptg  : TGIS_Point
                                   ) ; virtual;

      /// <summary>
      ///   Set up extent of base shape on point 3D position.
      /// </summary>
      /// <param name="_ptg">
      ///   point on which extent is set up; in layer units
      /// </param>
      /// <remarks>
      ///   If point is outside an extent, then the extent will be extended.
      ///   For an empty shape, the extent is initiating to the given point.
      /// </remarks>
      procedure setExtentByPoint3D ( const _ptg  : TGIS_Point3D
                                   ) ; virtual;

      /// <summary>
      ///   Cut the shape in a defined extent.
      /// </summary>
      /// <param name="_extent">
      ///   extent to be cut with
      /// </param>
      /// <param name="_lockInternal2">
      ///   if True, then the shape should be left locked as
      ///   TGIS_Lock.Internal2; it will be used to avoid multiple
      ///   reprojection of the truncated shape
      /// </param>
      /// <returns>
      ///   Normalized shape (a new copy) or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to find intersection of a shape with given
      ///   extent and get a pointer to the new normalized shape.
      /// </remarks>
      function  getIntersectInternal
                                   ( const _extent        : TGIS_Extent ;
                                     const _lockInternal2 : Boolean
                                   ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Cut the shape in a defined extent.
      /// </summary>
      /// <param name="_extent">
      ///   extent to be cut with
      /// </param>
      /// <param name="_lockInternal2">
      ///   if True, then the shape should be left locked as
      ///   TGIS_Lock.Internal2; it will be used to avoid multiple
      ///   reprojection of the truncated shape
      /// </param>
      /// <returns>
      ///   Normalized shape (a new copy) or nil.
      /// </returns>
      /// <remarks>
      ///   Use this method to find intersection of a shape with given
      ///   extent and get a pointer to the new normalized shape.
      /// </remarks>
      function  getIntersectInternal3D
                                   ( const _extent        : TGIS_Extent ;
                                     const _lockInternal2 : Boolean
                                   ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Parse label string (to expand fields etc.). Expands old
      ///   formatting (':\&lt;field\&gt;')
      /// </summary>
      /// <returns>
      ///   Label text.
      /// </returns>
      function  getLabelOld        : String ;

      /// <summary>
      ///   Parse label string (to expand fields etc.).
      /// </summary>
      /// <returns>
      ///   Label text.
      /// </returns>
      function  getLabelInternal   : String ;

      /// <summary>
      ///   Prepare truncated shape.
      /// </summary>
      /// <param name="_restrictive">
      ///   <list type="bullet">
      ///     <item>
      ///       False - VisibleExtent + 1 inch margin
      ///     </item>
      ///     <item>
      ///       True - VisibleExtent extent only
      ///     </item>
      ///   </list>
      /// </param>
      /// <returns>
      ///   Truncated shape (a new copy), nil or self object.
      /// </returns>
      /// <remarks>
      ///   Used to truncate shape to a drawing rectangle to avoid
      ///   costly rendering outside of visible scope.
      /// </remarks>
      function  getTruncatedShape  ( const _restrictive    : Boolean
                                   ) : TGIS_Shape  ;

      /// <summary>
      ///   Prepare truncated shape.
      /// </summary>
      /// <returns>
      ///   Truncated shape (a new copy), nil or self object.
      /// </returns>
      /// <remarks>
      ///   Used to truncate shape to a drawing rectangle to avoid
      ///   costly rendering outside of visible scope for labeling and
      ///   charting purposes.
      /// </remarks>
      function  getTruncatedShapeEx : TGIS_Shape  ;

      /// <summary>
      ///   Verify if point should be truncated
      /// </summary>
      /// <param name="_ptg">
      ///   point to be checked
      /// </param>
      /// <param name="_restrictive">
      ///   <list type="bullet">
      ///     <item>
      ///       False - VisibleExtent + 1 inch margin
      ///     </item>
      ///     <item>
      ///       True - VisibleExtent extent only
      ///     </item>
      ///   </list>
      /// </param>
      /// <returns>
      ///   True if point should be truncated,
      /// </returns>
      /// <remarks>
      ///   Used to truncate shape to a drawing rectangle to avoid
      ///   costly rendering outside of visible scope.
      /// </remarks>
      function  isTruncatedPoint   ( const _ptg            : TGIS_Point ;
                                     const _restrictive    : Boolean
                                   ) : Boolean ;

      /// <summary>
      ///   Verify if point should be truncated
      /// </summary>
      /// <param name="_ptg">
      ///   point to be checked
      /// </param>
      /// <returns>
      ///   True if point should be truncated,
      /// </returns>
      /// <remarks>
      ///   Used to truncate shape to a drawing rectangle to avoid
      ///   costly rendering outside of visible scope for labeling and
      ///   charting purposes.
      /// </remarks>
      function  isTruncatedPointEx ( const _ptg            : TGIS_Point
                                   ) : Boolean ;

      /// <summary>
      ///   Frees truncated shape, but also checks if truncated shape was
      ///   really created.
      /// </summary>
      /// <param name="_shape">
      ///   truncated shape
      /// </param>
      procedure freeTruncatedShape (   var _shape          : TGIS_Shape
                                   ) ;

      /// <summary>
      ///   Prepare a pen and a brush to draw tracking points.
      /// </summary>
      procedure prepareTrackingPoints ;

    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}

      /// <summary>
      ///   Convert a point in the working coordinates (viewer or layer)
      ///   to WGS84.
      /// </summary>
      /// <param name="_pt">
      ///   the point to convert
      /// </param>
      /// <returns>
      ///   Converted point.
      /// </returns>
      function pointToWGS       ( const _pt : TGIS_Point
                                ) : TGIS_Point ;
      /// <summary>
      ///   Convert a point in WGS84 to the working coordinates
      ///   (viewer or layer).
      /// </summary>
      /// <param name="_pt">
      ///   the point to convert
      /// </param>
      /// <returns>
      ///   Converted point.
      /// </returns>
      function pointFromWGS     ( const _pt : TGIS_Point
                                ) : TGIS_Point ;
      /// <summary>
      ///   Calculate the distance between two points along a grand circle
      ///   using the Haversine Formula. Coordinates must be supplied in
      ///   WGS84 in radians.
      /// </summary>
      /// <param name="_p1">
      ///   the first point
      /// </param>
      /// <param name="_p2">
      ///   the second point
      /// </param>
      /// <returns>
      ///   Distance in meters.
      /// </returns>
      function haversineFormula ( const _p1 : TGIS_Point ;
                                  const _p2 : TGIS_Point
                                ) : Double ;
      /// <summary>
      ///   Calculate the distance between two points on the WGS84
      ///   ellipsoid. Coordinates must be supplied in WGS84 in radians.
      /// </summary>
      /// <param name="_p1">
      ///   the first point
      /// </param>
      /// <param name="_p2">
      ///   the second point
      /// </param>
      /// <returns>
      ///   Distance in meters.
      /// </returns>
      function distanceWGS      ( const _p1 : TGIS_Point ;
                                  const _p2 : TGIS_Point
                                ) : Double ;
      /// <summary>
      ///   Calculate the distance between a point and a line segment
      ///   (i.e. a section of a grand circle). Coordinates must be
      ///   supplied in WGS84 in radians.
      /// </summary>
      /// <param name="_p0">
      ///   the point to calculate the distance to
      /// </param>
      /// <param name="_p1">
      ///   the beginning point of the line segment
      /// </param>
      /// <param name="_p2">
      ///   the end point of the line segment
      /// </param>
      /// <param name="_togc">
      ///   True if the distance is to be calculated to
      ///   the whole grand circle, not only the section
      /// </param>
      /// <param name="_out">
      ///   the point on the segment/grand circle closest to _p0
      /// </param>
      /// <returns>
      ///   Distance in meters.
      /// </returns>
      function distance2SegmentWGS
                                ( const _p0   : TGIS_Point ;
                                  const _p1   : TGIS_Point ;
                                  const _p2   : TGIS_Point ;
                                  const _togc : Boolean ;
                                    out _out  : TGIS_Point
                                ) : Double ;

      /// <summary>
      ///   Get built-in field value.
      /// </summary>
      /// <param name="_id">
      ///   virtual field ID
      /// </param>
      /// <param name="_iscs">
      ///   True if specified CS; False otherwise
      /// </param>
      /// <returns>
      ///   calculated field value
      /// </returns>
      function getVirtualField  ( const _id     : Integer ;
                                  const _iscs   : Boolean
                                ) : Variant ;

    public // constructors

      /// <summary>
      ///   Create a shape instance.
      /// </summary>
      /// <remarks>
      ///   <note type="note">
      ///    For usage TGIS_LayerVector.CreateShape method is recommended
      ///    instead.
      ///    </note>
      ///   <para>
      ///     Use this method to create a shape. Internally it calls
      ///     Recreate method.
      ///   </para>
      /// </remarks>
      constructor Create     ; overload;
                               {$IFNDEF CLR} virtual; {$ENDIF}

      /// <summary>
      ///   Create a shape instance.
      /// </summary>
      /// <param name="_source">
      ///   If not nil then base shape will be based on this shape.
      ///   Otherwise _prt, _mapped, _uid and _layer will be used.
      /// </param>
      /// <param name="_ptr">
      ///   Address in memory where shape data exists.
      /// </param>
      /// <param name="_mapped">
      ///   Id _ptr from mapped file or from memory.
      /// </param>
      /// <param name="_uid">
      ///   Unique identity for shape.
      /// </param>
      /// <param name="_layer">
      ///   Reference to the layer on which shape will be created.
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    For usage TGIS_LayerVector.CreateShape method is recommended
      ///    instead.
      ///    </note>
      ///   <para>
      ///     Use this method to create a shape. Internally it calls
      ///     Recreate method.
      ///   </para>
      /// </remarks>
      constructor Create     ( const _source : TGIS_Shape ;
                               {$IFDEF MANAGED}
                                 const _ptr  : TGIS_Bytes ;
                               {$ELSE}
                                 const _ptr  : Pointer    ;
                               {$ENDIF}
                               const _mapped : Boolean    ;
                               const _uid    : TGIS_Uid      ;
                               const _layer  : TGIS_LayerVector
                             ) ; overload;
                               {$IFNDEF CLR} virtual; {$ENDIF}

      /// <summary>
      ///   Create a shape instance.
      /// </summary>
      /// <param name="_source">
      ///   If not nil then base shape will be based on this shape.
      ///   Otherwise _prt, _mapped, _uid and _layer will be used.
      /// </param>
      /// <param name="_ptr">
      ///   Address in memory where shape data exists.
      /// </param>
      /// <param name="_mapped">
      ///   Id _ptr from mapped file or from memory.
      /// </param>
      /// <param name="_uid">
      ///   Unique identity for shape.
      /// </param>
      /// <param name="_layer">
      ///   Reference to the layer on which shape will be created.
      /// </param>
      /// <param name="_dim">
      ///   Dimension
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    For usage TGIS_LayerVector.CreateShape method is recommended
      ///    instead.
      ///    </note>
      ///   <para>
      ///     Use this method to create a shape. Internally it calls
      ///     Recreate method.
      ///   </para>
      /// </remarks>
      constructor Create     ( const _source : TGIS_Shape ;
                               {$IFDEF MANAGED}
                                 const _ptr  : TGIS_Bytes ;
                               {$ELSE}
                                 const _ptr  : Pointer    ;
                               {$ENDIF}
                               const _mapped : Boolean    ;
                               const _uid    : TGIS_Uid      ;
                               const _layer  : TGIS_LayerVector ;
                               const _dim    : TGIS_DimensionType
                             ) ; overload; virtual;

      /// <summary>
      ///   Create a shape instance.
      /// </summary>
      /// <param name="_dim">
      ///   Dimension
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    For usage TGIS_LayerVector.CreateShape method is recommended
      ///    instead.
      ///    </note>
      ///   <para>
      ///     Use this method to create a shape. Internally it calls
      ///     Recreate method.
      ///   </para>
      /// </remarks>
      constructor Create       ( const _dim    : TGIS_DimensionType
                               ) ; overload; virtual;

      {$IFNDEF OXYGENE}

        /// <summary>
        ///   Destroy a shape instance.
        /// </summary>
        /// <remarks>
        ///   Use this method to destroy a shape instance. It will free
        ///   memory if the shape is allocated in memory /it can also be
        ///   mapped to the disk file/.
        /// </remarks>
        destructor  Destroy    ; override;
      {$ENDIF}

      /// <summary>
      ///   Create a copy of the current shape.
      /// </summary>
      /// <returns>
      ///   Newly created copy of the shape.
      /// </returns>
      function    CreateCopy   : TGIS_Shape ; virtual;

      /// <summary>
      ///   Create a copy of the current shape reprojected form the layer
      ///   coordinate system into a provided coordinate system. If shape is
      ///   not a member of the layer, then simply a shape copy will be
      ///   returned.
      /// </summary>
      /// <param name="_cs">
      ///   desired coordinate system to be converted to
      /// </param>
      /// <returns>
      ///   A a reprojected shape (new copy).
      /// </returns>
      function    CreateCopyCS ( const _cs     : TGIS_CSCoordinateSystem
                               ) : TGIS_Shape ;

      /// <summary>
      ///   Recreate an instance.
      /// </summary>
      /// <param name="_source">
      ///   If not nil, then the base shape will be based on this shape.
      ///   Otherwise _ptr, _uid and _layer will be used.
      /// </param>
      /// <param name="_mapped">
      ///   True if pointer is mapped to the file
      /// </param>
      /// <param name="_ptr">
      ///   Address in memory where shape data exists.
      /// </param>
      /// <param name="_uid">
      ///   Unique identifier for shape.
      /// </param>
      /// <param name="_layer">
      ///   Reference to the layer on which the shape will be created.
      /// </param>
      /// <remarks>
      ///   Use this method to recreate an instance with new basic values.
      ///   Needed for faster FindNext in mapped file shapes. In such a
      ///   situation shapes will be "reused" in FindNext loop. See Create
      ///   method for details and example.
      /// </remarks>
      procedure   Recreate     ( const _source : TGIS_Shape              ;
                                 {$IFDEF MANAGED}
                                   const _ptr  : TGIS_Bytes              ;
                                 {$ELSE}
                                   const _ptr  : Pointer                 ;
                                 {$ENDIF}
                                 const _mapped : Boolean                 ;
                                 const _uid    : TGIS_Uid                   ;
                                 const _layer  : TGIS_LayerVector
                               ) ; overload; virtual;

      /// <summary>
      ///   Recreate an instance.
      /// </summary>
      /// <param name="_source">
      ///   If not nil, then the base shape will be based on this shape.
      ///   Otherwise _ptr, _uid and _layer will be used.
      /// </param>
      /// <param name="_mapped">
      ///   True if pointer is mapped to the file
      /// </param>
      /// <param name="_ptr">
      ///   Address in memory where shape data exists.
      /// </param>
      /// <param name="_uid">
      ///   Unique identifier for shape.
      /// </param>
      /// <param name="_layer">
      ///   Reference to the layer on which the shape will be created.
      /// </param>
      /// <param name="_dim">
      ///   Dimension.
      /// </param>
      /// <remarks>
      ///   Use this method to recreate an instance with new basic values.
      ///   Needed for faster FindNext in mapped file shapes. In such a
      ///   situation shapes will be "reused" in FindNext loop. See Create
      ///   method for details and example.
      /// </remarks>
      procedure   Recreate     ( const _source : TGIS_Shape              ;
                                 {$IFDEF MANAGED}
                                   const _ptr  : TGIS_Bytes              ;
                                 {$ELSE}
                                   const _ptr  : Pointer                 ;
                                 {$ENDIF}
                                 const _mapped : Boolean                 ;
                                 const _uid    : TGIS_Uid                   ;
                                 const _layer  : TGIS_LayerVector        ;
                                 const _dim    : TGIS_DimensionType
                               ) ; overload; virtual;

      /// <summary>
      ///   Prepare reprojected shape, truncated by extent and copy fields
      ///   to the result.
      /// </summary>
      /// <param name="_cs">
      ///   coordinate system
      /// </param>
      /// <param name="_extent">
      ///   extent used to truncate shape (in a same space as _cs)
      /// </param>
      /// <param name="_truncate">
      ///   If True, the result shape will be truncated
      /// </param>
      /// <param name="_copyfield">
      ///   If True, the result shape will copy the source fields
      /// </param>
      /// <returns>
      ///   Shape prepared for export. If shape as not truncated not reprojected
      ///   then is same as shape itself; otherwise a new object is created.
      /// </returns>
      function PrepareExportShape
                               ( const _cs         : TGIS_CSCoordinateSystem ;
                                 const _extent     : TGIS_Extent         ;
                                 const _truncate   : Boolean             ;
                                 const _copyfield  : Boolean
                               ) : TGIS_Shape ;

      /// <summary>
      ///   Prepare params.
      /// </summary>
      /// <param name="_value">
      ///   reference section
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    Only for internal use of TatukGIS.
      ///    </note>
      /// </remarks>
      procedure SetParamsInternal
                               ( const _value      : TGIS_ParamsSectionVector
                               ) ;

    public // API
      /// <summary>
      ///   Flash shape on screen with default parameters
      ///   (_times equals 4 and _delay equals 100).
      /// </summary>
      procedure Flash          ; overload;

      /// <summary>
      ///   Flash shape on screen.
      ///   Just another visual effect to sign a shape
      /// </summary>
      /// <param name="_times">
      ///   the number of times the shape will flash
      ///   (maximum is 20)
      /// </param>
      /// <param name="_delay">
      ///   delay  time in msec. between each color change
      ///   (maximum is 10000)
      /// </param>
      procedure Flash          ( const _times : Integer ;
                                 const _delay : Integer
                               ) ; overload;virtual;

      /// <summary>
      ///   Move the whole shape.
      /// </summary>
      /// <param name="_ptg">
      ///   point to which we are moving ;
      /// </param>
      /// <param name="_layer">
      ///   snapping layer; if nil, a shape will not be snapped; just
      ///   perfect for GPS snap-to-road function
      /// </param>
      /// <param name="_prec">
      ///   snapping precision; only points closer to _ptg than _prec can be
      ///   found ;
      /// </param>
      /// <remarks>
      ///   Use this method to move the whole shape. Reference point is the
      ///   same as Centroid.
      /// </remarks>
      procedure SetPosition    ( const _ptg   : TGIS_Point ;
                                 const _layer : TGIS_LayerVector ;
                                 const _prec  : Double
                               ) ;

      /// <summary>
      ///   Lock a shape.
      /// </summary>
      /// <param name="_lock">
      ///   TGIS_Lock.None - unlocked; TGIS_Lock.Extent - extent locked;
      ///   TGIS_Lock.Projection - extent locked and projections turned off
      /// </param>
      procedure Lock           ( const _lock  : TGIS_Lock
                               ) ; virtual;

      /// <summary>
      ///   Unlock a shape from burst-mode operation.
      /// </summary>
      /// <remarks>
      ///   <para>
      ///     Do after Lock. This method will update shape, layer and viewer
      ///     extent.
      ///   </para>
      ///   <para>
      ///      See Lock for example.
      ///   </para>
      /// </remarks>
      procedure Unlock         ; virtual;

      /// <summary>
      ///   Add a point to the last part of the shape.
      /// </summary>
      /// <param name="_ptg">
      ///   point to be added
      /// </param>
      /// <remarks>
      ///   <para>
      ///     Internal representation of a shape is the same as in the SHP
      ///     file. If you want to set a new geometry, this will call
      ///     Reset, AddPart, AddPoint...AddPoint. For TGIS_ShapePoint,
      ///     only one Part and one Point is allowed.
      ///   </para>
      ///   <para>
      ///      See TGIS_Shape.Lock for details and example.
      ///   </para>
      /// </remarks>
      procedure AddPoint       ( const _ptg : TGIS_Point
                               ) ; virtual; abstract;
      /// <summary>
      ///   Add a point to the last part of the shape in 3D.
      /// </summary>
      /// <param name="_ptg">
      ///   point to be added
      /// </param>
      /// <remarks>
      ///   Internal representation of a shape is the same as in the SHP
      ///   file. If you want to set a new geometry, this will call Reset,
      ///   AddPart, AddPoint...AddPoint. For TGIS_ShapePoint, only one
      ///   Part and one Point is allowed. See TGIS_Shape.Lock for details
      ///   and example.
      /// </remarks>
      procedure AddPoint3D     ( const _ptg : TGIS_Point3D
                               ) ; virtual; abstract;

      /// <summary>
      ///   Add a point to the last part of the shape.
      /// </summary>
      /// <param name="_bearing">
      ///   bearing in radians
      /// </param>
      /// <param name="_distance">
      ///   distance in map units
      /// </param>
      /// <returns>
      ///   True, then function succeed.
      /// </returns>
      function  AddPointBearing
                             ( const _bearing  : Double ;
                               const _distance : Double
                             ) : Boolean ; overload; virtual;

      /// <summary>
      ///   Add a point to the last part of the shape.
      /// </summary>
      /// <param name="_bearing">
      ///   bearing in radians
      /// </param>
      /// <param name="_distance">
      ///   distance in map units
      /// </param>
      /// <param name="_compass">
      ///   if True, then bearing is North oriented
      /// </param>
      /// <returns>
      ///   True, then function succeed.
      /// </returns>
      function  AddPointBearing( const _bearing  : Double ;
                                 const _distance : Double ;
                                 const _compass  : Boolean
                               ) : Boolean ; overload; virtual;

      /// <summary>
      ///   Add next part to the shape.
      /// </summary>
      /// <remarks>
      ///   <para>
      ///     Use this method to add a new part to the shape. Internal
      ///     representation of a shape is same as in the SHP file. If you
      ///     want to set a new geometry,this call Reset, AddPart,
      ///     AddPoint...AddPoint.
      ///   </para>
      ///   <para>
      ///      See Lock for example.
      ///   </para>
      /// </remarks>
      procedure AddPart        ; virtual;

      /// <summary>
      ///   Retrieve a point from a point segment of geometry.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   point number
      /// </param>
      /// <returns>
      ///   Point from shape.
      /// </returns>
      /// <remarks>
      ///   See SetPosition method for example.
      /// </remarks>
      function  GetPoint       ( const _part : Integer;
                                 const _pos  : Integer
                               ) : TGIS_Point ; virtual;

      /// <summary>
      ///   Retrieve a point coordinates from a shape segment.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   point number
      /// </param>
      /// <param name="_x">
      ///   x coordinate
      /// </param>
      /// <param name="_y">
      ///   y coordinate
      /// </param>
      procedure GetPointEx     ( const _part : Integer ;
                                 const _pos  : Integer ;
                                 var   _x    : Double  ;
                                 var   _y    : Double
                               ) ; virtual;
      {$IFDEF JAVA}
        /// <summary>
        ///   Retrieve a point coordinates from a shape segment.
        /// </summary>
        /// <param name="_part">
        ///   part number
        /// </param>
        /// <param name="_pos">
        ///   point number
        /// </param>
        /// <param name="_ptg">
        ///   coordinates to be returned here
        /// </param>
        /// <param name="_pt">
        ///   coordinates to be returned here
        /// </param>
        procedure GetPointEx2     ( const _part : Integer ;
                                    const _pos  : Integer ;
                                    const _ptg  : TGIS_Point3D ;
                                    const _pt   : TPointD
                                 ) ; virtual;
      {$ENDIF}

      /// <summary>
      ///   Retrieve a point from a point segment of geometry in 3D.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   point number
      /// </param>
      /// <returns>
      ///   Point from shape.
      /// </returns>
      /// <remarks>
      ///   See SetPosition method for a similar example.
      /// </remarks>
      function  GetPoint3D     ( const _part : Integer;
                                 const _pos  : Integer
                               ) : TGIS_Point3D ; virtual;

      /// <summary>
      ///   Retrieve a point coordinates from a shape segment.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_pos">
      ///   point number
      /// </param>
      /// <param name="_x">
      ///   x coordinate
      /// </param>
      /// <param name="_y">
      ///   y coordinate
      /// </param>
      /// <param name="_z">
      ///   z coordinate
      /// </param>
      /// <param name="_m">
      ///   m coordinate
      /// </param>
      procedure GetPoint3DEx   ( const _part : Integer ;
                                 const _pos  : Integer ;
                                 var   _x    : Double  ;
                                 var   _y    : Double  ;
                                 var   _z    : Double  ;
                                 var   _m    : Double
                               ) ; virtual;

      /// <summary>
      ///   Retrieve the first point from the first segment of geometry.
      /// </summary>
      /// <returns>
      ///   First point in a geometry.
      /// </returns>
      function  GetFirstPoint  : TGIS_Point ; virtual;

      /// <summary>
      ///   Retrieve the first point from the first segment of geometry in
      ///   3D.
      /// </summary>
      /// <returns>
      ///   First point in a geometry.
      /// </returns>
      function  GetFirstPoint3D: TGIS_Point3D ; virtual;

      /// <summary>
      ///   Retrieve the last point from the last segment of geometry.
      /// </summary>
      /// <returns>
      ///   Last point in a geometry.
      /// </returns>
      function  GetLastPoint   : TGIS_Point ; virtual;

      /// <summary>
      ///   Retrieve the last point from the last segment of geometry in 3D.
      /// </summary>
      /// <returns>
      ///   Last point in a geometry.
      /// </returns>
      function  GetLastPoint3D : TGIS_Point3D ; virtual;

      /// <summary>
      ///   Retrieve a count of the points in a geometry.
      /// </summary>
      /// <returns>
      ///   Number of points in a geometry.
      /// </returns>
      function  GetNumPoints   : Integer ; virtual;

      /// <summary>
      ///   Retrieve the number of parts in a geometry.
      /// </summary>
      /// <returns>
      ///   Number of parts in a geometry.
      /// </returns>
      /// <remarks>
      ///   Use this property to get the number of parts that were added by
      ///   AddPart method.
      /// </remarks>
      function  GetNumParts    : Integer ; virtual;

      /// <summary>
      ///   Calculates the count of points in a given part
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <returns>
      ///   Number of points in a part.
      /// </returns>
      function  GetPartSize    ( const _part : Integer
                               ) : Integer ; virtual;

      /// <summary>
      ///   Get the type of a part.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <returns>
      ///   Type of the part.
      /// </returns>
      function  GetPartType    ( const _part : Integer
                               ) : TGIS_PartType ; virtual;

      /// <summary>
      ///   Set the type of a part.
      /// </summary>
      /// <param name="_part">
      ///   part number
      /// </param>
      /// <param name="_type">
      ///   part type
      /// </param>
      procedure SetPartType    ( const _part : Integer ;
                                 const _type : TGIS_PartType
                                ) ; virtual;

      /// <summary>
      ///   Retrieving a snap point.
      /// </summary>
      /// <param name="_ptg">
      ///   point for which we are seeking a snap point ;
      /// </param>
      /// <param name="_prec">
      ///   snapping precision; only points closer to _ptg then _prec can be
      ///   found ;
      /// </param>
      /// <param name="_dist">
      ///   achieved precision
      /// </param>
      /// <returns>
      ///   Found snap point. If such point cannot be localized then same as
      ///   _ptg.
      /// </returns>
      /// <remarks>
      ///   Snap point is the best point in the shape for which we can
      ///   perform snapping.
      /// </remarks>
      function  GetSnapPoint   ( const _ptg  : TGIS_Point ;
                                 const _prec : Double;
                                 var   _dist : Double
                               ) : TGIS_Point ; virtual;

      /// <summary>
      ///   Retrieving a snap point in 3D.
      /// </summary>
      /// <param name="_ptg">
      ///   point for which we are seeking a snap point ;
      /// </param>
      /// <param name="_prec">
      ///   snapping precision; only points closer to _ptg then _prec can be
      ///   found ;
      /// </param>
      /// <param name="_dist">
      ///   achieved precision
      /// </param>
      /// <returns>
      ///   Found snap point. If such point cannot be localized then same as
      ///   _ptg.
      /// </returns>
      /// <remarks>
      ///   Snap point is the best point in the shape for which we can
      ///   perform snapping.
      /// </remarks>
      function  GetSnapPoint3D ( const _ptg  : TGIS_Point3D ;
                                 const _prec : Double;
                                 var   _dist : Double
                               ) : TGIS_Point3D ; virtual;

      /// <summary>
      ///   Return current shape as a TGIS_ShapePoint.
      /// </summary>
      /// <remarks>
      ///   <note type="note">
      ///    for multipart/multipoint shapes the last point will be returned
      ///    </note>
      /// </remarks>
      /// <returns>
      ///   Newly created shape object.
      /// </returns>
      function  AsPoint        : TGIS_ShapePoint ;

      /// <summary>
      ///   Return current shape as a TGIS_ShapeMultiPoint.
      /// </summary>
      /// <returns>
      ///   Newly created shape object.
      /// </returns>
      function  AsMultiPoint   : TGIS_ShapeMultiPoint ;

      /// <summary>
      ///   Return current shape as a TGIS_ShapeArc.
      /// </summary>
      /// <returns>
      ///   Newly created shape object.
      /// </returns>
      function  AsArc          : TGIS_ShapeArc ;

      /// <summary>
      ///   Return current shape as a TGIS_ShapePolygon
      /// </summary>
      /// <returns>
      ///   Newly created shape object.
      /// </returns>
      function  AsPolygon      : TGIS_ShapePolygon ;

      /// <summary>
      ///   Reset shape.
      /// </summary>
      /// <remarks>
      ///   <para>
      ///     Use this method to remove all points from a shape. If you want
      ///     to set a new geometry, call Reset, AddPart, AddPoint...AddPoint.
      ///   </para>
      ///   <para>
      ///      See SetPosition method for a similar example.
      ///   </para>
      /// </remarks>
      procedure Reset          ; virtual;

      /// <summary>
      ///   Reset IsModified flag.
      /// </summary>
      procedure ResetModified ;

      /// <summary>
      ///   Assign values from a given shape.
      /// </summary>
      /// <param name="_source">
      ///   Given shape. Must be same shape as current object.
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_WRONGSHAPE
      /// </exception>
      procedure Assign         ( const _source : TGIS_Shape ) ;

      /// <summary>
      ///   Add a copy of the shape to a layer using new UID.
      /// </summary>
      /// <returns>
      ///   Pointer to the editable version of the shape.
      /// </returns>
      /// <remarks>
      ///   See CopyFields for example.
      /// </remarks>
      function  AddToLayer     : TGIS_Shape ;

      /// <summary>
      ///   Add the shape to edited items list.
      /// </summary>
      /// <returns>
      ///   Pointer to the editable version of the shape.
      /// </returns>
      /// <remarks>
      ///   Any subsequent call to the shape will return the editable
      ///   version..
      /// </remarks>
      function  MakeEditable   : TGIS_Shape ;

      /// <summary>
      ///   Delete shape.
      /// </summary>
      /// <remarks>
      ///   Shape will be marked as deleted but the real deletion will be
      ///   performed upon save. Before save, the shape will simply be hidden.
      /// </remarks>
      procedure Delete         ;

      /// <summary>
      ///   Add shape to the RTree index (if the index exists).
      /// </summary>
      procedure AddToIndex     ;

      /// <summary>
      ///   Update shape to the RTree index (if the index exists).
      /// </summary>
      procedure UpdateIndex    ;

      /// <summary>
      ///   Revert params to the layer based parameters.
      /// </summary>
      /// <remarks>
      ///   Use this method to free local shape parameters.
      /// </remarks>
      procedure RevertParams   ; virtual;

      /// <summary>
      ///    Draw shape.
      /// </summary>
      /// <param name="_mode">
      ///   outline drawing mode; valid only for lines; used
      ///   to drawing nice line junctions in multipass mode;
      /// </param>
      procedure Draw         ( const _mode : TGIS_RendererMultipassMode
                             ) ; overload; virtual;

      /// <summary>
      ///   Draw shape.
      /// </summary>
      /// <remarks>
      ///   Equivalent to Draw(0).
      /// </remarks>
      procedure Draw         ; overload;

      /// <summary>
      ///   Draw tracking points of the shape.
      /// </summary>
      procedure DrawTrackingPoints ; virtual;

      /// <summary>
      ///   Invalidate the area of a shape; whole cached output will be
      ///   invalidated.
      /// </summary>
      /// <remarks>
      ///   See Combine for similar example.
      /// </remarks>
      procedure Invalidate   ; overload; virtual;

      /// <summary>
      ///   DrawLabel immediately.
      /// </summary>
      /// <remarks>
      ///   <para>
      ///     When using this operation, never call any function which uses
      ///     FindFirst..FindNext (any function which iterates through the
      ///     shapes using it - so never use inside an operation like
      ///     Locate etc.).
      ///   </para>
      ///   <para>
      ///      See TGIS_LayerVector.DrawChart for example.
      ///   </para>
      /// </remarks>
      procedure DrawLabel      ; overload ; virtual ;

      /// <summary>
      ///   DrawLabel immediately returning points delimiting label area.
      /// </summary>
      /// <param name="_points">
      ///   list of points delimiting label area;
      /// </param>
      /// <remarks>
      ///   <para>
      ///     Each drawn label is described as a sequence of delimiting points
      ///     starting from left top corner of the label and ending with the same point.
      ///     For arc shapes labels can be drawn for each part, so the buffer
      ///     can be then a set of such sequences.
      ///   </para>
      ///   <para>
      ///     When using this operation, never call any function which uses
      ///     FindFirst..FindNext (any function which iterates through the
      ///     shapes using it - so never use inside an operation like
      ///     Locate etc.).
      ///   </para>
      ///   <para>
      ///      See TGIS_LayerVector.DrawChart for example.
      ///   </para>
      /// </remarks>
      procedure DrawLabel      ( var _points : TGIS_DrawBuf
                               ) ; overload ; virtual ;

      /// <summary>
      ///   <para>
      ///     Draw chart immediately.
      ///   </para>
      ///   <para>
      ///
      ///   </para>
      /// </summary>
      /// <remarks>
      ///   <para>
      ///      When using this operation, never call any function which uses
      ///     FindFirst..FindNext (any function which iterates through the
      ///     shapes using it - so never use inside an operation like
      ///     Locate etc.).
      ///   </para>
      ///   <para>
      ///      See TGIS_LayerVector.DrawChart for example.
      ///   </para>
      /// </remarks>
      procedure DrawChart      ; virtual;

      /// <summary>
      ///   Retrieving data from associated data table.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <returns>
      ///   Field value. If field value is Null then function will return
      ///   default value. GetFieldEx will return raw value instead.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    by providing empty field the join (if any exists) will be
      ///    resynchronized
      ///    </note>
      ///   See TGIS_LayerVector.DrawLabel for example.
      /// </remarks>
      function  GetField       ( const _name    : String
                               ) : Variant ; virtual;

      /// <summary>
      ///   Retrieving data from associated data table.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <returns>
      ///   Field value. If field value is Null then function will return
      ///   Null default value. GetField will return a default value
      ///   instead.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    by providing empty field the join (if any exists) will be
      ///    resynchronize
      ///    </note>
      ///   See TGIS_LayerVector.DrawLabel for example.
      /// </remarks>
      function  GetFieldEx     ( const _name    : String
                               ) : Variant ; overload; virtual;

      /// <summary>
      ///   Retrieving data from associated data table.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <param name="_cursor">
      ///   cursor index
      /// </param>
      /// <returns>
      ///   Field value. If field value is Null then function will return
      ///   Null default value. GetField will return a default value
      ///   instead.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    by providing empty field the join (if any exists) will be
      ///    resynchronize
      ///    </note>
      ///   See TGIS_LayerVector.DrawLabel for example.
      /// </remarks>
      function  GetFieldEx     ( const _name    : String ;
                                 const _cursor  : Integer
                               ) : Variant ; overload; virtual;

      /// <summary>
      ///   Retrieving data from associated data table.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <param name="_rule">
      ///   True if filed rule should be expanded (like alias matching)
      /// </param>
      /// <returns>
      ///   Field value. If field value is Null then function will return
      ///   Null default value. GetField will return a default value
      ///   instead.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    by providing empty field the join (if any exists) will be
      ///    resynchronize
      ///    </note>
      ///   See TGIS_LayerVector.DrawLabel for example.
      /// </remarks>
      function  GetFieldEx     ( const _name    : String  ;
                                 const _rule    : Boolean
                               ) : Variant ; overload; virtual;

      /// <summary>
      ///   Retrieving data from associated data table.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <param name="_cursor">
      ///   cursor index
      /// </param>
      /// <param name="_rule">
      ///   True if filed rule should be expanded (like alias matching)
      /// </param>
      /// <returns>
      ///   Field value. If field value is Null then function will return
      ///   Null default value. GetField will return a default value
      ///   instead.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    by providing empty field the join (if any exists) will be
      ///    resynchronize
      ///    </note>
      ///   See TGIS_LayerVector.DrawLabel for example.
      /// </remarks>
      function  GetFieldEx     ( const _name    : String  ;
                                 const _cursor  : Integer ;
                                 const _rule    : Boolean
                               ) : Variant ; overload; virtual;

      /// <summary>
      ///   Set a new value for a field.
      /// </summary>
      /// <param name="_name">
      ///   field name
      /// </param>
      /// <param name="_val">
      ///   field value
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDNOEXIST
      /// </exception>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_FIELDREADONLY
      /// </exception>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_WRONGFLOAT
      /// </exception>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_WRONGBOOLEAN
      /// </exception>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_WRONGDATE
      /// </exception>
      /// <remarks>
      ///   See TGIS_LayerVector.RenameField for example.
      /// </remarks>
      procedure SetField       ( const _name    : String ;
                                 const _val     : Variant
                               ) ;
      /// <summary>
      ///   Set default values of fields based on field rules.
      /// </summary>
      /// <remarks>
      ///   <note type="note">
      ///    Fields w/o rule will remain untouched.
      ///    </note>
      /// </remarks>
      procedure SetFieldsDefaulRuleValue ;

      /// <summary>
      ///   Test if shape field was modified.
      /// </summary>
      /// <param name="_field">
      ///   field name
      /// </param>
      /// <returns>
      ///   True if field has been modified.
      /// </returns>
      function  IsFieldModified( const _field : String
                               ) : Boolean ;

      /// <summary>
      ///   Test if shape field was modified.
      /// </summary>
      /// <param name="_id">
      ///   field index
      /// </param>
      /// <returns>
      ///   True if field has been modified.
      /// </returns>
      function  IsFieldModifiedEx( const _id : Integer
                               ) : Boolean ;

      /// <summary>
      ///   Return label content (including expanded field values) etc.
      ///   Label can contain HTML markup. To obtain label value without any
      ///   formatting markers use GetLabelPlain.
      /// </summary>
      /// <returns>
      ///   Text with possible formatting etc.
      /// </returns>
      function  GetLabel       : String ; virtual;

      /// <summary>
      ///   Return label content (including expanded field values) etc.
      ///   Label will be cleared from any HTML markup etc. To obtain label
      ///   value with formatting markers use GetLabel.
      /// </summary>
      /// <param name="_all_lines">
      ///   if false, then only first line from multi line label will be
      ///   returned
      /// </param>
      /// <returns>
      ///   Cleared text.
      /// </returns>
      function  GetLabelPlain  ( const _all_lines : Boolean
                               ) : String ; virtual;

      /// <summary>
      ///   Calculate planar distance between a point and the shape.
      /// </summary>
      /// <param name="_ptg">
      ///   reference point
      /// </param>
      /// <returns>
      ///   Distance between shapes in map units.
      /// </returns>
      /// <param name="_prec">
      ///   precision /not longer distance than/; point inside the polygon
      ///   is always not greater then _prec; if _prec less than 0, then
      ///   being outside/inside polygon means the same;
      /// </param>
      function  Distance       ( const _ptg  : TGIS_Point ;
                                 const _prec : Double
                               ) : Double ; virtual;
      /// <summary>
      ///   Calculate WGS84 distance between a point and the shape.
      /// </summary>
      /// <param name="_ptg">
      ///   reference point
      /// </param>
      /// <returns>
      ///   Distance between shapes in meters (if CS of layers are known).
      /// </returns>
      /// <param name="_prec">
      ///   precision /not longer distance than/; point inside the polygon
      ///   is always not greater then _prec; if _prec less than 0, then
      ///   being outside/inside polygon means the same;
      /// </param>
      function  DistanceCS     ( const _ptg  : TGIS_Point ;
                                 const _prec : Double
                               ) : Double ; virtual;

      /// <summary>
      ///   Calculate the linear distance between a point and a part in the
      ///   current shape..
      /// </summary>
      /// <param name="_ptg">
      ///   reference point
      /// </param>
      /// <param name="_prec">
      ///   precision /not longer distance than/; point inside polygon is
      ///   always not greater than _prec; if _prec less then 0 then being
      ///   outside/inside polygon means the same;
      /// </param>
      /// <param name="_part">
      ///   part number to which the distance will be computed
      /// </param>
      /// <param name="_proj">
      ///   point projected to a nearest element of the shape
      /// </param>
      /// <returns>
      ///   Distance in map units.
      /// </returns>
      function  Distance2Part  ( const _ptg  : TGIS_Point ;
                                 const _prec : Double     ;
                                 const _part : Integer    ;
                                 var   _proj : TGIS_Point
                               ) : Double ; virtual; abstract;

      /// <summary>
      ///   Calculate the WGS84 distance between a point and a part in the
      ///   current shape.
      /// </summary>
      /// <param name="_ptg">
      ///   reference point
      /// </param>
      /// <param name="_prec">
      ///   precision /not longer distance than/; point inside polygon is
      ///   always not greater than _prec; if _prec less then 0 then being
      ///   outside/inside polygon means the same;
      /// </param>
      /// <param name="_part">
      ///   part number to which the distance will be computed
      /// </param>
      /// <param name="_proj">
      ///   point projected to a nearest element of the shape
      /// </param>
      /// <returns>
      ///   Distance in meters (if CS of layers are known).
      /// </returns>
      function  Distance2PartCS( const _ptg  : TGIS_Point ;
                                 const _prec : Double     ;
                                 const _part : Integer    ;
                                 var   _proj : TGIS_Point
                               ) : Double ; virtual; abstract;

      /// <summary>
      ///   Calculate planar distance between two shapes.
      /// </summary>
      /// <param name="_shp">
      ///   reference shape
      /// </param>
      /// <returns>
      ///   Distance in map units.
      /// </returns>
      function  Distance2Shape ( const _shp  : TGIS_Shape
                               ) : Double ; virtual;
      /// <summary>
      ///   Calculate WGS84 distance between two shapes.
      /// </summary>
      /// <param name="_shp">
      ///   reference shape
      /// </param>
      /// <returns>
      ///   Distance in meters (or -1 if map units if CS is not defined).
      /// </returns>
      function  Distance2ShapeCS
                               ( const _shp  : TGIS_Shape
                               ) : Double ; virtual;
      /// <summary>
      ///   Calculate the central point of a shape.
      /// </summary>
      /// <returns>
      ///   Point location.
      /// </returns>
      function  Centroid       : TGIS_Point ; virtual;

      /// <summary>
      ///   Calculate the point which lies on the shape.
      /// </summary>
      /// <returns>
      ///   Point location.
      /// </returns>
      function  PointOnShape   : TGIS_Point ; virtual;

      /// <summary>
      ///   Calculate the area of a shape.
      /// </summary>
      /// <returns>
      ///   Area in map units.
      /// </returns>
      function  Area           : Double ; virtual;

      /// <summary>
      ///   Calculate the area of a shape.
      /// </summary>
      /// <returns>
      ///   Area in meters (or -1 if map units if CS is not defined).
      /// </returns>
      function  AreaCS         : Double ; virtual;

      /// <summary>
      ///   Calculate the length of a shape.
      /// </summary>
      /// <returns>
      ///   Length in map units.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    For polygons function returns length of the perimeter.
      ///    </note>
      /// </remarks>
      function  Length         : Double ; virtual;

      /// <summary>
      ///   Calculate the length of a shape.
      /// </summary>
      /// <returns>
      ///   Length in meters (or -1 if map units if CS is not defined).
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    For polygons function returns length of the perimeter.
      ///    </note>
      /// </remarks>
      function  LengthCS       : Double ; virtual;

      /// <summary>
      ///   Calculate the length of a shape part.
      /// </summary>
      /// <param name="_part">
      ///   number of the part closest to a given point
      /// </param>
      /// <returns>
      ///   Part length in map units.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    For polygons function returns length of the perimeter.
      ///    </note>
      /// </remarks>
      function  PartLength     ( const _part : Integer
                               ) : Double ; virtual;

      /// <summary>
      ///   Calculate the length of a shape part.
      /// </summary>
      /// <param name="_part">
      ///   number of the part closest to a given point
      /// </param>
      /// <returns>
      ///   Part length in meters (or -1 if map units if CS is not defined).
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    For polygons function returns length of the perimeter.
      ///    </note>
      /// </remarks>
      function  PartLengthCS   ( const _part : Integer
                               ) : Double ; virtual;

      /// <summary>
      ///   Test if the shape is inside a given circle.
      /// </summary>
      /// <param name="_center">
      ///   center of circle
      /// </param>
      /// <param name="_range">
      ///   circle range
      /// </param>
      /// <param name="_itype">
      ///   kind of test
      /// </param>
      /// <returns>
      ///  True if relation is true.
      /// </returns>
      function  IsInsideCircle ( const _center : TGIS_Point ;
                                 const _range : Double ;
                                 const _itype : TGIS_InsideType
                               ) : Boolean  ; virtual;

      /// <summary>
      ///   Test if the shape is inside a defined extent.
      /// </summary>
      /// <param name="_extent">
      ///   extent to be tested with
      /// </param>
      /// <param name="_itype">
      ///   kind of test
      /// </param>
      /// <returns>
      ///   True if shape is inside provided extent.
      /// </returns>
      /// <remarks>
      ///   See IsInsideCircle for example.
      /// </remarks>
      function  IsInsideExtent ( const _extent : TGIS_Extent ;
                                 const _itype : TGIS_InsideType
                               ) : Boolean ; virtual;

      /// <summary>
      ///   Test if the shape is inside a given polygon.
      /// </summary>
      /// <param name="_shape">
      ///   polygon to test with
      /// </param>
      /// <param name="_itype">
      ///   kind of test
      /// </param>
      /// <returns>
      ///  True if relation is true.
      /// </returns>
      function  IsInsidePolygon( const _shape : TGIS_ShapePolygon ;
                                 const _itype : TGIS_InsideType
                               ) : Boolean ; virtual;

      /// <summary>
      ///   Test if the current shape has any common point with another
      ///   given shape.
      /// </summary>
      /// <param name="_shape">
      ///   shape to test with
      /// </param>
      /// <returns>
      ///  True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See IsInsideCircle for example.
      /// </remarks>
      function  IsCommonPoint  ( const _shape : TGIS_Shape
                               ) : Boolean ; virtual;

      /// <summary>
      ///   Get all crossing points between the current shape and another
      ///   given shape.
      /// </summary>
      /// <param name="_shape">
      ///   shape to test with
      /// </param>
      /// <returns>
      ///   List of crossing points or nil.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    Remember to free this list.
      ///    </note>
      ///   See TGIS_ShapePolygon.GetIntersect for example.
      /// </remarks>
      function  GetCrossings   ( const _shape : TGIS_Shape
                               ) : TGIS_PointList ;

      /// <summary>
      ///   Cut the shape in a defined extent.
      /// </summary>
      /// <param name="_extent">
      ///   extent to be cut with
      /// </param>
      /// <param name="_draft">
      ///   if true, then operation will be perform much faster; resulting
      ///   shape may be topologically improper; used mainly for internal
      ///   drawing purposes
      /// </param>
      /// <returns>
      ///   Normalized shape (a new copy).
      /// </returns>
      function  GetIntersection( const _extent : TGIS_Extent ;
                                 const _draft  : Boolean
                               ) : TGIS_Shape ; overload; virtual;

      /// <summary>
      ///   Cut the shape in a defined extent.
      /// </summary>
      /// <param name="_extent">
      ///   extent to be cut with
      /// </param>
      /// <returns>
      ///   Normalized shape (a new copy).
      /// </returns>
      function  GetIntersection( const _extent : TGIS_Extent
                               ) : TGIS_Shape ; overload; virtual;


      /// <summary>
      ///   Compute angle of first/last element of the shape in radians
      ///   related to north, east winding.
      /// </summary>
      /// <param name="_reverse">
      ///   if True, then end will be treated as start
      /// </param>
      /// <returns>
      ///   Angle in radians.
      /// </returns>
      function  GetAngle       ( const _reverse : Boolean
                               ) : Double ;

      /// <summary>
      ///   Splits a multipart shape into parts.
      /// </summary>
      /// <returns>
      ///   Newly created list of parts.
      /// </returns>
      /// <remarks>
      ///   If a shape is single part, a main part is returned.
      /// </remarks>
      function  Split          : TGIS_ShapeList ; overload ;

      /// <summary>
      ///   Joins the current shape to another given shape (excluding
      ///   TGIS_ShapePoint).
      /// </summary>
      /// <param name="_shape">
      ///   shape to join
      /// </param>
      /// <returns>
      ///   Returns newly created shape.
      /// </returns>
      /// <remarks>
      ///   First part of _shape is added to last part.
      /// </remarks>
      function  Join           ( const _shape        : TGIS_Shape
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Joins the current shape to another given shape (excluding
      ///   TGIS_ShapePoint).
      /// </summary>
      /// <param name="_shape">
      ///   shape to join
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   Otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   First part of _shape is added to last part.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Join           ( const _shape        : TGIS_Shape ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Reverse the order of parts.
      /// </summary>
      /// <remarks>
      ///   Use this method to reverse the order of parts in multipart
      ///   shape. The shape structure will be rebuilt. See example.
      /// </remarks>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      function  Reverse        : TGIS_Shape ; overload;

      /// <summary>
      ///   Reverse the order of parts.
      /// </summary>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Use this method to reverse the order of parts in multipart
      ///   shape. The shape structure will be rebuilt. See example.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Reverse        ( const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Line generalization routine.
      /// </summary>
      /// <param name="_tolerance">
      ///   simplification tolerance
      /// </param>
      /// <remarks>
      ///   Vertex elimination routine based on Douglas-Peucker
      ///   algorithm. Only for arc or polygon shapes.
      /// </remarks>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      function  Simplify     ( const _tolerance    : Double
                             ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Line generalization routine.
      /// </summary>
      /// <param name="_tolerance">
      ///   simplification tolerance
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   Otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Vertex elimination routine based on Douglas-Peucker algorithm.
      ///   Only for arc or polygon shapes.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Simplify       ( const _tolerance    : Double ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Smooth shape routine
      /// </summary>
      /// <param name="_factor">
      ///   smooth factor, number of points iterations - number of output
      ///   points = number of input point * _factor
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <remarks>
      ///   Vertex spline smoothing routine based on Catmull-Rom
      ///   algorithm. Only for arc or polygon shapes. Based on 4 control
      ///   points.
      /// </remarks>
      function  Smooth         ( const _factor       : Integer
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Smooth shape routine
      /// </summary>
      /// <param name="_factor">
      ///   smooth factor, number of points iterations - number of output
      ///   points = number of input point * _factor
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   Otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Vertex spline smoothing routine based on Catmull-Rom algorithm.
      ///   Only for arc or polygon shapes. Based on 4 control points.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Smooth         ( const _factor       : Integer ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Checks nine-intersection matrix for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <param name="_isectionMatrix">
      ///   intersection matrix
      /// </param>
      /// <returns>
      ///   True if conditions in matrix are true.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Topology class to find relations. See
      ///   GIS_Topology for details and examples.
      /// </remarks>
      function  Relate         ( const _shape     : TGIS_Shape ;
                                 const _isectionMatrix : String
                               ) : Boolean ;

      /// <summary>
      ///   Tests equality relationship for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Topology class to find relations. See
      ///   GIS_Topology for details and examples.
      /// </remarks>
      function  Equality       ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Tests disjoint relationship for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See Equality for example.
      /// </remarks>
      function  Disjoint       ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Test intersect relationship for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See Equality for example.
      /// </remarks>
      function  Intersect      ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Tests touch relationship for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See Equality for example.
      /// </remarks>
      function  Touch          ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Tests cross relationship for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See Equality for example.
      /// </remarks>
      function  Cross          ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Tests within relationship for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See Equality for example.
      /// </remarks>
      function  Within         ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Tests contains relationship for given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See Equality for example.
      /// </remarks>
      function  Contains       ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Tests overlap relationship for self and given shape
      /// </summary>
      /// <param name="_shape">
      ///   given shape
      /// </param>
      /// <returns>
      ///   True if relation is true.
      /// </returns>
      /// <remarks>
      ///   See Equality for example.
      /// </remarks>
      function  Overlap        ( const _shape     : TGIS_Shape
                               ) : Boolean ;

      /// <summary>
      ///   Copy geometry.
      /// </summary>
      /// <param name="_shape">
      ///   shape with geometry to copy
      /// </param>
      /// <remarks>
      ///   Use this method to copy geometry from other object. Can be used
      ///   to safely change Polygon to Arc geometry etc.
      /// </remarks>
      procedure CopyGeometry   ( const _shape     : TGIS_Shape
                               ) ; virtual;

      /// <summary>
      ///   Append geometry.
      /// </summary>
      /// <param name="_shape">
      ///   shape with geometry to append
      /// </param>
      /// <remarks>
      ///   Use this method to append geometry from other object. Can be
      ///   used to safely combine shapes geometry etc.
      /// </remarks>
      procedure AppendGeometry ( const _shape     : TGIS_Shape
                               ) ;

      /// <summary>
      ///   Copy fields structure.
      /// </summary>
      /// <param name="_shape">
      ///   shape with fields to copy
      /// </param>
      /// <remarks>
      ///   Use this method to copy fields for given _shape. When we create
      ///   a new shape and want to use an existing field structure,
      ///   CopyFields method makes all for us. See example.
      /// </remarks>
      procedure CopyFields     ( const _shape     : TGIS_Shape
                               ) ;

      /// <summary>
      ///   Compute a new shape from self and shape provided, based on a
      ///   given operation.
      /// </summary>
      /// <param name="_shape">
      ///   shape to combine with
      /// </param>
      /// <param name="_operation">
      ///   operation code; what kind of operation should be perform
      ///   between (current shape) and (_shape)
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class.
      /// </remarks>
      function  Combine        ( const _shape        : TGIS_Shape ;
                                 const _operation    : TGIS_TopologyCombineType
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute a new shape from self and shape provided, based on a
      ///   given operation.
      /// </summary>
      /// <param name="_shape">
      ///   shape to combine with
      /// </param>
      /// <param name="_operation">
      ///   operation code; what kind of operation should be perform between
      ///   (current shape) and (_shape)
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   Otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Combine        ( const _shape        : TGIS_Shape ;
                                 const _operation    : TGIS_TopologyCombineType ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute an union with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute union with
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class. See
      ///   Combine for similar example.
      /// </remarks>
      function  Union          ( const _shape        : TGIS_Shape
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute an union with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute union with
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape;
      ///   otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class. See
      ///   Combine for similar example.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Union          ( const _shape        : TGIS_Shape ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute an intersection with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute intersection with
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class. See
      ///   Combine for similar example.
      /// </remarks>
      function  Intersection   ( const _shape        : TGIS_Shape
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute an intersection with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute intersection with
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape;
      ///   otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Intersection   ( const _shape        : TGIS_Shape ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute a difference with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute difference with
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class. See
      ///   Combine for similar example.
      /// </remarks>
      function  Difference     ( const _shape        : TGIS_Shape
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute a difference with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute difference with
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   Otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class. See
      ///   Combine for similar example.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  Difference     ( const _shape        : TGIS_Shape ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute a symmetrical difference with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute symmetrical difference with
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class. See
      ///   Combine for similar example.
      /// </remarks>
      function  SymmetricalDifference
                               ( const _shape        : TGIS_Shape
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Compute a symmetrical difference with shape provided.
      /// </summary>
      /// <param name="_shape">
      ///   shape to compute symmetrical difference with
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   Otherwise returns modified or unmodified self object.
      /// </returns>
      /// <remarks>
      ///   Internally it uses Combine method of TGIS_Topology class. See
      ///   Combine for similar example.
      /// </remarks>
      {#ownership:result:ownif_returnewobject}
      function  SymmetricalDifference
                               ( const _shape        : TGIS_Shape ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Create the shape geometry from an Extended Well-Known Text
      ///   (EWKT) representation of the geometry with SRID meta data. (see
      ///   www.postgis.org).
      /// </summary>
      /// <param name="_ewkt">
      ///   EWKT text
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDEWKT
      /// </exception>
      function  CreateFromEWKT ( const _ewkt : String
                               ) : TGIS_Shape ; virtual;
      /// <summary>
      ///   Create the Shape geometry into an Extended Well-Known Binary (EWKB)
      ///   representation of the geometry with SRID meta data. (see www.postgis.org).
      /// </summary>
      /// <param name="_ewkb">
      ///   EWKB array
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDEWKB
      /// </exception>
      /// <returns>
      ///   Newly constructed object or nil.
      /// </returns>
      function CreateFromEWKB( const _ewkb : OleVariant
                             ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Create the shape from a Well Known Text (see: www.opengis.org).
      /// </summary>
      /// <param name="_wkt">
      ///   WKT text
      /// </param>
      /// <returns>
      ///   Newly constructed object or nil.
      /// </returns>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDWKT
      /// </exception>
      function  CreateFromWKT  ( const _wkt : String
                               ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Create the shape from Well Known Binary (see: www.opengis.org).
      /// </summary>
      /// <param name="_wkb">
      ///   WKB array
      /// </param>
      /// <returns>
      ///   Newly constructed object or nil.
      /// </returns>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDWKB
      /// </exception>
      function  CreateFromWKB( const _wkb : OleVariant
                             ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Create the shape from GeoMedia Database Object (GDO).
      /// </summary>
      /// <param name="_gdo">
      ///   GDO array
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDGDO
      /// </exception>
      function  CreateFromGDO
                           ( const _gdo : OleVariant
                           ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Create the shape from JSON.
      /// </summary>
      /// <param name="_json">
      ///   JSON text
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDJSON
      /// </exception>
      function  CreateFromJSON ( const _json : String
                               ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Create the shape from GML.
      /// </summary>
      /// <param name="_gml">
      ///   GML text
      /// </param>
      /// <returns>
      ///   Newly created shape.
      /// </returns>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDGML
      /// </exception>
      function  CreateFromGML  ( const _gml : String
                               ) : TGIS_Shape ; virtual;

      /// <summary>
      ///   Import the Extended Well-Known Binary (EWKB) representation of
      ///   the geometry with SRID meta data into the current shape (see
      ///   www.postgis.org).
      /// </summary>
      /// <param name="_ewkt">
      ///   EWKT text
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDEWKT
      /// </exception>
      /// <remarks>
      ///   Internally it uses CreateFromEWKT method. If WKT is a different
      ///   type, the shape will be reset.
      /// </remarks>
      procedure ImportFromEWKT ( const _ewkt : String
                               ) ; virtual;

      /// <summary>
      ///   Import the Extended Well-Known Binary (EWKB) representation of
      ///   the geometry with SRID meta data into the current shape (see
      ///   www.postgis.org).
      /// </summary>
      /// <param name="_ewkb">
      ///   EWKB array
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDEWKB
      /// </exception>
      /// <remarks>
      ///   Internally it uses CreateFromEWKB method. If WKB is a different
      ///   type, the shape will be reset.
      /// </remarks>
      procedure ImportFromEWKB( var   _ewkb : OleVariant
                              ) ; virtual;

      /// <summary>
      ///   Import the Well Known Text (see www.opengis.org) into the
      ///   current shape.
      /// </summary>
      /// <param name="_wkt">
      ///   WKT text
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDWKT
      /// </exception>
      /// <remarks>
      ///   Internally it uses CreateFromWKT method. If WKT is a different
      ///   type, the shape will be reset.
      /// </remarks>
      procedure ImportFromWKT  ( const _wkt : String
                               ) ; virtual;

      /// <summary>
      ///   Import the Well Known Binary (see: www.opengis.org) into the
      ///   current shape.
      /// </summary>
      /// <param name="_wkb">
      ///   WKB array
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDWKB
      /// </exception>
      /// <remarks>
      ///   Internally it uses CreateFromWKT method. If WKB is a different
      ///   type, the shape will be reset.
      /// </remarks>
      procedure ImportFromWKB( var _wkb : OleVariant
                             ) ; virtual;

      /// <summary>
      ///   Import the GeoMedia Database Object (GDO) into the current
      ///   shape.
      /// </summary>
      /// <param name="_gdo">
      ///   GDO array
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDGDO
      /// </exception>
      /// <remarks>
      ///   Internally it uses CreateFromGDO method. If WKB is a
      ///   different type, the shape will be reset.
      /// </remarks>
      procedure ImportFromGDO
                           ( var _gdo : OleVariant
                           ) ; virtual;

      /// <summary>
      ///   Import the Variant geometry.
      /// </summary>
      /// <param name="_var">
      ///   imported Variant array
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    Procedure assumes that type of geometry is same as type of
      ///    shape
      ///    </note>
      /// </remarks>
      procedure ImportFromVAR( var _var : OleVariant
                             ) ; virtual;

      /// <summary>
      ///   Import the JSON into the current shape.
      /// </summary>
      /// <param name="_json">
      ///   JSON text
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDJSON
      /// </exception>
      /// <remarks>
      ///   Internally it uses CreateFromJSON method. If JSON is a different
      ///   type, the shape will be reset.
      /// </remarks>
      procedure ImportFromJSON ( const _json : String
                               ) ; virtual;

      /// <summary>
      ///   Import the GML into the current shape.
      /// </summary>
      /// <param name="_gml">
      ///   GML text
      /// </param>
      /// <exception cref="EGIS_Exception">
      ///   GIS_RS_ERR_UNSUPPORTEDGML
      /// </exception>
      /// <remarks>
      ///   Internally it uses CreateFromGML method. If GML is a different
      ///   type, the shape will be reset.
      /// </remarks>
      procedure ImportFromGML  ( const _gml : String
                               ) ; virtual;
      /// <summary>
      ///   Export the Shape geometry into a GML (see www.opengis.org).
      /// </summary>
      /// <returns>
      ///   Exported GML text.
      /// </returns>
      /// <remarks>
      ///   See TGIS_ShapePolygon.ExportToWKB for example.
      /// </remarks>
      function  ExportToGML    : String ; virtual; abstract;

      /// <summary>
      ///   Export the Shape geometry into an Extended Well-Known Text
      ///   (EWKT) representation of the geometry with SRID meta data. (see
      ///   www.postgis.org).
      /// </summary>
      /// <returns>
      ///   Exported EWKT text.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    Spatial referencing identifier SRID can be provided by
      ///    TGIS_Shape.SetSRID
      ///    </note>
      ///   See ExportToEWKB for example.
      /// </remarks>
      function  ExportToEWKT   : String ; virtual; abstract;

      /// <summary>
      ///   Export the Shape geometry into an Extended Well-Known Binary
      ///   (EWKB) representation of the geometry with SRID meta data.
      ///   (see www.postgis.org). Spatial referencing identifier SRID can
      ///   be provided by TGIS_Shape.SetSRID See
      ///   TGIS_ShapePolygon.ExportToEWKB for example.
      /// </summary>
      /// <param name="_ewkb">
      ///   exported EWKB array
      /// </param>
      procedure ExportToEWKB ( var _ewkb : OleVariant
                             ) ; virtual; abstract;

      /// <summary>
      ///   Export the Shape geometry into a Well Known Text (see
      ///   www.opengis.org).
      /// </summary>
      /// <returns>
      ///   Exported WKT text.
      /// </returns>
      /// <remarks>
      ///   See TGIS_ShapePolygon.ExportToWKB for example.
      /// </remarks>
      function  ExportToWKT    : String ; virtual; abstract;

      /// <summary>
      ///   Export the Shape geometry into a Well Known Binary (see
      ///   www.opengis.org). See TGIS_ShapePolygon.ExportToWKB for
      ///   example.
      /// </summary>
      /// <param name="_wkb">
      ///   exported WKB array
      /// </param>
      procedure ExportToWKB   ( var _wkb : OleVariant
                              ) ; virtual; abstract;

      /// <summary>
      ///   Export the Shape geometry into a GeoMedia Database Object (GDO).
      ///   See TGIS_ShapePolygon.ExportToWKB for example.
      /// </summary>
      /// <param name="_gdo">
      ///   exported GDO array
      /// </param>
      procedure ExportToGDO   ( var _gdo : OleVariant
                              ) ; virtual; abstract;

      /// <summary>
      ///   Export the Shape geometry into an internal SHP format.
      /// </summary>
      /// <param name="_var">
      ///   exported VAR array
      /// </param>
      procedure ExportToVAR    ( var _var : OleVariant
                               ) ; virtual; abstract;

      /// <summary>
      ///   Export the Shape geometry into a GeoJSON (see www.geojson.org).
      /// </summary>
      /// <returns>
      ///   Exported JSON text.
      /// </returns>
      function  ExportToJSON   : String ; virtual; abstract;

      /// <summary>
      ///   Prepare contour bitmap (for internal TGIS_Topology purposes).
      /// </summary>
      /// <param name="_size">
      ///   width and height of bitmap
      /// </param>
      /// <param name="_outline">
      ///   if true then contour for polygons will be drawn with outlines
      ///   (borders)
      /// </param>
      /// <param name="_pixels">
      ///   newly allocated bitmap
      /// </param>
      /// <param name="_scale">
      ///   shape size in pixels divided by the shape size in map units
      /// </param>
      /// <param name="_offset">
      ///   offset of shape within bitmap caused by map placement, margins
      ///   etc.
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///     This method is for internal use only.
      ///   </note>
      /// </remarks>
      procedure PrepareContourInternal
                               ( const _size    : Integer     ;
                                 const _outline : Boolean     ;
                                 var   _pixels  : TGIS_Pixels ;
                                 var   _scale   : Double      ;
                                 var   _offset  : TPoint
                               ) ;

      /// <summary>
      ///   Transform shape by provided matrix [_m11.._m33] and
      ///   translation vector [_dx,_dy,-dz].
      /// </summary>
      /// <param name="_origin">
      ///   origin point of the transformation
      /// </param>
      /// <param name="_m11">
      ///   element [1,1] of the transformation matrix
      /// </param>
      /// <param name="_m12">
      ///   element [1,2] of the transformation matrix
      /// </param>
      /// <param name="_m13">
      ///   element [1,3] of the transformation matrix
      /// </param>
      /// <param name="_m21">
      ///   element [2,1] of the transformation matrix
      /// </param>
      /// <param name="_m22">
      ///   element [2,2] of the transformation matrix
      /// </param>
      /// <param name="_m23">
      ///   element [2,3] of the transformation matrix
      /// </param>
      /// <param name="_m31">
      ///   element [3,1] of the transformation matrix
      /// </param>
      /// <param name="_m32">
      ///   element [3,2] of the transformation matrix
      /// </param>
      /// <param name="_m33">
      ///   element [3,2] of the transformation matrix
      /// </param>
      /// <param name="_dx">
      ///   x translation element of translation vector
      /// </param>
      /// <param name="_dy">
      ///   y translation element of translation vector
      /// </param>
      /// <param name="_dz">
      ///   z translation element of translation vector
      /// </param>
      /// <returns>
      ///  Newly created transformed shape.
      /// </returns>
      function  Transform      ( const _origin   : TGIS_Point3D ;
                                 const _m11      : Double      ;
                                 const _m12      : Double      ;
                                 const _m13      : Double      ;
                                 const _m21      : Double      ;
                                 const _m22      : Double      ;
                                 const _m23      : Double      ;
                                 const _m31      : Double      ;
                                 const _m32      : Double      ;
                                 const _m33      : Double      ;
                                 const _dx       : Double      ;
                                 const _dy       : Double      ;
                                 const _dz       : Double
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Transform shape by provided matrix [_m11.._m33] and translation
      ///   vector [_dx,_dy,-dz].
      /// </summary>
      /// <param name="_origin">
      ///   origin point of the transformation
      /// </param>
      /// <param name="_m11">
      ///   element [1,1] of the transformation matrix
      /// </param>
      /// <param name="_m12">
      ///   element [1,2] of the transformation matrix
      /// </param>
      /// <param name="_m13">
      ///   element [1,3] of the transformation matrix
      /// </param>
      /// <param name="_m21">
      ///   element [2,1] of the transformation matrix
      /// </param>
      /// <param name="_m22">
      ///   element [2,2] of the transformation matrix
      /// </param>
      /// <param name="_m23">
      ///   element [2,3] of the transformation matrix
      /// </param>
      /// <param name="_m31">
      ///   element [3,1] of the transformation matrix
      /// </param>
      /// <param name="_m32">
      ///   element [3,2] of the transformation matrix
      /// </param>
      /// <param name="_m33">
      ///   element [3,2] of the transformation matrix
      /// </param>
      /// <param name="_dx">
      ///   x translation element of translation vector
      /// </param>
      /// <param name="_dy">
      ///   y translation element of translation vector
      /// </param>
      /// <param name="_dz">
      ///   z translation element of translation vector
      /// </param>
      /// <param name="_returnnewobj">
      ///   if True, then result will be returned in a newly created object;
      ///   if False, then self object will be returned
      /// </param>
      /// <returns>
      ///   If _returnnewobj=True, then returns newly created shape.
      ///   Otherwise returns modified or unmodified self object.
      /// </returns>
      {#ownership:result:ownif_returnewobject}
      function  Transform      ( const _origin   : TGIS_Point3D ;
                                 const _m11      : Double      ;
                                 const _m12      : Double      ;
                                 const _m13      : Double      ;
                                 const _m21      : Double      ;
                                 const _m22      : Double      ;
                                 const _m23      : Double      ;
                                 const _m31      : Double      ;
                                 const _m32      : Double      ;
                                 const _m33      : Double      ;
                                 const _dx       : Double      ;
                                 const _dy       : Double      ;
                                 const _dz       : Double      ;
                                 const _returnnewobj : Boolean
                               ) : TGIS_Shape ; overload;

      /// <summary>
      ///   Add to the current shape a series of points forming elliptical
      ///   arc.
      /// </summary>
      /// <param name="_center">
      ///   center of arc
      /// </param>
      /// <param name="_radiusA">
      ///   first radius of ellipse
      /// </param>
      /// <param name="_radiusB">
      ///   second radius of ellipse
      /// </param>
      /// <param name="_start">
      ///   angle of a start position; for full ellipse set to 0
      /// </param>
      /// <param name="_stop">
      ///   angle of the end position; for full ellipse set to 2Pi
      /// </param>
      /// <param name="_rotation">
      ///   initial rotation; 0 means position GisPoint( _center.X +
      ///   _radiusA, _center.Y + 0 )
      /// </param>
      procedure  StrokeArc     ( const _center   : TGIS_Point3D ;
                                 const _radiusA  : Double      ;
                                 const _radiusB  : Double      ;
                                 const _start    : Double      ;
                                 const _stop     : Double      ;
                                 const _rotation : Double
                               ) ; overload;

      /// <summary>
      ///   Add to the current shape a series of points forming elliptical
      ///   arc.
      /// </summary>
      /// <param name="_center">
      ///   center of arc
      /// </param>
      /// <param name="_radiusA">
      ///   first radius of ellipse
      /// </param>
      /// <param name="_radiusB">
      ///   second radius of ellipse
      /// </param>
      /// <param name="_start">
      ///   angle of a start position; for full ellipse set to 0
      /// </param>
      /// <param name="_stop">
      ///   angle of the end position; for full ellipse set to 2Pi
      /// </param>
      /// <param name="_rotation">
      ///   initial rotation; 0 means position GisPoint( _center.X +
      ///   _radiusA, _center.Y + 0 )
      /// </param>
      /// <param name="_segments">
      ///   maximum number of segments used to create full ellipse
      /// </param>
      procedure  StrokeArc     ( const _center   : TGIS_Point3D ;
                                 const _radiusA  : Double      ;
                                 const _radiusB  : Double      ;
                                 const _start    : Double      ;
                                 const _stop     : Double      ;
                                 const _rotation : Double      ;
                                 const _segments : Integer
                               ) ; overload;

      /// <summary>
      ///   Change winding of a shape part.
      /// </summary>
      /// <param name="_part">
      ///   part index
      /// </param>
      procedure ChangeWinding  ( const _part    : Integer
                               ) ;

      /// <summary>
      ///   Get a shape styling parameters used during drawing on a viewer
      ///   and fill _params parameter with them.
      /// </summary>
      /// <param name="_params">
      ///   params to be set (must be allocated)
      /// </param>
      /// <remarks>
      ///   <note type="note">
      ///    The result parameters are resolved using the current viewer context.
      ///   </note>
      ///   <note type="note">
      ///    Internally use TGIS_LayerVector.ShapeParamsAsDrawn.
      ///   </note>
      /// </remarks>
      procedure ParamsAsDrawn  ( const _params : TGIS_ParamsSectionVector
                               ) ;

      {$IFDEF OXYGENE}
        /// <inheritdoc/>
        function ToString        : String ; override ;
      {$ENDIF}
    public // properties for this class

      /// <summary>
      ///   Tag has no predefined meaning. The Tag property is provided for
      ///   the convenience of storing additional integer values or pointer
      ///   information for special needs in an application.
      /// </summary>
      property Tag        :  {$IFNDEF GENDOC_XDK}
                               NativeInt
                             {$ELSE}
                               Integer
                             {$ENDIF} read  fget_Tag
                                      write fset_Tag ;

      /// <summary>
      ///   TagPointer has no predefined meaning. The TagPointer property is
      ///   provided for the convenience of storing additional pointer
      ///   information for special needs in an application.
      /// </summary>
      property TagPointer : {$IFDEF MANAGED}
                              Object
                            {$ELSE}
                              Pointer
                            {$ENDIF} read  fget_TagPointer
                                     write fset_TagPointer ;

      /// <summary>
      ///   TagInternal has no predefined meaning. The TagInternal property
      ///   is provided for the convenience of storing additional for
      ///   internal use of TatukGIS. Please do not use this property on your
      ///   own!.
      /// </summary>
      property TagInternal : {$IFNDEF GENDOC_XDK}
                               NativeInt
                             {$ELSE}
                               Integer
                             {$ENDIF} read  fget_TagInternal
                                      write fset_TagInternal ;

      /// <summary>
      ///   Reference to the viewer. Thanks to this, the shape will know
      ///   the visibility area etc.
      /// </summary>
      property Viewer : TGIS_ViewerRef read fget_Viewer ;

      /// <summary>
      ///   Reference to layer. Thanks to this, the shape will know the
      ///   default colors etc.
      /// </summary>
      {$IFDEF DCC} [unsafe] {$ENDIF}
      property Layer : TGIS_LayerVector read FLayer write fset_Layer;

      /// <summary>
      ///   Get extent for current shape.
      /// </summary>
      property Extent : TGIS_Extent read fget_Extent ;

      /// <summary>
      ///   Get extent 3D for current shape.
      /// </summary>
      property Extent3D : TGIS_Extent3D read fget_Extent3D ;

      /// <summary>
      ///   Get extent for current shape. Projected
      /// </summary>
      property ProjectedExtent : TGIS_Extent read fget_ProjectedExtent ;

      /// <summary>
      ///   Mode of locking
      /// </summary>
      property LockLevel : TGIS_Lock read lockMode ;

      /// <summary>
      ///   Internal storage of parts. Closely matches SHP
      ///   representation for fast mapped file purposes.
      /// </summary>
      property Parts :
        {$IFDEF MANAGED}
           TBytes read fget_Parts ;
        {$ELSE}
           Pointer read FParts ;
        {$ENDIF}

      /// <summary>
      ///   Size of parts part of geometry.
      /// </summary>
      property PartsSize : Integer read fget_PartsSize ;

      {$IFDEF MANAGED}
        /// <summary>
        ///   Internal storage of points. Closely matches SHP
        ///   representation for fast mapped file purposes.
        /// </summary>
        property Points  : TBytes read fget_Points ;

        /// <summary>
        ///   Internal storage of points. Closely matches SHP
        ///   representation for fast mapped file purposes.
        /// </summary>
        property PointsZ : TBytes read fget_PointsZ ;

        /// <summary>
        ///   Internal storage of points. Closely matches SHP
        ///   representation for fast mapped file purposes.
        /// </summary>
        property PointsM : TBytes read fget_PointsM ;
      {$ELSE}
        /// <summary>
        ///   Internal storage of points. Closely matches SHP
        ///   representation for fast mapped file purposes.
        /// </summary>
        property Points : Pointer read FPoints ;

        /// <summary>
        ///   Internal storage of points. Closely matches SHP
        ///   representation for fast mapped file purposes.
        /// </summary>
        property PointsZ : Pointer read FPointsZ ;

        /// <summary>
        ///   Internal storage of points. Closely matches SHP
        ///   representation for fast mapped file purposes.
        /// </summary>
        property PointsM : Pointer read FPointsM ;
      {$ENDIF}

      /// <summary>
      ///   Size of points part of geometry.
      /// </summary>
      property PointsSize : Integer read fget_PointsSize ;

      /// <summary>
      ///   Size of points Z part of geometry.
      /// </summary>
      property PointsZSize : Integer read fget_PointsZSize ;

      /// <summary>
      ///   Size of points M part of geometry.
      /// </summary>
      property PointsMSize : Integer read fget_PointsMSize ;

      /// <summary>
      ///   Points Z min value.
      /// </summary>
      property PointsZMin : Double read fget_PointsZMin ;

      /// <summary>
      ///   Points Z max value.
      /// </summary>
      property PointsZMax : Double read fget_PointsZMax ;

      /// <summary>
      ///   Points M min value.
      /// </summary>
      property PointsMMin : Double read fget_PointsMMin ;

      /// <summary>
      ///   Points M max value.
      /// </summary>
      property PointsMMax : Double read fget_PointsMMax ;

      /// <summary>
      ///   Internal storage of part types. Closely matches SHP
      ///   representation for fast mapped file purposes.
      /// </summary>
      property PartTypes :
        {$IFDEF MANAGED}
            TBytes read fget_PartTypes ;
        {$ELSE}
            Pointer read FPartTypes ;
        {$ENDIF}

      /// <summary>
      ///   Size of part types of geometry.
      /// </summary>
      property PartTypesSize : Integer read fget_PartTypesSize ;

      /// <summary>
      ///   Size of geometry (number of bytes occupied by all parts &amp;
      ///   points).
      /// </summary>
      property GeometrySize : Integer read fget_GeometrySize ;

      /// <summary>
      ///   Get SmartSize of the shape. SmartSize is used to determine if
      ///   the shape is big enough to be visible.
      /// </summary>
      property SmartSize : Integer read fget_SmartSize ;

      /// <summary>
      ///   Get unique identifier for current shape. Must be >= 0.
      /// </summary>
      property Uid : TGIS_Uid read FUid ;

      /// <summary>
      ///   Get type of shape. Can be TGIS_ShapeType.Point,
      ///   TGIS_ShapeType.MultiPoint etc. Important because there can be
      ///   more than  one shape type in a layer.
      /// </summary>
      property ShapeType : TGIS_ShapeType read FShapeType ;

      /// <summary>
      ///   True if geometry not allocated, but mapped to the file.
      /// </summary>
      property IsMapped : Boolean read FIsMapped ;

      /// <summary>
      ///   True if the Shape needs to be reverted to the version saved
      ///   in file.
      /// </summary>
      property IsReverted : Boolean read FIsReverted ;

      /// <summary>
      ///   True if the Shape needs to be deleted. Deleted shape will
      ///   still exist until the next save, but will not be displayed.
      /// </summary>
      property IsDeleted : Boolean read FIsDeleted write FIsDeleted ;

      /// <summary>
      ///   True if the Shape has checked and fixed winding.
      /// </summary>
      property IsFixed : Boolean read FIsFixed write FIsFixed    ;

      /// <summary>
      ///   Is shape hidden. Treat it as turn On/Off.
      /// </summary>
      property IsHidden : Boolean read FIsHidden write FIsHidden ;

      /// <summary>
      ///   Is shape selected.
      /// </summary>
      property IsSelected : Boolean read fget_IsSelected write fset_IsSelected ;

      /// <summary>
      ///   Is shape editable.
      /// </summary>
      property IsEditable : Boolean read fget_IsEditable ;

      /// <summary>
      ///   Is shape a independent object or is a mirror of disk based
      ///   shape.
      /// </summary>
      property IsNewShape : Boolean read FIsNewShape ;

      /// <summary>
      ///   Is shape modified.
      /// </summary>
      property IsModified : Boolean read FIsModified ;

      /// <summary>
      ///   Shape dimension.
      /// </summary>
      property Dimension : TGIS_DimensionType read FDimension ;

      /// <summary>
      ///   Is shape empty.
      /// </summary>
      property IsEmpty : Boolean read FIsEmpty ;

      /// <summary>
      ///   Returns parameters (colors, fills etc) object. If object was
      ///   not allocated then Layer level parameters will be returned.
      /// </summary>
      property Params : TGIS_ParamsSectionVector read fget_Params
                                                 write fset_Params ;

      /// <summary>
      ///   True if the shape has private parameters. You can
      ///   allocate/deallocate local params by set this value to
      ///   True/False.
      /// </summary>
      property LocalParams : Boolean read fget_LocalParams
                                     write fset_LocalParams ;

      /// <summary>
      ///   True if the shape rtree index is managed.
      /// </summary>
      property ManageRTree : Boolean read fget_ManageRTree ;

      /// <summary>
      ///   Handle to parent shape. Used for complex shapes.
      /// </summary>
      property ParentShape : TGIS_Shape read  FParent
                                        write FParent;

      /// <summary>
      ///   True if the shape geometry has changed. Valid only for
      ///   editable shapes.
      /// </summary>
      property GeometryChanged : Boolean read fget_GeometryChanged ;

      /// <summary>
      ///   True if a shape field has changed. Valid only for
      ///   editable shapes.
      /// </summary>
      property FieldChanged : Boolean read fget_FieldChanged ;

  end ;


  /// <summary>
  ///   Encapsulation of single point shapes.
  /// </summary>
  {$IFDEF ISLAND}[Export]{$ENDIF}
  TGIS_ShapePoint = {$IFDEF OXYGENE} public {$ENDIF} class ( TGIS_Shape )

    // properties access functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      function  fget_Extent      : TGIS_Extent ; override;
      function  fget_SmartSize   : Integer     ; override;
      function  fget_PointsZMin  : Double      ; override;
      function  fget_PointsZMax  : Double      ; override;
      function  fget_PointsMMin  : Double      ; override;
      function  fget_PointsMMax  : Double      ; override;

    // other protected functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

       /// <inheritdoc/>
      function  getPartOffset   ( _part : Integer
                                ) : Integer ; override;

      /// <inheritdoc/>
      procedure setPoint        ( const _part : Integer ;
                                  const _pos  : Integer ;
                                  const _ptg  : TGIS_Point
                                ) ; override;

      /// <inheritdoc/>
      procedure setPoint3D      ( const _part : Integer ;
                                  const _pos  : Integer ;
                                  const _ptg  : TGIS_Point3D
                                ) ; override;

      /// <inheritdoc/>
      procedure setExtentByPoint( const _ptg  : TGIS_Point
                                ) ; override;

      /// <inheritdoc/>
      function  getIntersectInternal
                                ( const _extent        : TGIS_Extent ;
                                  const _lockInternal2 : Boolean
                                ) : TGIS_Shape ; override;

      /// <inheritdoc/>
      function  getIntersectInternal3D
                                ( const _extent        : TGIS_Extent ;
                                  const _lockInternal2 : Boolean
                                ) : TGIS_Shape ; override;

    public // constructors

      /// <inheritdoc/>
      constructor Create         ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}
      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector
                                 ) ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector ;
                                   const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      constructor Create         ( const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

    public // API - Shape Level

      /// <inheritdoc/>
      procedure Unlock           ; override;

      /// <inheritdoc/>
      procedure AddPoint         ( const _ptg : TGIS_Point
                                 ) ; override;

      /// <inheritdoc/>
      procedure AddPoint3D       ( const _ptg : TGIS_Point3D
                                 ) ; override;

      /// <inheritdoc/>
      procedure AddPart          ; override;

      /// <inheritdoc/>
      /// <remarks>
      ///   For TGIS_ShapePoint only _part = 0 and _pos = 0 is allowed. See
      ///   TGIS_Shape.SetPosition for example.
      /// </remarks>
      function  GetPoint         ( const _part : Integer;
                                   const _pos  : Integer
                                 ) : TGIS_Point ; override;

      /// <inheritdoc/>
      /// <remarks>
      ///   For TGIS_ShapePoint only _part = 0 and _pos = 0 is allowed. See
      ///   TGIS_Shape.SetPosition for example.
      /// </remarks>
      procedure GetPointEx       ( const _part : Integer ;
                                   const _pos  : Integer ;
                                   var   _x    : Double  ;
                                   var   _y    : Double
                                 ) ; override;
      {$IFDEF JAVA}
        /// <inheritdoc/>
        procedure GetPointEx2    ( const _part : Integer ;
                                   const _pos  : Integer ;
                                   const _ptg  : TGIS_Point3D ;
                                   const _pt   : TPointD
                                 ) ; override;
      {$ENDIF}

      /// <inheritdoc/>
      /// <remarks>
      ///   For TGIS_ShapePoint only _part = 0 and _pos = 0 is allowed.
      /// </remarks>
      function  GetPoint3D       ( const _part : Integer;
                                   const _pos  : Integer
                                 ) : TGIS_Point3D ; override;

      /// <inheritdoc/>
      /// <remarks>
      ///   For TGIS_ShapePoint only _part = 0 and _pos = 0 is allowed. See
      ///   TGIS_Shape.SetPosition for example.
      /// </remarks>
      procedure GetPoint3DEx     ( const _part : Integer ;
                                   const _pos  : Integer ;
                                   var   _x    : Double  ;
                                   var   _y    : Double  ;
                                   var   _z    : Double  ;
                                   var   _m    : Double
                                 ) ; override;

      /// <inheritdoc/>
      function  GetNumPoints     : Integer ; override;

      /// <inheritdoc/>
      function  GetNumParts      : Integer ; override;

      /// <inheritdoc/>
      /// <param name="_part">
      ///   for TGIS_ShapePoint always = 0
      /// </param>
      function  GetPartSize      ( const _part : Integer
                                 ) : Integer ; override;

      /// <inheritdoc/>
      function  Distance2Part    ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  Distance2PartCS  ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  Centroid         : TGIS_Point ; override;

      /// <inheritdoc/>
      function  IsInsideCircle   ( const _center : TGIS_Point ;
                                   const _range : Double ;
                                   const _itype : TGIS_InsideType
                                 ) : Boolean  ; override;
      /// <inheritdoc/>
      function  IsInsidePolygon  ( const _shape : TGIS_ShapePolygon ;
                                   const _itype : TGIS_InsideType
                                 ) : Boolean ; override;

      /// <inheritdoc/>
      function  IsCommonPoint    ( const _shape : TGIS_Shape
                                 ) : Boolean ; override;

      /// <inheritdoc/>
      function  ExportToGML      : String ; override;

      /// <inheritdoc/>
      function  ExportToEWKT     : String ; override;

      /// <inheritdoc/>
      procedure ExportToEWKB     ( var _ewkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToWKT      : String ; override;

      /// <inheritdoc/>
      procedure ExportToWKB      ( var _wkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToGDO      ( var _gdo : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToVAR      ( var _var : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToJSON     : String ; override;
  end ;

  /// <summary>
  ///   Encapsulation of multi-point shapes.
  /// </summary>
  {$IFDEF ISLAND}[Export]{$ENDIF}
  TGIS_ShapeMultiPoint = {$IFDEF OXYGENE} public {$ENDIF} class ( TGIS_Shape )

    // properties access functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      function fget_SmartSize  : Integer ; override;

    // other protected function
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <inheritdoc/>
      function getPartOffset   ( _part : Integer
                               ) : Integer ; override;

      /// <inheritdoc/>
      procedure setPoint       ( const _part : Integer ;
                                 const _pos  : Integer ;
                                 const _ptg  : TGIS_Point
                               ) ; override;

      /// <inheritdoc/>
      procedure setPoint3D     ( const _part : Integer ;
                                 const _pos  : Integer ;
                                 const _ptg  : TGIS_Point3D
                               ) ; override;

      /// <inheritdoc/>
      function  getIntersectInternal
                               ( const _extent : TGIS_Extent ;
                                 const _lockInternal2 : Boolean
                               ) : TGIS_Shape ; override;

      /// <inheritdoc/>
      function  getIntersectInternal3D
                               ( const _extent : TGIS_Extent ;
                                 const _lockInternal2 : Boolean
                               ) : TGIS_Shape ; override;
    public // constructors

      /// <inheritdoc/>
      constructor Create       ; overload;
                               {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create       ( const _source : TGIS_Shape ;
                                 {$IFDEF MANAGED}
                                   const _ptr  : TGIS_Bytes ;
                                 {$ELSE}
                                   const _ptr  : Pointer    ;
                                 {$ENDIF}
                                 const _mapped : Boolean    ;
                                 const _uid    : TGIS_Uid      ;
                                 const _layer  : TGIS_LayerVector
                               ) ; overload;
                               {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create       ( const _source : TGIS_Shape ;
                                 {$IFDEF MANAGED}
                                   const _ptr  : TGIS_Bytes ;
                                 {$ELSE}
                                   const _ptr  : Pointer    ;
                                 {$ENDIF}
                                 const _mapped : Boolean    ;
                                 const _uid    : TGIS_Uid      ;
                                 const _layer  : TGIS_LayerVector ;
                                 const _dim    : TGIS_DimensionType
                               ) ; overload; override;

        /// <inheritdoc/>
      constructor Create       ( const _dim    : TGIS_DimensionType
                               ) ; overload; override;

    public // API - Shape Level

      /// <inheritdoc/>
      procedure AddPoint         ( const _ptg : TGIS_Point
                                 ) ; override;
       /// <inheritdoc/>
      procedure AddPoint3D       ( const _ptg : TGIS_Point3D
                                 ) ; override;

       /// <inheritdoc/>
      procedure AddPart          ; override;

      /// <inheritdoc/>
      /// <remarks>
      ///   See TGIS_LayerVector.DrawLabel for example. For
      ///   TGIS_ShapeMultiPoint only _part = 0 is allowed.
      /// </remarks>
      function  GetPoint         ( const _part : Integer;
                                   const _pos  : Integer
                                 ) : TGIS_Point ; override;
      /// <inheritdoc/>
      procedure GetPointEx       ( const _part : Integer ;
                                   const _pos  : Integer ;
                                   var   _x    : Double  ;
                                   var   _y    : Double
                                 ) ; override;
      {$IFDEF JAVA}
        /// <inheritdoc/>
        procedure GetPointEx2     ( const _part : Integer ;
                                    const _pos  : Integer ;
                                    const _ptg  : TGIS_Point3D ;
                                    const _pt   : TPointD
                                 ) ; override;
      {$ENDIF}

      /// <inheritdoc/>
      /// <remarks>
      ///   For TGIS_ShapeMultiPoint only _part = 0 is allowed.
      /// </remarks>
      function  GetPoint3D       ( const _part : Integer;
                                   const _pos  : Integer
                                 ) : TGIS_Point3D ; override;

      /// <inheritdoc/>
      procedure GetPoint3DEx     ( const _part : Integer ;
                                   const _pos  : Integer ;
                                   var   _x    : Double  ;
                                   var   _y    : Double  ;
                                   var   _z    : Double  ;
                                   var   _m    : Double
                                 ) ; override;

      /// <inheritdoc/>
      function  GetNumPoints     : Integer ; override;

      /// <inheritdoc/>
      function  GetNumParts      : Integer ; override;

      /// <summary>
      ///   Retrieving size /points count/ of given part.
      /// </summary>
      /// <param name="_part">
      ///   for TGIS_ShapeMultiPoint always = 0
      /// </param>
      function  GetPartSize      ( const _part : Integer
                                 ) : Integer ; override;

      /// <inheritdoc/>
      function  Distance2Part    ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;
      /// <inheritdoc/>
      function  Distance2PartCS  ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  Centroid         : TGIS_Point ; override;

      /// <inheritdoc/>
      function  IsInsideCircle   ( const _center : TGIS_Point ;
                                   const _range : Double ;
                                   const _itype : TGIS_InsideType
                                 ) : Boolean  ; override;

      /// <inheritdoc/>
      function  IsInsidePolygon  ( const _shape : TGIS_ShapePolygon ;
                                   const _itype : TGIS_InsideType
                                 ) : Boolean ; override;

      /// <inheritdoc/>
      function  IsCommonPoint    ( const _shape : TGIS_Shape
                                 ) : Boolean ; override;

       /// <inheritdoc/>
      function  ExportToGML      : String ; override;

      /// <inheritdoc/>
      function  ExportToEWKT     : String ; override;

       /// <inheritdoc/>
      procedure ExportToEWKB     ( var _ewkb : OleVariant
                                 ) ; override;

       /// <inheritdoc/>
      function  ExportToWKT      : String ; override;

       /// <inheritdoc/>
      procedure ExportToWKB      ( var _wkb : OleVariant
                                 ) ; override;

       /// <inheritdoc/>
      procedure ExportToGDO      ( var _gdo : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToVAR      ( var _var : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToJSON     : String ; override;
  end ;

  /// <summary>
  ///   Encapsulation of lines.
  /// </summary>
  {$IFDEF ISLAND}[Export]{$ENDIF}
  TGIS_ShapeArc = {$IFDEF OXYGENE} public {$ENDIF} class ( TGIS_Shape )

    // properties access function
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      function fget_SmartSize    : Integer ; override;

    // other protected functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <inheritdoc/>
      function  getIntersectInternal
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;

      /// <inheritdoc/>
      function  getIntersectInternal3D
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;

    public // constructors

      /// <inheritdoc/>
      constructor Create         ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector
                                 ) ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector ;
                                   const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      constructor Create         ( const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

    public // API - Shape Level

      /// <inheritdoc/>
      procedure AddPoint         ( const _ptg : TGIS_Point
                                 ) ; override;

      /// <inheritdoc/>
      procedure AddPoint3D       ( const _ptg : TGIS_Point3D
                                 ) ; override;

      /// <inheritdoc/>
      function  Distance2Part    ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  Distance2PartCS  ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

       /// <inheritdoc/>
      function  Centroid         : TGIS_Point ; override;

      /// <inheritdoc/>
      function  Area             : Double ; override;

      /// <inheritdoc/>
      function  AreaCS           : Double ; override;

      /// <inheritdoc/>
      function  Length           : Double ; override;

      /// <inheritdoc/>
      function  LengthCS         : Double ; override;

      /// <inheritdoc/>
      function  PartLength       ( const _part : Integer
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  PartLengthCS     ( const _part : Integer
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  IsInsideCircle   ( const _center   : TGIS_Point ;
                                   const _range    : Double    ;
                                   const _itype    : TGIS_InsideType
                                 ) : Boolean  ; override;

      /// <inheritdoc/>
      function  IsInsidePolygon  ( const _shape    : TGIS_ShapePolygon ;
                                   const _itype    : TGIS_InsideType
                                 ) : Boolean ; override;

      /// <inheritdoc/>
      function  IsCommonPoint    ( const _shape    : TGIS_Shape
                                 ) : Boolean ; override;

      /// <summary>
      ///   Calculate a distance from the beginning of the line and the
      ///   position of a the point projected to the line.
      /// </summary>
      /// <param name="_ptg">
      ///   point to which position will be found
      /// </param>
      /// <param name="_side">
      ///   side of the line on which _ptg has been localized: -1 - left
      ///   of the line; 0 - precisely on the line; 1 - right of the line;
      ///   2 - undefined;
      /// </param>
      /// <param name="_location">
      ///   location of _ptg related to line: -1 - before the start of the
      ///   line; 0 - within the line; 1 - beyond the end of the line
      /// </param>
      /// <param name="_distance">
      ///   distance (gap) between the shape and the point
      /// </param>
      /// <returns>
      ///   Perpendicular point location form the beginning on line. .
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    See also TGIS_ShapeArc.GetPointOnLine.
      ///    </note>
      /// </remarks>
      function  GetDistanceOnLine
                                 ( const _ptg      : TGIS_Point ;
                                   var   _side     : Integer    ;
                                   var   _location : Integer    ;
                                   var   _distance : Double
                                 ) : Double ; overload;

      /// <summary>
      ///   Calculate a distance from the beginning of the line and the
      ///   position of a the point projected to the line.
      /// </summary>
      /// <param name="_ptg">
      ///   point to which position will be found
      /// </param>
      /// <param name="_side">
      ///   side of the line on which _ptg has been localized: -1 - left of
      ///   the line; 0 - precisely on the line; 1 - right of the line; 2 -
      ///   undefined;
      /// </param>
      /// <param name="_location">
      ///   location of _ptg related to line: -1 - before the start of the
      ///   line; 0 - within the line; 1 - beyond the end of the line
      /// </param>
      /// <param name="_distance">
      ///   distance (gap) between the shape and the point
      /// </param>
      /// <param name="_part">
      ///   part number on which calculation will be performed; if &lt; 0
      ///   then calculations will be done on all parts
      /// </param>
      /// <returns>
      ///   Perpendicular point location form the beginning on line. .
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    See also TGIS_ShapeArc.GetPointOnLine.
      ///    </note>
      /// </remarks>
      function  GetDistanceOnLine( const _ptg      : TGIS_Point ;
                                   var   _side     : Integer    ;
                                   var   _location : Integer    ;
                                   var   _distance : Double     ;
                                   const _part     : Integer
                                 ) : Double ; overload;

      /// <summary>
      ///   Calculate a point located at _distance from the beginning and
      ///   moved out of line by _offset.
      /// </summary>
      /// <param name="_distance">
      ///   distance from origin
      /// </param>
      /// <param name="_offset">
      ///   distance (left if negative) from line
      /// </param>
      /// <returns>
      ///   Point location.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    See also TGIS_ShapeArc.GetDistanceOnLine.
      ///    </note>
      /// </remarks>
      function  GetPointOnLine   ( const _distance : Double ;
                                   const _offset   : Double
                                 ) : TGIS_Point ; overload; virtual;

      /// <summary>
      ///   Calculate a point located at _distance from the beginning and
      ///   moved out of line by _offset.
      /// </summary>
      /// <param name="_distance">
      ///   distance from origin
      /// </param>
      /// <param name="_offset">
      ///   distance (left if negative) from line
      /// </param>
      /// <param name="_part">
      ///   part number on which calculation will be performed; if &lt; 0
      ///   then calculations will be done on all parts
      /// </param>
      /// <returns>
      ///   Point location.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    See also TGIS_ShapeArc.GetDistanceOnLine.
      ///    </note>
      /// </remarks>
      function  GetPointOnLine   ( const _distance : Double ;
                                   const _offset   : Double ;
                                   const _part     : Integer
                                 ) : TGIS_Point ; overload; virtual;

      /// <summary>
      ///   Calculate a point located at _distance from the beginning and
      ///   moved out of line by _offset.
      /// </summary>
      /// <param name="_distance">
      ///   distance from origin
      /// </param>
      /// <param name="_offset">
      ///   distance (left if negative) from line
      /// </param>
      /// <param name="_part">
      ///   part number on which calculation will be performed; if &lt; 0
      ///   then calculations will be done on all parts
      /// </param>
      /// <param name="_canExceed">
      ///   if False, then the _distance will be limited to the length of the line;
      ///   otherwise the _distance will remain unchanged;
      ///   True is the default option for other overloads
      /// </param>
      /// <returns>
      ///   Point location.
      /// </returns>
      /// <remarks>
      ///   <note type="note">
      ///    See also TGIS_ShapeArc.GetDistanceOnLine.
      ///    </note>
      /// </remarks>
      function  GetPointOnLine   ( const _distance  : Double ;
                                   const _offset    : Double ;
                                   const _part      : Integer ;
                                   const _canExceed : Boolean
                                 ) : TGIS_Point ; overload; virtual;

      /// <summary>
      ///   Extract the segment for the line based on _from _to distances.
      /// </summary>
      /// <returns>
      ///   Newly created segment which is encompass whole shape.
      /// </returns>
      function  GetSegment       : TGIS_ShapeArc ; overload; virtual;

      /// <summary>
      ///   Extract the segment for the line based on _from _to distances.
      /// </summary>
      /// <param name="_from">
      ///   starting distance from origin
      /// </param>
      /// <param name="_to">
      ///   ending distance from origin
      /// </param>
      /// <returns>
      ///   Newly created segment or nil if segment is empty.
      /// </returns>
      function  GetSegment       ( const _from     : Double ;
                                   const _to       : Double
                                 ) : TGIS_ShapeArc ; overload; virtual;

      /// <summary>
      ///   Extract the segment for the line based on _from _to distances.
      /// </summary>
      /// <param name="_from">
      ///   starting distance from origin
      /// </param>
      /// <param name="_to">
      ///   ending distance from origin
      /// </param>
      /// <param name="_part">
      ///   part number on which calculation will be performed; if &lt; 0
      ///   then calculations will be done on all parts
      /// </param>
      /// <returns>
      ///   Newly created segment or nil if segment is empty.
      /// </returns>
      function  GetSegment       ( const _from     : Double ;
                                   const _to       : Double ;
                                   const _part     : Integer
                                 ) : TGIS_ShapeArc ; overload; virtual;

      /// <inheritdoc/>
      function  ExportToGML      : String ; override;

      /// <inheritdoc/>
      function  ExportToEWKT     : String ; override;

       /// <inheritdoc/>
      procedure ExportToEWKB     ( var _ewkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToWKT      : String ; override;

      /// <inheritdoc/>
      procedure ExportToWKB      ( var _wkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToGDO      ( var _gdo : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToVAR      ( var _var : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToJSON     : String ; override;

  end ;

  /// <summary>
  ///   Encapsulation of polygon shapes.
  /// </summary>
  {$IFDEF ISLAND}[Export]{$ENDIF}
  TGIS_ShapePolygon = {$IFDEF OXYGENE} public {$ENDIF} class ( TGIS_Shape )

    // properties access functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      function fget_SmartSize    : Integer ; override;

    // other protected functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <inheritdoc/>
      function  getIntersectInternal
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;

      /// <inheritdoc/>
      function  getIntersectInternal3D
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;

    public // constructors

      /// <inheritdoc/>
      constructor Create         ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector
                                 ) ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector ;
                                   const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      constructor Create         ( const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

    public // API - Shape Level

      /// <inheritdoc/>
      procedure AddPoint         ( const _ptg : TGIS_Point
                                 ) ; override;

       /// <inheritdoc/>
      procedure AddPoint3D       ( const _ptg : TGIS_Point3D
                                 ) ; override;

      /// <inheritdoc/>
      function  Distance2Part    ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  Distance2PartCS ( const _ptg  : TGIS_Point ;
                                  const _prec : Double     ;
                                  const _part : Integer    ;
                                  var   _proj : TGIS_Point
                                ) : Double ; override;

       /// <inheritdoc/>
      function  Centroid         : TGIS_Point ; override;

      /// <inheritdoc/>
      function  PointOnShape     : TGIS_Point ; override;

      /// <inheritdoc/>
      function  Area             : Double ; override;

      /// <inheritdoc/>
      function  AreaCS           : Double ; override;

      /// <inheritdoc/>
      function  Length           : Double ; override;

      /// <inheritdoc/>
      function  LengthCS         : Double ; override;

      /// <inheritdoc/>
      function  PartLength       ( const _part : Integer
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  PartLengthCS     ( const _part : Integer
                                 ) : Double ; override;
      /// <inheritdoc/>
      function  IsInsideCircle   ( const _center : TGIS_Point ;
                                   const _range : Double ;
                                   const _itype : TGIS_InsideType
                                 ) : Boolean  ; override;
      /// <inheritdoc/>
      function  IsInsidePolygon  ( const _shape : TGIS_ShapePolygon ;
                                   const _itype : TGIS_InsideType
                                 ) : Boolean ; override;

      /// <inheritdoc/>
      function  IsCommonPoint    ( const _shape : TGIS_Shape
                                 ) : Boolean ; override;

      /// <inheritdoc/>
      function  ExportToGML      : String ; override;

      /// <inheritdoc/>
      function  ExportToEWKT     : String ; override;

      /// <inheritdoc/>
      procedure ExportToEWKB     ( var _ewkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToWKT      : String ; override;

      /// <inheritdoc/>
      procedure ExportToWKB      ( var _wkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToGDO      ( var _gdo : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToVAR      ( var _var : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToJSON     : String ; override;

      /// <summary>
      ///   Splits a multipart polygon shape into parts.
      /// </summary>
      /// <param name="_keep_holes">
      ///   if True, polygons with holes are not split;
      ///   if False, all parts are split
      /// </param>
      /// <returns>
      ///   Newly created list of parts.
      /// </returns>
      /// <remarks>
      ///   If a shape is single part, a main part is returned.
      /// </remarks>
      function  Split            ( const _keep_holes : Boolean
                                 ) : TGIS_ShapeList ; overload ;

      /// <summary>
      ///   Builds a polygon from a list of non complex edges.
      /// </summary>
      /// <param name="_edges">
      ///   list of non complex edges of TGIS_ShapeArc type
      /// </param>
      /// <param name="_tolerance">
      ///   tolerance into which two arcs are close enough to be joined
      /// </param>
      procedure BuildFromEdges   ( const _edges     : TGIS_ObjectList ;
                                   const _tolerance : Double
                                 ) ;
  end ;

  /// <summary>
  ///   Encapsulation of complex shapes.
  /// </summary>
  TGIS_ShapeComplex = {$IFDEF OXYGENE} public {$ENDIF} class ( TGIS_Shape )

    // properties internal values
    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}
      FComplexList : TGIS_ShapeList ;

    // properties access functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      function  fget_ShapesCount     : Integer ;
      function  fget_SmartSize       : Integer     ; override;
      function  fget_Extent          : TGIS_Extent ; override;
      function  fget_ProjectedExtent : TGIS_Extent ; override;
      procedure fset_Layer           ( const _layer : TGIS_LayerVector
                                     ) ; override;
      procedure fset_IsSelected      ( const _value : Boolean
                                     ) ; override;
    // other protected functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <inheritdoc/>
      function  checkIsEmpty         : Boolean ; override;

      /// <inheritdoc/>
      function  getIntersectInternal
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;

      /// <inheritdoc/>
      function  getIntersectInternal3D
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;

    public // constructors

      /// <inheritdoc/>
      constructor Create         ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector
                                 ) ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector ;
                                   const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      constructor Create         ( const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      procedure   Recreate       ( const _source : TGIS_Shape             ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes             ;
                                   {$ELSE}
                                     const _ptr  : Pointer                ;
                                   {$ENDIF}
                                   const _mapped : Boolean                ;
                                   const _uid    : TGIS_Uid                  ;
                                   const _layer  : TGIS_LayerVector       ;
                                   {$IFNDEF OXYGENE}
                                     const _dim    : TGIS_DimensionType
                                                    = TGIS_DimensionType.Unknown
                                   {$ELSE}
                                     const _dim    : TGIS_DimensionType
                                      {$IFDEF CLR}  := TGIS_DimensionType.Unknown {$ENDIF}
                                   {$ENDIF}
                                 ) ; override;
      {$IFNDEF OXYGENE}

        /// <summary>
        ///   Destroy a shape instance.
        /// </summary>
        destructor  Destroy      ; override;
      {$ENDIF}

      /// <inheritdoc/>
      function  CreateCopy       : TGIS_Shape ; override;

    public // Lider.CG.GIS.GeoViewer API - Shape Level

       /// <inheritdoc/>
      procedure AddPoint         ( const _ptg : TGIS_Point
                                 ) ; override;

      /// <inheritdoc/>
      procedure AddPoint3D       ( const _ptg : TGIS_Point3D
                                 ) ; override;

      /// <inheritdoc/>
      function  Distance2Part    ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  Distance2PartCS  ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

       /// <inheritdoc/>
      function  Centroid         : TGIS_Point ; override;

      /// <inheritdoc/>
      function  Area             : Double ; override;

       /// <inheritdoc/>
      function  AreaCS           : Double ; override;

      /// <inheritdoc/>
      function  Length           : Double ; override;

      /// <inheritdoc/>
      function  LengthCS         : Double ; override;

      /// <inheritdoc/>
      function  ExportToGML      : String ; override;

      /// <inheritdoc/>
      function  ExportToEWKT     : String ; override;

      /// <inheritdoc/>
      procedure ExportToEWKB     ( var _ewkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToWKT      : String ; override;

      /// <inheritdoc/>
      procedure ExportToWKB      ( var _wkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToGDO      ( var _gdo : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToVAR      ( var _var : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToJSON     : String ; override;

      /// <inheritdoc/>
      procedure Flash            ( const _times : Integer ;
                                   const _delay : Integer
                                 ) ; override;

      /// <inheritdoc/>
      procedure CopyGeometry     ( const _shape     : TGIS_Shape
                                 ) ; override;

      /// <inheritdoc/>
      procedure Unlock           ; override;

    public // API Complex Shape management

      /// <summary>
      ///   Adds shape to complex list.
      /// </summary>
      /// <param name="_shp">
      ///   shape to add
      /// </param>
      procedure AddShape         ( const _shp     : TGIS_Shape
                                 ) ;

      /// <summary>
      ///   Delete shape from complex list.
      /// </summary>
      /// <param name="_index">
      ///   shape index to delete
      /// </param>
      procedure DeleteShape      ( const _index   : Integer
                                 ) ;

      /// <summary>
      ///   Gets a shape from complex list.
      /// </summary>
      /// <param name="_index">
      ///   shape index
      /// </param>
      /// <returns>
      ///   Found shape or nil.
      /// </returns>
      function  GetShape         ( const _index   : Integer
                                 ) : TGIS_Shape ;

      /// <summary>
      ///   Locate a shape that is near _pt, but is closer than _prec
      ///   distance.
      /// </summary>
      /// <param name="_ptg">
      ///   reference point /searching point/
      /// </param>
      /// <param name="_prec">
      ///   precision /not a longer distance than/; for points inside the
      ///   polygon (if _prec &gt;= 0) the distance will be multiply by 0.95
      ///   (to prefer points inside the polygon) but will not be bigger
      ///   then _prec; for point distance will be multiplied by 0.9 to
      ///   prefer points over lines and polygons
      /// </param>
      /// <param name="_visible">
      ///   if true the only visible shapes will be evaluated; shapes turned
      ///   of by query of hidden will be ignored
      /// </param>
      /// <param name="_dist">
      ///   distance to found shape
      /// </param>
      /// <returns>
      ///   Found shape or nil.
      /// </returns>
      /// <remarks>
      ///   See TGIS_LayerVector.Locate for example. To improve performance
      ///   sections visibility can be used to choose layer to call its
      ///   Locate method.
      /// </remarks>
      function  Locate           ( const _ptg     : TGIS_Point ;
                                   const _prec    : Double     ;
                                   const _visible : Boolean    ;
                                   var   _dist    : Double
                                 ) : TGIS_Shape ;
    public // properties

       /// <summary>
       ///   Number of shapes in collection.
       /// </summary>
       property ShapesCount : Integer read fget_ShapesCount ;

  end ;

  /// <summary>
  ///   Encapsulation of MultiPatch shapes.
  /// </summary>
  TGIS_ShapeMultiPatch = {$IFDEF OXYGENE} public {$ENDIF} class ( TGIS_ShapePolygon )
    {$IFNDEF OXYGENE} private {$ELSE} assembly {$ENDIF}
      FNormals            : TGIS_Normals ;
      FHasNormals         : Boolean ;
      FTextures           : TGIS_Textures ;
      FHasTextures        : Boolean ;
      FMaterials          : TGIS_Materials ;
      FHasMaterials       : Boolean ;
      FPartDescriptors    : TGIS_PartDescriptors ;
      FHasPartDescriptors : Boolean ;
      FVertexColors       : TGIS_VertexColors ;
      FHasVertexColors    : Boolean ;

    // properties access functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      function fget_SmartSize    : Integer     ; override;

    // other protected functions
    {$IFDEF OXYGENE} assembly or {$ENDIF}
    protected

      /// <inheritdoc/>
      function  getIntersectInternal
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;

      /// <inheritdoc/>
      function  getIntersectInternal3D
                                 ( const _extent         : TGIS_Extent ;
                                   const _lockInternal2  : Boolean
                                 ) : TGIS_Shape ; override;
    public // constructors

      /// <inheritdoc/>
      constructor Create         ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector
                                 ) ; overload;
                                 {$IFNDEF CLR} override; {$ENDIF}

      /// <inheritdoc/>
      constructor Create         ( const _source : TGIS_Shape ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes ;
                                   {$ELSE}
                                     const _ptr  : Pointer    ;
                                   {$ENDIF}
                                   const _mapped : Boolean    ;
                                   const _uid    : TGIS_Uid      ;
                                   const _layer  : TGIS_LayerVector ;
                                   const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      constructor Create         ( const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      procedure   Recreate       ( const _source : TGIS_Shape              ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes              ;
                                   {$ELSE}
                                     const _ptr  : Pointer                 ;
                                   {$ENDIF}
                                   const _mapped : Boolean                 ;
                                   const _uid    : TGIS_Uid                ;
                                   const _layer  : TGIS_LayerVector        ;
                                   const _dim    : TGIS_DimensionType
                                 ) ; overload; override;

      /// <inheritdoc/>
      procedure   Recreate       ( const _source : TGIS_Shape              ;
                                   {$IFDEF MANAGED}
                                     const _ptr  : TGIS_Bytes              ;
                                   {$ELSE}
                                     const _ptr  : Pointer                 ;
                                   {$ENDIF}
                                   const _mapped : Boolean                 ;
                                   const _uid    : TGIS_Uid                ;
                                   const _layer  : TGIS_LayerVector
                                 ) ; overload; override;
      {$IFNDEF MANAGED}
        /// <summary>
        ///   Destroy a shape instance.
        /// </summary>
        destructor  Destroy      ; override;
      {$ENDIF}

    public // Lider.CG.GIS.GeoViewer API - Shape Level

      /// <inheritdoc/>
      /// <remarks>
      ///   Doesn't work for MultiPatch shapes. Instead refer to a sub shape
      ///   using GetShape method and then use AddPoint.
      /// </remarks>
      procedure AddPoint         ( const _ptg : TGIS_Point
                                 ) ; override;

      /// <inheritdoc/>
      /// <remarks>
      ///   Doesn't work for MultiPatch shapes. Instead refer to a sub shape
      ///   using GetShape method and then use AddPoint3D.
      /// </remarks>
      procedure AddPoint3D       ( const _ptg : TGIS_Point3D
                                 ) ; override;

      /// <inheritdoc/>
      function  Distance2Part    ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

       /// <inheritdoc/>
      function  Distance2PartCS  ( const _ptg  : TGIS_Point ;
                                   const _prec : Double     ;
                                   const _part : Integer    ;
                                   var   _proj : TGIS_Point
                                 ) : Double ; override;

      /// <inheritdoc/>
      function  PointOnShape     : TGIS_Point ; override;

      /// <inheritdoc/>
      function  Centroid         : TGIS_Point ; override;

      /// <inheritdoc/>
      function  Area             : Double ; override;

      /// <inheritdoc/>
      function  AreaCS           : Double ; override;

      /// <inheritdoc/>
      function  Length           : Double ; override;

      /// <inheritdoc/>
      function  LengthCS         : Double ; override;

      /// <inheritdoc/>
      function  ExportToGML      : String ; override;

      /// <inheritdoc/>
      function  ExportToEWKT     : String ; override;

      /// <inheritdoc/>
      procedure ExportToEWKB     ( var _ewkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      function  ExportToWKT      : String ; override;

      /// <inheritdoc/>
      procedure ExportToWKB      ( var _wkb : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToGDO      ( var _gdo : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
      procedure ExportToVAR      ( var _var : OleVariant
                                 ) ; override;

      /// <inheritdoc/>
       function  ExportToJSON     : String ; override;

    public

     /// <summary>
     ///   Normals for textures (lights related)
     /// </summary>
     property Normals      : TGIS_Normals              read  FNormals ;

     /// <summary>
     ///   True is shape has normals
     /// </summary>
     property HasNormals   : Boolean                   read  FHasNormals
                                                       write FHasNormals ;
     /// <summary>
     ///   Textures specification for shape
     /// </summary>
     property Textures     : TGIS_Textures             read  FTextures ;

     /// <summary>
     ///   True is shape has textures specification.
     /// </summary>
     property HasTextures  : Boolean                   read  FHasTextures
                                                       write FHasTextures ;
     /// <summary>
     ///   Materials for textures (bitmaps etc).
     /// </summary>
     property Materials    : TGIS_Materials            read  FMaterials ;

     /// <summary>
     ///   True is shape has materials.
     /// </summary>
     property HasMaterials : Boolean                   read  FHasMaterials
                                                       write FHasMaterials ;
     /// <summary>
     ///   Part descriptors (fan, strip, ring etc.).
     /// </summary>
     property PartDescriptors : TGIS_PartDescriptors   read  FPartDescriptors ;

     /// <summary>
     ///   True is shape has parts descriptors
     /// </summary>
     property HasPartDescriptors : Boolean             read  FHasPartDescriptors
                                                       write FHasPartDescriptors ;
     /// <summary>
     ///   Vertex colors
     /// </summary>
     property VertexColors      : TGIS_VertexColors    read  FVertexColors ;

     /// <summary>
     ///   True is shape has normals
     /// </summary>
     property HasVertexColors   : Boolean              read  FHasVertexColors
                                                       write FHasVertexColors ;

  end ;
{$ENDREGION 'Shapes types'}

{$REGION 'Public functions'}

  /// <summary>
  ///   Test if a given point is inside a given polygon.
  /// </summary>
  /// <param name="_ptg">
  ///   point to test
  /// </param>
  /// <param name="_shape">
  ///   polygon to test
  /// </param>
  /// <returns>
  ///  True if relation is true.
  /// </returns>
  /// <remarks>
  ///   See GisIsPointInsideExtent for example.
  /// </remarks>
  function GisIsPointInsidePolygon
                         ( const _ptg    : TGIS_Point ;
                           const _shape  : TGIS_ShapePolygon
                         ) : Boolean ; overload;

  /// <summary>
  ///   Test if a given point is inside a given polygon.
  /// </summary>
  /// <param name="_ptg">
  ///   point to test
  /// </param>
  /// <param name="_shape">
  ///   polygon to test
  /// </param>
  /// <param name="_part">
  ///   if &gt;= 0 then calculation done only for selected part ;
  /// </param>
  /// <returns>
  ///  True if relation is true.
  /// </returns>
  /// <remarks>
  ///   See GisIsPointInsideExtent for example.
  /// </remarks>
  function GisIsPointInsidePolygon
                         ( const _ptg    : TGIS_Point ;
                           const _shape  : TGIS_ShapePolygon ;
                           const _part   : Integer
                         ) : Boolean ; overload;

type
  {#gendoc:hide:GENXDK}
  {#gendoc:hide:GENPDK}
  /// <summary>
  ///   Function to be used by GisLabelTextParser.
  /// </summary>
  /// <param name="_name">
  ///   Name of the field value to be returned.
  /// </param>
  /// <returns>
  ///  Computed field value.
  /// </returns>
  TGIS_ExpandLabelFun  = function(
                           const _name : String
                         ) : Variant of object ;

  /// <summary>
  ///   Function to parse label text and substitute embedded field values
  ///   and formulas.
  /// </summary>
  /// <param name="_text">
  ///   Text label to be parsed.
  /// </param>
  /// <param name="_shp">
  ///   Shape object which provide field values.
  /// </param>
  /// <returns>
  ///  Expanded label text.
  /// </returns>
  function GisExpandLabel( const _text       : String;
                           const _shp : TGIS_Shape
                         ) : String ; overload ;

  /// <summary>
  ///   Function to parse label text and substitute embedded field values
  ///   and formulas.
  /// </summary>
  /// <param name="_text">
  ///   Text label to be parsed.
  /// </param>
  /// <param name="_getfield">
  ///   Callback function to provide field values.
  /// </param>
  /// <returns>
  ///  Expanded label text.
  /// </returns>
  function GisExpandLabel( const _text       : String;
                           const _getfield   : TGIS_ExpandLabelFun
                         ) : String ; overload ;



{$ENDREGION 'Public functions'}
//##############################################################################
implementation

{$IFDEF DCC}
  uses
    Lider.CG.GIS.GeoCsBase,
    Lider.CG.GIS.GeoCsProjections,
    Lider.CG.GIS.GeoFieldRules,
    Lider.CG.GIS.GeoGeometryFactory,
    Lider.CG.GIS.GeoIniFiles,
    Lider.CG.GIS.GeoInternals,
    Lider.CG.GIS.GeoLayerSublayer,
    Lider.CG.GIS.GeoRendererAbstract,
    Lider.CG.GIS.GeoResource,
    Lider.CG.GIS.GeoStringFormat,
    Lider.CG.GIS.GeoStatistics,
    Lider.CG.GIS.GeoTopology ;
{$ENDIF}

const
{$REGION 'Common const'}
  { Basic offsets in geometry binary representation -  count of parts. }
    {$IFDEF OXYGENE}
      OFFSET_NUM_PARTS   = 4 * sizeOf( Double )  ;
    {$ELSE}
      OFFSET_NUM_PARTS   = sizeOf( TGIS_Extent ) ;
    {$ENDIF}
  { Basic offsets in geometry binary representation -  count of points. }
    {$IFDEF OXYGENE}
      OFFSET_MULTIPOINTS = 4 * sizeOf( Double )  ;
    {$ELSE}
      OFFSET_MULTIPOINTS = sizeOf( TGIS_Extent ) ;
    {$ENDIF}
  { Basic offsets in geometry binary representation -  count of points. }
    OFFSET_NUM_POINTS  = OFFSET_NUM_PARTS  + sizeOf( DWORD ) ;
  { Basic offsets in geometry binary representation -  parts data. }
    OFFSET_PARTS       = OFFSET_NUM_POINTS + sizeOf( DWORD ) ;
  { Memory allocation unit for shape data (FParts pointer).
    Any reallocation can be only a multiplication of PARTS_CHUNK_SIZE. }
    PARTS_CHUNK_SIZE   = 64  ;
  { Memory allocation unit for shape data (FPoint pointer).
    Any reallocation can be only a multiplication of POINTS_CHUNK_SIZE. }
    POINTS_CHUNK_SIZE  = 256 ;
  { Limit of a GDI device. For WIn NT much larger for, Win9x only +-2^15 but
    we choose bit less then a common denominator. }
    GDI_LIMIT          = 16000 ;

  { If set to NO         then labels will not be rotated
    If set to BYFIELD    then labels will not be rotated only if
                         set by params.RotateEx.Field
    If set to WITHANGLE  then labels will not be rotated if (1) or
                         params.Rotate <> 0
    If set to ALL        then all labels will not be rotated
  }
    METADATA_ROTATELABELS     = 'TGIS_Viewer.RotationMode.Labels' ;
  { If set to NO         then symbols will not be rotated
    If set to BYFIELD    then symbols will not be rotated only if
                         set by params.RotateEx.Field
    If set to WITHANGLE  then symbols will not be rotated if (1) or
                         params.Rotate <> 0
    If set to ALL        then all symbols will rotated wit map rotation
  }
    METADATA_ROTATESYMBOLS    = 'TGIS_Viewer.RotationMode.Symbols' ;

  { If set to YES/NO     then field with original uid (ORIG_ID) will be added
                         during layer import
  }
    METADATA_WRITEORIGINALUID = 'TGIS_LayerVector.WriteOriginalUid' ;

  { Magic number to ensur that TagPointer is AGGREGATED_VALUE. }
    AGGREGATED_MAGIC_NUMBER   = 32916184 ;

  { Field for  }
    STYLE_FIELD_WIDTH = 2048 ;

{$ENDREGION 'Common const'}

{$REGION 'Common vars'}
var
  oAggregators      : TDictionary<
                        String,
                        TGIS_DynamicAggregatorAbstractClass
                      > = nil;
  oAggregatorsNames : TStringList = nil;
{$ENDREGION 'Common vars'}

{$REGION 'T_CatmullRomSpline'}
type

  T_CatmullRomSpline = class
    private
      FExponent : Double ;
    private
      bReady : Boolean ;
    private
      P0  : TGIS_Point3D ;
      P1  : TGIS_Point3D ;
      P2  : TGIS_Point3D ;
      P3  : TGIS_Point3D ;
      T0  : Double ;
      T1  : Double ;
      T2  : Double ;
      T3  : Double ;
      T10 : Double ;
      T21 : Double ;
      T32 : Double ;
      T20 : Double ;
      T31 : Double ;
    private
      function  fget_Exponent : Double ;
      procedure fset_Exponent ( const _val : Double
                              ) ;
    private
      function  getKnot ( const _kn0 : Double ;
                          const _pt0 : TGIS_Point3D ;
                          const _pt1 : TGIS_Point3D
                        ) : Double ;
    public
      constructor Create ;
    public
      procedure Prepare   ( const _p0 : TGIS_Point3D ;
                            const _p1 : TGIS_Point3D ;
                            const _p2 : TGIS_Point3D ;
                            const _p3 : TGIS_Point3D
                          ) ;
      function  Calculate ( const _t  : Double
                          ) : TGIS_Point3D ;
    public
      property Exponent : Double
                          read  fget_Exponent
                          write fset_Exponent ;
      property Knot0    : Double
                          read  T0 ;
      property Knot1    : Double
                          read  T1 ;
      property Knot2    : Double
                          read  T2 ;
      property Knot3    : Double
                          read  T3 ;
      property Ready    : Boolean
                          read bReady ;
  end ;

constructor T_CatmullRomSpline.Create ;
begin
  inherited ;

  FExponent := 0.5 ;
  bReady := False ;
  T0 := 0.0 ;
  T1 := 0.0 ;
  T2 := 0.0 ;
  T3 := 0.0 ;
end ;


function T_CatmullRomSpline.fget_Exponent : Double ;
begin
  Result := FExponent ;
end ;


procedure T_CatmullRomSpline.fset_Exponent(
  const _val : Double
) ;
begin
  if ( _val < 0.0 ) or ( _val > 1.0 ) then
    exit ;

  FExponent := _val ;
end ;


function T_CatmullRomSpline.getKnot(
  const _kn0 : Double ;
  const _pt0 : TGIS_Point3D ;
  const _pt1 : TGIS_Point3D
) : Double ;
var
  x : Double ;
  y : Double ;
  z : Double ;
  m : Double ;
  v : Double ;
begin
  if FExponent = 0.0 then begin
    Result := 1.0 + _kn0 ;
    exit ;
  end ;

  x := _pt1.X - _pt0.X ;
  y := _pt1.Y - _pt0.Y ;
  z := _pt1.Z - _pt0.Z ;
  m := _pt1.M - _pt0.M ;
  v := x*x + y*y + z*z + m*m ;

  if FExponent = 1.0 then begin
    Result := Sqrt( v ) + _kn0 ;
    exit ;
  end ;

  Result := Power( v, 0.5*FExponent ) + _kn0 ;
end ;


procedure T_CatmullRomSpline.Prepare(
  const _p0 : TGIS_Point3D ;
  const _p1 : TGIS_Point3D ;
  const _p2 : TGIS_Point3D ;
  const _p3 : TGIS_Point3D
) ;
begin
  bReady := True ;

  P0 := _TGIS_Point3D(_p0) ;
  P1 := _TGIS_Point3D(_p1) ;
  P2 := _TGIS_Point3D(_p2) ;
  P3 := _TGIS_Point3D(_p3) ;

  T0 := 0.0 ;
  T1 := getKnot( T0, _p0, _p1 ) ;
  T2 := getKnot( T1, _p1, _p2 ) ;
  T3 := getKnot( T2, _p2, _p3 ) ;

  T10 := T1 - T0 ;
  if T10 = 0 then
    bReady := False ;
  T21 := T2 - T1 ;
  if T21 = 0 then
    bReady := False ;
  T32 := T3 - T2 ;
  if T32 = 0 then
    bReady := False ;
  T20 := T2 - T0 ;
  if T20 = 0 then
    bReady := False ;
  T31 := T3 - T1 ;
  if T31 = 0 then
    bReady := False ;
end ;


function T_CatmullRomSpline.Calculate(
  const _t  : Double
) : TGIS_Point3D ;
var
  res : TGIS_Point3D ;
  a1  : TGIS_Point3D ;
  a2  : TGIS_Point3D ;
  a3  : TGIS_Point3D ;
  b1  : TGIS_Point3D ;
  b2  : TGIS_Point3D ;
  v1  : Double ;
  v2  : Double ;
begin
  if not Ready then begin
    Result := GisPoint3D( 0.0, 0.0, 0.0 );
    exit ;
  end ;

  {$IFDEF JAVA}
    a1  := TGIS_Point3D.create ;
    a2  := TGIS_Point3D.create ;
    a3  := TGIS_Point3D.create ;
    b1  := TGIS_Point3D.create ;
    b2  := TGIS_Point3D.create ;
    res := TGIS_Point3D.create ;
  {$ENDIF}

  v1 := ( T1 - _t )/T10 ;
  v2 := ( _t - T0 )/T10 ;
  a1.X := v1*P0.X + v2*P1.X ;
  a1.Y := v1*P0.Y + v2*P1.Y ;
  a1.Z := v1*P0.Z + v2*P1.Z ;
  a1.M := v1*P0.M + v2*P1.M ;

  v1 := ( T2 - _t )/T21 ;
  v2 := ( _t - T1 )/T21 ;
  a2.X := v1*P1.X + v2*P2.X ;
  a2.Y := v1*P1.Y + v2*P2.Y ;
  a2.Z := v1*P1.Z + v2*P2.Z ;
  a2.M := v1*P1.M + v2*P2.M ;

  v1 := ( T3 - _t )/T32 ;
  v2 := ( _t - T2 )/T32 ;
  a3.X := v1*P2.X + v2*P3.X ;
  a3.Y := v1*P2.Y + v2*P3.Y ;
  a3.Z := v1*P2.Z + v2*P3.Z ;
  a3.M := v1*P2.M + v2*P3.M ;

  v1 := ( T2 - _t )/T20 ;
  v2 := ( _t - T0 )/T20 ;
  b1.X := v1*a1.X + v2*a2.X ;
  b1.Y := v1*a1.Y + v2*a2.Y ;
  b1.Z := v1*a1.Z + v2*a2.Z ;
  b1.M := v1*a1.M + v2*a2.M ;

  v1 := ( T3 - _t )/T31 ;
  v2 := ( _t - T1 )/T31 ;
  b2.X := v1*a2.X + v2*a3.X ;
  b2.Y := v1*a2.Y + v2*a3.Y ;
  b2.Z := v1*a2.Z + v2*a3.Z ;
  b2.M := v1*a2.M + v2*a3.M ;

  v1 := ( T2 - _t )/T21 ;
  v2 := ( _t - T1 )/T21 ;
  res.X := v1*b1.X + v2*b2.X ;
  res.Y := v1*b1.Y + v2*b2.Y ;
  res.Z := v1*b1.Z + v2*b2.Z ;
  res.M := v1*b1.M + v2*b2.M ;

  Result := res ;
end ;

{$ENDREGION 'T_CatmullRomSpline'}

{$REGION 'T_ParamsSectionVectorHelper'}
type
   T_ParamsSectionVectorHelper = class helper for TGIS_ParamsSectionVector
     public
        procedure SetGround  ( const _value : TGIS_3DGroundType ) ;
        procedure SetBasement( const _value : TGIS_3DBasementType ) ;
   end;

procedure T_ParamsSectionVectorHelper.SetGround(
  const _value : TGIS_3DGroundType
) ;
begin
  fset_GroundIfNotDefault( _value ) ;
end;

procedure T_ParamsSectionVectorHelper.SetBasement(
  const _value : TGIS_3DBasementType
) ;
begin
  fset_BasementIfNotDefault( _value ) ;
end;
{$ENDREGION 'T_ParamsSectionVectorHelper'}

{$REGION 'Private utility functions'}

function auto_round(
  const _var : Double
) : Double ;
begin
  if      _var < 0.1   then  Result := _var
  else if _var < 1     then  Result := RoundTo( _var, -5 )
  else if _var < 10    then  Result := RoundTo( _var, -4 )
  else if _var < 100   then  Result := RoundTo( _var, -3 )
  else if _var < 1000  then  Result := RoundTo( _var, -2 )
  else if _var < 10000 then  Result := RoundTo( _var, -1 )
  else                       Result := RoundTo( _var, -0 )
end ;

{$ENDREGION 'Private utility functions'}

{$REGION 'Public utility functions'}

function GisIsPointInsidePolygon(
  const _ptg   : TGIS_Point        ;
  const _shape : TGIS_ShapePolygon
) : Boolean ;
begin
  Result := GisIsPointInsidePolygon( _ptg, _shape, -1 ) ;
end ;

function GisIsPointInsidePolygon(
  const _ptg   : TGIS_Point        ;
  const _shape : TGIS_ShapePolygon ;
  const _part  : Integer
) : Boolean ;
var
  point_no     : Integer ;
  parts, count : Integer ;
  points_count : Integer ;
  next_pt      : Integer ;
  npar         : Integer ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
  start, stop  : Integer ;
begin
  Result := False ;
  if not assigned( _shape ) or ( _shape.ShapeType <> TGIS_ShapeType.Polygon ) then
    exit ;

  with _shape.Extent do begin
    if ( XMax=Xmin ) and (YMax=YMin) then begin
      if ( XMax=_ptg.X ) and (YMax=_ptg.Y) then
        Result := True ;
      exit ;
    end ;
  end ;

  parts := _shape.GetNumParts ;

  if _part < 0 then begin
    start := 0 ;
    stop  := parts -1 ;
  end
  else begin
    start := _part ;
    stop  := _part ;
  end ;
  if stop > parts -1 then stop := 1 ;

  for count := start to stop do begin
    points_count := _shape.GetPartSize( count ) ;
    next_pt := points_count - 1 ;
    npar := 0 ;
    for point_no := 0 to points_count - 1 do  begin // all points
      // point will be tested on every line of polygon
      // test is based on odd/even algorithm
      line_a := _shape.GetPoint( count, point_no  ) ;
      line_b := _shape.GetPoint( count, next_pt) ;
      next_pt := point_no ;
        try
          if ( ( ( ( line_a.Y <= _ptg.Y ) and ( _ptg.Y < line_b.Y ) ) or
                 ( ( line_b.Y <= _ptg.Y ) and ( _ptg.Y < line_a.Y ) )
               ) and
               ( _ptg.X < ( line_b.X - line_a.X )*( _ptg.Y - line_a.Y ) /
                          ( line_b.Y - line_a.Y ) + line_a.X
               )
             ) then
            npar := npar +1;
        except
        end ;
      end ;

      if ( npar mod 2) = 1 then
        Result := not Result ; // even - point is inside part
    end ;
end ;

function label_text_parser(
  const _text     : String;
  const _shp      : TGIS_Shape ;
  const _getfield : TGIS_ExpandLabelFun
) : String ;
var
  i             : Integer ;
  j             : Integer ;
  c             : Char    ;
  state         : Integer ;
  vtmp          : Variant ;
  fmt           : TStringBuilder ;
  lname         : TStringBuilder ;
  lstat         : TStringBuilder ;
  res           : TStringBuilder ;
  formula       : TStringBuilder ;
  sqlquery      : TGIS_SqlQuery  ;
  bvtmp         : Boolean ;

  c2            : Char    ;
  stmp          : String  ;
  snohtml       : TStringBuilder ;
  exapandhtml   : Boolean ;
  washtml       : Boolean ;

  function get_char
    : Char ;
  begin
    inc( i ) ;
    if i <= StringLast( _text ) then begin
      Result := _text[i] ;
    end
    else
      Result := #0 ;
  end ;

begin
  Result  := ''  ;

  state    := 0   ;
  bvtmp    := False ;
  fmt      := TStringBuilder.Create ;
  lname    := TStringBuilder.Create ;
  lstat    := TStringBuilder.Create ;
  res      := TStringBuilder.Create ;
  formula  := TStringBuilder.Create ;
  sqlquery := nil ;
  exapandhtml := False ;
  try

    i := StringFirst -1 ;
    c := get_char ;
    while c <> #0 do begin

      case state of
         0 :  begin
                if      c = '{' then begin
                                       bvtmp := False   ;
                                       state := 5       ;
                                       c := get_char    ;
                                       exapandhtml := False ;
                                     end
                                else begin
                                       res.Append( c )  ;
                                       c := get_char    ;
                                     end ;
              end ;
        5  :  begin
                if      c = ' ' then begin
                                       c := get_char ;
                                     end
                else if c = '[' then begin
                                       state := 6 ;
                                       c := get_char ;
                                     end
                else if c = '"' then begin
                                       state := 7 ;
                                       c := get_char ;
                                     end
                                else begin
                                       state := 10 ;
                                     end;
              end;
        6  :  begin
                if      c = ']' then begin
                                       state := 10 ;
                                       c := get_char ;
                                     end
                                else begin
                                       lname.Append( c ) ;
                                       c := get_char ;
                                     end;
              end;
        7  :  begin
                if      c = '"' then begin
                                       state := 10 ;
                                       c := get_char ;
                                     end
                                else begin
                                       lname.Append( c ) ;
                                       c := get_char ;
                                     end;
              end;
        10 :  begin
                if      c = ':' then begin
                                       state := 20      ;
                                       c := get_char    ;
                                     end
                else if c = '!' then begin
                                       exapandhtml := True  ;
                                       c := get_char    ;
                                     end
                else if c = '(' then begin
                                       state := 15      ;
                                       c := get_char    ;
                                     end
                else if c = '{' then begin
                                       state := 17      ;
                                       c := get_char    ;
                                     end
                else if c = '}' then begin
                                       state := 30      ;
                                     end
                                else begin
                                       lname.Append( c ) ;
                                       c := get_char    ;
                                     end ;
              end ;
        17 :  begin
                if      c = '}' then begin
                                       if not assigned( sqlquery ) then
                                         sqlquery := TGIS_SqlQuery.Create ;
                                       sqlquery.Prepare( formula.ToString ) ;
                                       formula.Clear ;
                                       vtmp := sqlquery.ParseAsFloat(
                                                          _shp,
                                                          NaN,
                                                          0
                                                        ) ;
                                       bvtmp := True    ;
                                       state := 10      ;
                                       c := get_char    ;
                                     end
                                else begin
                                       formula.Append( c )  ;
                                       c := get_char    ;
                                     end ;
              end ;
        15 :  begin
                if      c = ')' then begin
                                       c := get_char    ;
                                       state := 10      ;
                                     end
                                else begin
                                       lstat.Append( c ) ;
                                       c := get_char    ;
                                     end ;
              end ;
        20 :  begin
               if      c = '}' then begin
                                      state := 30      ;
                                    end
                               else begin
                                      fmt.Append( c )  ;
                                      c := get_char    ;
                                    end ;
             end ;
        30 :  begin

                state := 0 ;
                if not bvtmp then begin
                  if assigned( _shp ) then begin
                    if lstat.Length > 0 then begin
                      vtmp := _shp.Layer.getStatistics( lstat.ToString, lname.ToString ) ;
                    end
                    else
                      vtmp := _shp.GetFieldEx( GisDeNormalizedSQLName( lname.ToString ) ) ;
                  end
                  else begin
                    vtmp := _getfield( lname.ToString ) ;
                  end ;
                end ;

                if ( not VarIsNull( vtmp ) ) and ( not VarIsEmpty( vtmp ) ) then
                begin
                  // prerecognize labels with incomplete HTML markup
                  if exapandhtml then begin
                    case VarTypeEx( vtmp ) of
                      varExAnsiString,
                      varExWideString :
                        begin
                          washtml := false ;
                          stmp := String( vtmp ) ;
                          snohtml := TStringBuilder.Create ;
                          try
                            for j := StringFirst to StringLast( stmp ) do begin
                              c2 := stmp[j] ;
                              case c2 of
                                '<' : begin
                                        snohtml.Append( '&lt;' ) ;
                                        washtml := True
                                      end;
                                '>' : begin
                                        snohtml.Append( '&gt;' ) ;
                                        washtml := True
                                      end;
                                else  begin
                                        snohtml.Append( c2 ) ;
                                      end ;

                              end ;
                            end ;

                            if washtml then begin
                              vtmp := snohtml.ToString ;
                            end ;
                          finally
                            FreeObject( snohtml ) ;
                          end ;
                        end;
                    end ;
                  end ;
                end ;

                res.Append(
                  TGIS_StringFormat.Format( fmt.ToString, vtmp )
                ) ;
                {$IFDEF JAVA}
                  fmt.setLength(0) ;
                  lname.setLength(0) ;
                  lstat.setLength(0) ;
                {$ELSE}
                  fmt.Length   := 0 ;
                  lname.Length := 0 ;
                  lstat.Length := 0 ;
                {$ENDIF}
                c := get_char  ;
              end ;
        else  begin
                assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
              end ;
      end;
    end ;

  finally
    Result := res.ToString ;

    FreeObject( fmt      ) ;
    FreeObject( lname    ) ;
    FreeObject( lstat    ) ;
    FreeObject( res      ) ;
    FreeObject( formula  ) ;
    FreeObject( sqlquery ) ;
  end;
end;

function GisExpandLabel(
  const _text : String;
  const _shp  : TGIS_Shape
) : String ; overload ;
begin
  Result := label_text_parser( _text, _shp, nil ) ;
end;

function GisExpandLabel(
  const _text     : String;
  const _getfield : TGIS_ExpandLabelFun
) : String ;
begin
  Result := label_text_parser( _text, nil, _getfield ) ;
end;

{$ENDREGION 'Public utility functions'}

{$REGION 'TGIS_ShapeEventArgs'}
{$IFDEF OXYGENE}

  // Create an object.
  constructor TGIS_ShapeEventArgs.Create(
    const _shape : TGIS_Shape
  ) ;
  begin
    inherited Create ;
    FShape := _shape ;
  end ;

{$ENDIF}
{$ENDREGION 'TGIS_ShapeEventArgs'}

{$REGION 'TGIS_ShapePosEventArgs'}
{$IFDEF OXYGENE}

  // Create an object.
  constructor TGIS_ShapePosEventArgs.Create(
    const _shape : TGIS_Shape ;
    const _pos   : TGIS_LabelPositions ;
    {$IFDEF JAVA}
      const _pt    : TPoint ;
      const _rct   : TRect
    {$ENDIF}
    {$IFDEF CLR}
      const _pt    : System.Drawing.Point ;
      const _rct   : System.Drawing.Rectangle
    {$ENDIF}
    {$IFDEF ISLAND}
      const _pt    : TPoint ;
      const _rct   : TRect
    {$ENDIF}
  ) ;
  begin
    inherited Create ;
    FShape := _shape ;
    FPos   := _pos ;
    FPoint := _pt ;
    FRect  := _rct ;
  end ;

{$ENDIF}
{$ENDREGION 'TGIS_ShapePosEventArgs'}

{$REGION 'TGIS_ShapeFieldChangeEventArgs'}
{$IFDEF OXYGENE}
  // Create an object.
  constructor TGIS_ShapeFieldChangeEventArgs.Create(
    const _shape : TGIS_Shape ;
    const _id    : Integer
  ) ;
  begin
    inherited Create ;
    FShape := _shape ;
    FId    := _id ;
end ;

{$ENDIF}
{$ENDREGION 'TGIS_ShapeFieldChangeEventArgs'}

{$REGION 'TGIS_LayerVector'}

constructor TGIS_LayerVector.Create ;
var
  tmp_render : TObject ;
  tmp_labels : TObject ;
  tmp_line   : TObject ;
  tmp_area   : TObject ;
  tmp_marker : TObject ;
  tmp_chart  : TObject ;
  tmp_field  : TGIS_FieldInfo ;
begin
  inherited ;

  cursorOpen ; // cursor 0 for general loops
  cursorOpen ; // cursor 1 for GetShape

  ParamsList.SetUp( TGIS_ParamsSectionVector.Create ) ;

  FMultipassRendering := False ;

  FJoinCodePage  := GisSystemCodePage ;

  labelHint      := True ;
  chartHint      := True ;

  FScope         := '' ;
  FScopeExtent   := GisNoWorld ;

  FItems          := TGIS_ShapeList.Create( True ) ;
  FFields         := TGIS_FieldInfoList.Create ;

  FFieldsVirtual  := TGIS_FieldInfoList.Create ;

  helperFindField := TDictionary< String, Integer >.Create(
                       {$IFDEF OXYGENE}
                         {$IFDEF JAVA}
                           java.lang.String.CASE_INSENSITIVE_ORDER
                         {$ENDIF}
                         {$IFDEF CLR}
                           StringComparer.OrdinalIgnoreCase
                         {$ENDIF}
                       {$ELSE}
                         TIStringComparer.Ordinal
                       {$ENDIF}
                     ) ;
  helperFindFieldInternal :=
                     TDictionary< String, Integer >.Create(
                       {$IFDEF OXYGENE}
                         {$IFDEF JAVA}
                           java.lang.String.CASE_INSENSITIVE_ORDER
                         {$ENDIF}
                         {$IFDEF CLR}
                           StringComparer.OrdinalIgnoreCase
                         {$ENDIF}
                       {$ELSE}
                         TIStringComparer.Ordinal
                       {$ENDIF}
                     ) ;

  FDynamicAggregator        := nil ;
  oldAggregatorParams       := nil;
  aggregatedItems           := TGIS_ShapeList.Create( True ) ;
  aggregatedItemsAttributes := TObjectList<TObject>.Create( True ) ;

  // UID
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_UID ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Number ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_UID ) ;

  // SELECTED
  tmp_field           :=TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_SELECTED ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Boolean ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_SELECTED ) ;

  // HIDDEN
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_HIDDEN ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Boolean ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_HIDDEN ) ;

  // AREA
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_AREA ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_AREA ) ;

  // LENGTH
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_LENGTH ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_LENGTH ) ;

  // COORD_Z
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_COORD_Z ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_COORD_Z ) ;

  // COORD_M
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_COORD_M ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_COORD_M ) ;

  // NOW
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_NOW ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Date ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_NOW ) ;

  // MIN_X
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MIN_X ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MIN_X ) ;

  // MIN_Y
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MIN_Y ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MIN_Y ) ;

  // MIN_Z
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MIN_Z ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MIN_Z ) ;

  // MIN_M
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MIN_M ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MIN_M ) ;

  // MAX_X
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MAX_X ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MAX_X ) ;

  // MAX_Y
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MAX_Y ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MAX_Y ) ;

  // MAX_Z
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MAX_Z ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MAX_Z ) ;

  // MAX_M
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_MAX_M ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_MAX_M ) ;

  // CENTER_X
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_CENTER_X ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_CENTER_X ) ;

  // CENTER_Y
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_CENTER_Y ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_CENTER_Y ) ;

  // CENTER_Z
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_CENTER_Z ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_CENTER_Z ) ;

  // CENTER_M
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_CENTER_M ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_CENTER_M ) ;

  // CENTROID_X
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_CENTROID_X ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_CENTROID_X ) ;

  // CENTROID_Y
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_CENTROID_Y ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_CENTROID_Y ) ;

  // NUM_PARTS
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_NUM_PARTS ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Number ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_NUM_PARTS ) ;

  // NUM_POINTS
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_NUM_POINTS ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Number ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_NUM_POINTS ) ;

  // AGGREGATD_COUNT
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_AGGREGATED_COUNT ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Number ;
  FFieldsVirtual.Add( tmp_field ) ;

  // AGGREGATD_VALUE
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_AGGREGATED_VALUE ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Number ;
  FFieldsVirtual.Add( tmp_field ) ;

  // AGGREGATD_UIDS
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_AGGREGATED_UIDS ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.String ;
  FFieldsVirtual.Add( tmp_field ) ;

  // SHAPE_TYPE
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_SHAPE_TYPE ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.String ;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_SHAPE_TYPE ) ;

  // VIEWER_SCALE
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_VIEWER_SCALE ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_VIEWER_SCALE ) ;

  // VIEWER_LEVEL
  tmp_field           := TGIS_FieldInfo.Create ;
  tmp_field.Saved     := False ;
  tmp_field.Name      := GIS_FIELD_VIEWER_LEVEL ;
  tmp_field.NewName   := tmp_field.Name ;
  tmp_field.FieldType := TGIS_FieldType.Float;
  FFieldsVirtual.Add( tmp_field ) ;
  assert( FFieldsVirtual.Count - 1 + GIS_FIELD_ID_UID = GIS_FIELD_ID_VIEWER_LEVEL ) ;

  RTreeFile      := nil ;

  FDefaultShapeType   := TGIS_ShapeType.Unknown ;
  FDefaultDimension   := TGIS_DimensionType.Unknown ;

  {$IFDEF OXYGENE}
    FSupportedShapes     := GisGetEmptyShapeType ;
    FSupportedDimensions := GisGetEmptyDimensionType ;
  {$ENDIF}

  Path           := '' ;
  Name           := '' ;

  FUseRTree      := False ;
  FBlockRTree    := False ;

  FIsModified    := False ;

  {$IFDEF GIS_NORECORDS}
    rLockedRender := new T_rLockedRender ;
  {$ENDIF}
  rLockedRender.oLock   := TGIS_ThreadClass.Create  ;
  rLockedRender.pLine   := TGIS_ParamsLine.Create   ;
  rLockedRender.pArea   := TGIS_ParamsArea.Create   ;
  rLockedRender.pMarker := TGIS_ParamsMarker.Create ;
  rLockedRender.pLabel  := TGIS_ParamsLabel.Create  ;
  rLockedRender.pChart  := TGIS_ParamsChart.Create  ;

  rLockedRender.dLine   := TGIS_ParamsLine.Create   ;
  rLockedRender.dArea   := TGIS_ParamsArea.Create   ;
  rLockedRender.dMarker := TGIS_ParamsMarker.Create ;
  rLockedRender.dLabel  := TGIS_ParamsLabel.Create  ;
  rLockedRender.dChart  := TGIS_ParamsChart.Create  ;

  {$IFDEF CLR}
    FJoinNET := nil ;
  {$ENDIF}
  {$IFNDEF GIS_NOADO_JOIN}
    FJoinADO := nil ;
  {$ENDIF}
  {$IFNDEF GIS_NODB}
    FJoinDB  := nil ;
  {$ENDIF}
  {$IFDEF GIS_PDK}
    FJoinDBAPI2 := nil ;
  {$ENDIF}

    FJoinPrimary   := '' ;
  FJoinForeign   := '' ;

  FIgnoreShapeParams  := False ;
  FUseShapeStyleField := False ;

  FInMemoryRTree := False ;

  {$IFDEF GIS_NORECORDS}
    oldMarkerPoint := new TGIS_Point() ;
  {$ENDIF}

  FLabelingMode  := -1 ;
  FSymbolingMode := -1 ;

  FSelectedList := TGIS_SelectedShapeList.Create ;

  // force default Params creation for proper interaction with
  // shape.Params creation order
  tmp_render := Params.Render ;
  tmp_labels := Params.Labels ;
  tmp_line   := Params.Line   ;
  tmp_area   := Params.Area   ;
  tmp_marker := Params.Marker ;
  tmp_chart  := Params.Chart  ;

  lastColorRampZone := -1 ;
end ;

procedure TGIS_LayerVector.doDestroy ;
var
  i : Integer ;
begin
  for i := 0 to high( cursorState ) do
    cursorClose( i ) ;

  if assigned( RTreeFile ) then begin
    RTreeFile.Commit( not MustSave ) ;
    FreeObject( FRTreeFile ) ;
  end ;

  FreeObject( FItems                    ) ;

  FreeObject( FFields                   ) ;
  FreeObject( FFieldsVirtual            ) ;

  FreeObject( helperFindField           ) ;
  FreeObject( helperFindFieldInternal   ) ;

  FreeObject( FDynamicAggregator        ) ;
  FreeObject( oldAggregatorParams       ) ;
  FreeObject( aggregatedItems           ) ;
  FreeObject( aggregatedItemsAttributes ) ;

  FreeObject( rLockedRender.oLock       ) ;
  FreeObject( rLockedRender.pLine       ) ;
  FreeObject( rLockedRender.pArea       ) ;
  FreeObject( rLockedRender.pMarker     ) ;
  FreeObject( rLockedRender.pLabel      ) ;
  FreeObject( rLockedRender.pChart      ) ;

  FreeObject( rLockedRender.dLine       ) ;
  FreeObject( rLockedRender.dArea       ) ;
  FreeObject( rLockedRender.dMarker     ) ;
  FreeObject( rLockedRender.dLabel      ) ;
  FreeObject( rLockedRender.dChart      ) ;

  FreeObject( FSelectedList             ) ;

  {$IFDEF GIS_PDK}
    JoinDB := nil ;
  {$ENDIF}

  inherited ;
end ;

function TGIS_LayerVector.fget_SupportedShapesAll
  : TGIS_ShapeTypes ;
begin
  Result := GisAddShapeType( FSupportedShapes, aggregatorShapeType ) ;
end;

function TGIS_LayerVector.fget_DefaultShapeType
  : TGIS_ShapeType ;
begin
  if      FDefaultShapeType      <> TGIS_ShapeType.Unknown then
          Result := FDefaultShapeType
  else if GisTestShapeType( TGIS_ShapeType.Point,      SupportedShapes ) then
          Result := TGIS_ShapeType.Point
  else if GisTestShapeType( TGIS_ShapeType.MultiPoint, SupportedShapes ) then
          Result := TGIS_ShapeType.MultiPoint
  else if GisTestShapeType( TGIS_ShapeType.Arc,        SupportedShapes ) then
          Result := TGIS_ShapeType.Arc
  else if GisTestShapeType( TGIS_ShapeType.Polygon,    SupportedShapes ) then
          Result := TGIS_ShapeType.Polygon
  else if GisTestShapeType( TGIS_ShapeType.MultiPatch, SupportedShapes ) then
          Result := TGIS_ShapeType.MultiPatch
  else    Result := TGIS_ShapeType.Unknown ;
end ;

procedure TGIS_LayerVector.fset_DefaultShapeType(
  const _value : TGIS_ShapeType
) ;
begin
  if GisTestShapeType( _value, SupportedShapes ) then
    FDefaultShapeType := _value ;
end ;

function TGIS_LayerVector.fget_DefaultDimension
  : TGIS_DimensionType ;
begin
  if      FDefaultDimension <> TGIS_DimensionType.Unknown then
          Result := FDefaultDimension
  else if GisTestDimensionType( TGIS_DimensionType.XY,   SupportedDimensions ) then
          Result := TGIS_DimensionType.XY
  else if GisTestDimensionType( TGIS_DimensionType.XYZ,  SupportedDimensions ) then
          Result := TGIS_DimensionType.XYZ
  else if GisTestDimensionType( TGIS_DimensionType.XYM,  SupportedDimensions ) then
          Result := TGIS_DimensionType.XYM
  else if GisTestDimensionType( TGIS_DimensionType.XYZM, SupportedDimensions ) then
          Result := TGIS_DimensionType.XYZM
  else    Result := TGIS_DimensionType.Unknown ;
end ;

procedure TGIS_LayerVector.fset_DefaultDimension(
  const _value : TGIS_DimensionType
) ;
begin
  if GisTestDimensionType( _value, SupportedDimensions ) then
    FDefaultDimension := _value ;
end ;

function TGIS_LayerVector.fget_ParamsVector
  : TGIS_ParamsSectionVector ;
begin
  Result := TGIS_ParamsSectionVector( inherited Params ) ;
end ;

procedure TGIS_LayerVector.fset_ParamsVector(
  const _value : TGIS_ParamsSectionVector
) ;
begin
  inherited Params := _value ;
end ;

function TGIS_LayerVector.fget_SelectedList
  : TGIS_SelectedShapeList ;
begin
  Result := FSelectedList ;
end ;

{$IFDEF CLR}
  // Property JoinNET access routine.
  procedure TGIS_LayerVector.fset_JoinNET(
    const _value : Object
  ) ;
  begin
    {$IFNDEF GIS_NOADO_JOIN}
      if assigned( FJoinADO ) then exit ;
    {$ENDIF}
    if assigned( _value ) and not ( _value is DataTable ) then exit ;
    FJoinNET     := _value ;
    rJoin.Active := True   ;
    rJoin.Reset  := False  ;
    rJoin.RowNET := 0      ;
  end ;
{$ENDIF}

{$IFNDEF GIS_NOADO_JOIN}
  {$IFDEF OXYGENE}
    // Property JoinADO access routine.
    procedure TGIS_LayerVector.fset_JoinADO(
      const _value : Object
    ) ;
  {$ELSE}

    procedure TGIS_LayerVector.fset_JoinADO(
      const _value : _Recordset
    ) ;
  {$ENDIF}
  begin
    {$IFDEF CLR}
      if assigned( FJoinNET ) then exit ;
      if assigned( _value ) and not ( _value is _Recordset ) then exit ;
    {$ENDIF}
    FJoinADO     := _value ;
    rJoin.Active := True   ;
    rJoin.Reset  := False  ;
  end ;
{$ENDIF}

{$IFNDEF GIS_NOJDBC}
  // Property JoinJDBC access routine.
  procedure TGIS_LayerVector.fset_JoinJDBC(
    const _value : Object
  ) ;
  begin
    FJoinJDBC     := _value ;
    rJoin.Active := True   ;
    rJoin.Reset  := False  ;
  end ;
  // query
  procedure TGIS_LayerVector.fset_JoinJDBCQuery(
    const _value : String
  ) ;
  begin
    FJoinJDBCQuery := _value;
  end;
{$ENDIF}

{$IFNDEF GIS_NODB}
  procedure TGIS_LayerVector.fset_JoinDB(
    const _value : TDataSet
  ) ;
  begin
    {$IFDEF GIS_PDK}
      if FJoinDBAPI2 <> nil then begin
        with GetPythonEngine do begin
          if ( FJoinDBAPI2 <> Py_None )
             and
             ( FJoinDBAPI2 <> nil )
          then begin
            Py_DECREF( FJoinDBAPI2 );
            FJoinDBAPI2 := Py_None ;
          end;
        end;
      end;
    {$ENDIF}

    FJoinDB := _value ;
    rJoin.Active := True   ;
    rJoin.Reset  := False  ;
  end ;
{$ENDIF}

{$IFDEF GIS_PDK}
  procedure TGIS_LayerVector.fset_JoinDBAPI2(
    const _value : PPyObject
  ) ;
  begin
    JoinDB := nil ;
    FJoinDBAPI2 := _value ;
  end ;
{$ENDIF}

procedure TGIS_LayerVector.fset_JoinPrimary(
  const _value : String
) ;
begin
  FJoinPrimary := _value ;
  rJoin.Active := True   ;
  rJoin.Reset  := False  ;
end ;

procedure TGIS_LayerVector.fset_JoinForeign(
  const _value : String
) ;
begin
  FJoinForeign := _value ;
  rJoin.Active := True   ;
  rJoin.Reset  := False  ;
end ;

procedure TGIS_LayerVector.fset_DynamicAggregator(
  const _value : TGIS_DynamicAggregatorAbstract
) ;
begin
  if assigned( oldAggregatorParams ) then begin
    ParamsList.Assign( oldAggregatorParams ) ;
  end
  else
  if assigned( _value ) then begin
    oldAggregatorParams := TGIS_ParamsList.Create             ;
    oldAggregatorParams.Assign( ParamsList ) ;
  end;

  if not assigned( _value ) then
    FreeObject( oldAggregatorParams ) ;

  if _value <> FDynamicAggregator then begin
    FreeObject( FDynamicAggregator ) ;
    FDynamicAggregator := _value ;
    if assigned( FDynamicAggregator ) then
      FDynamicAggregator.SetUp ;
  end ;
end ;

function TGIS_LayerVector.fget_PathRTree
  : String ;
begin
  Result := '' ;
end ;

function TGIS_LayerVector.fget_UseRTree
  : Boolean ;
begin
  Result := FUseRTree ;
end ;

function TGIS_LayerVector.fget_RTree
  : TGIS_RTree ;
begin
  Result := FRTreeFile ;
end ;

procedure TGIS_LayerVector.fset_UseRTree(
  const _value : Boolean
) ;
var
  i            : Integer  ;
  abrt         : Boolean  ;
  line_no      : Cardinal ;
  end_uid      : TGIS_Uid    ;
  old_modified : Boolean  ;
  old_scope    : String   ;
  is_busy      : Boolean  ;
begin
  if not IsOpened then exit ;
  if _value = assigned( RTreeFile ) then exit ;

  if FBlockRTree then exit ;

  FUseRTree := False ;

  if not _value then begin
    FreeObject( FRTreeFile ) ;
    exit ;
  end ;

  try
    if not IsStringEmpty( PathRTree ) and not FInMemoryRTree then
      RTreeFile := TGIS_RTree.Create( PathRTree )
    else
      RTreeFile := TGIS_RTree.Create( '' ) ;

    FUseRTree := True ;

    {$IFDEF JAVA OR ISLAND}
      if Age.CompareTo(RTreeFile.Age) > 0 then
        RTreeFile.Clear ;
    {$ELSE}
      if Age > RTreeFile.Age then
        RTreeFile.Clear ;
    {$ENDIF}

    old_scope    := Scope      ;
    old_modified := FIsModified ;
    is_busy := False ;

    try
      if RTreeFile.IsEmpty then begin
        abrt    := False      ;
        line_no := 0          ;
        if assigned( Viewer ) then
          end_uid := GetLastUid
        else
          end_uid := 1        ;

        if assigned( Viewer ) then begin
          RaiseBusyPrepare( self, Format( _rsrc( GIS_RS_BUSY_RTREE ), [Name] ) ) ;
          is_busy := True ;
        end;

        cursorFirst( 0, False,
                     GisWholeWorld, '', nil, '', True
                   ) ;

        while not cursorEof(0) do begin
          cursorShapeEx(0).AddToIndex ;

          inc( line_no ) ;
          if line_no mod 1000 = 1 then begin
            abrt := RaiseBusyShake( self, cursorShapeEx(0).Uid, end_uid ) ;
            if abrt then begin
              UseRTree := False ;
              break ;
            end ;
          end ;

          cursorNext(0) ;
        end ;
      end
      else begin
        abrt    := False ;
        line_no := 0     ;

        if Items.Count > 0 then begin
          RaiseBusyPrepare( self, Format( _rsrc( GIS_RS_BUSY_RTREE ), [Name] ) ) ;
          is_busy := true ;
        end ;

        for i:=0 to Items.Count -1 do begin
          TGIS_Shape( Items[i] ).UpdateIndex ;

          inc( line_no ) ;
          if line_no mod 1000 = 1 then begin
            abrt := RaiseBusyShake( self, i, Items.Count -1 ) ;
            if abrt then begin
              UseRTree := False ;
              break ;
            end ;
          end ;

        end ;
      end ;
    finally
      if assigned( RTreeFile ) then
        if UseRTree then
          RTreeFile.Commit( True );

      Scope       := old_scope    ;
      FIsModified := old_modified ;
      if not FIsModified then
        ClearModified ;

      if is_busy then
        RaiseBusyRelease( self ) ;
    end ;

  except
  end ;
end ;

function TGIS_LayerVector.fget_PathFLD
  : String ;
begin
  Result := Path + GIS_FLD_EXT ;
end ;

function TGIS_LayerVector.fget_PathFLDX
  : String ;
begin
  Result := Path + GIS_FLDX_EXT ;
end ;

function TGIS_LayerVector.fget_Items
  : TGIS_ShapeList ;
begin
  Result := FItems ;
end ;

function TGIS_LayerVector.fget_Fields
  : TGIS_FieldInfoList ;
begin
  Result := FFields ;
end ;

function TGIS_LayerVector.fget_FieldsVirtual
  : TGIS_FieldInfoList ;
begin
  Result := FFieldsVirtual ;
end ;

{$IFDEF JAVA}
  procedure TGIS_LayerVector.addPaintShapeEvent(
    const _e : TGIS_ShapeEvent
  ) ;
  begin
    FOnPaintShape := _e ;
  end ;

  procedure TGIS_LayerVector.removePaintShapeEvent(
    const _e : TGIS_ShapeEvent
  ) ;
  begin
    FOnPaintShape := nil ;
  end ;

  procedure TGIS_LayerVector.addPaintShapeLabelEvent(
    const _e : TGIS_ShapeEvent
  ) ;
  begin
    FOnPaintShapeLabel := _e ;
  end ;

  procedure TGIS_LayerVector.removePaintShapeLabelEvent(
    const _e : TGIS_ShapeEvent
  ) ;
  begin
    FOnPaintShapeLabel := nil ;
  end ;

  procedure TGIS_LayerVector.addPaintShapeChartEvent(
    const _e : TGIS_ShapeEvent
  ) ;
  begin
    FOnPaintShapeChart := _e ;
  end ;

  procedure TGIS_LayerVector.removePaintShapeChartEvent(
    const _e : TGIS_ShapeEvent
  ) ;
  begin
    FOnPaintShapeChart := nil ;
  end ;
{$ENDIF}

procedure TGIS_LayerVector.cursorFirstInternal(
  const _cursor      : Integer     ;
  const _viewerCS    : Boolean     ;
  const _extent      : TGIS_Extent ;
  const _query       : String      ;
  const _shape       : TGIS_Shape  ;
  const _de9im       : String      ;
  const _skipDeleted : Boolean
) ;
var
  eps       : Double ;
  ext       : TGIS_Extent ;
  pos       : Integer ;
  cnt_items : Integer ;
  cnt_aggrg : Integer ;
const
  MAP_EPS_M   = 2.5 ;
  MAP_EPS_RAD = MAP_EPS_M / 40000000 * 2*Pi;
begin
  rJoin.Reset      := True         ;
  rJoin.LastUid    := -1           ;
  rJoin.Primary    := -1           ;

  cursorState[ _cursor ].curBindOffset := -1 ;

  if GisIsNoWorld( _extent ) then
    exit ;

  if GisIsWholeWorld( _extent ) and
     assigned( Viewer )         and
     _viewerCS                  and
     ( CS.EPSG <> 0 )
  then
    ext := ProjectedExtent
  else
    ext := _extent ;

  if not GisIsNoWorld( FScopeExtent ) then
    ext := GisCommonExtent( ext, FScopeExtent ) ;

  cursorState[ _cursor ].curRawExtent := ext ;

  if ( ext.XMin <= ext.XMax ) or
     ( ext.YMin <= ext.YMax ) then
  begin
    if assigned( Viewer ) and _viewerCS then begin
      ext := Viewer.Ref.UnrotatedExtent( ext ) ;
      ext := self.CS.ExtentFromCS( Viewer.Ref.CS, ext ) ;
      ext := transformExtent( False, ext ) ;

      if GisIsValidExtent( ext ) then begin

        eps := Max( Abs( ext.XMax - ext.XMin ),
                    Abs( ext.YMax - ext.YMin )
                  ) / 1e6 ;

        if      CS is TGIS_CSGeographicCoordinateSystem then
                eps := Max(
                         eps,
                         TGIS_CSGeographicCoordinateSystem(CS).Units.FromBase(
                           MAP_EPS_RAD
                         )
                       )
        else if CS is TGIS_CSProjectedCoordinateSystem then
                eps := Max(
                         eps,
                         TGIS_CSProjectedCoordinateSystem(CS).Units.FromBase(
                           MAP_EPS_M
                         )
                       )
        else    eps := Max( eps, 1e-6 ) ;
      end
      else
        eps := 0 ;
    end
    else begin
      eps := Max( Abs( ext.XMax - ext.XMin ),
                  Abs( ext.YMax - ext.YMin )
                ) / 1e10 ;
      if eps = 0 then
        eps := 1e-10 ;
    end;
  end
  else begin
    ext := GisNoWorld ;
    eps := 0 ;
  end;

  cursorState[ _cursor ].curExtent := GisExtent( ext.XMin - 2 * eps,
                                                 ext.YMin -     eps,
                                                 ext.XMax + 2 * eps,
                                                 ext.YMax +     eps
                                               ) ;

  if      IsStringEmpty( FScope ) then
          cursorState[ _cursor ].curQuery := _query
  else if IsStringEmpty( _query ) then
          cursorState[ _cursor ].curQuery := FScope
  else    cursorState[ _cursor ].curQuery := Format( '(%s) AND (%s)', [ FScope, _query ] ) ;

  cursorState[ _cursor ].curRelShape    := _shape       ;
  cursorState[ _cursor ].curDE9IM       := _de9im       ;
  cursorState[ _cursor ].curSkipDeleted := _skipDeleted ;

  cursorState[ _cursor ].curSqlQuery.Prepare( cursorState[ _cursor ].curQuery ) ;

  FreeObject( cursorState[ _cursor ].curTopology ) ;
  cursorState[ _cursor ].curTopology  := TGIS_Topology.Create ;
  TGIS_Topology( cursorState[ _cursor ].curTopology ).RelatePrepare( _shape ) ;

  cursorState[ _cursor ].curPos := -1 ;
  cursorState[_cursor].curAggregatedPos := -1 ;

  cnt_items := Items.Count ;
  cnt_aggrg := aggregatedItems.Count ;

  with cursorState[_cursor] do begin
    while True do begin
      {$IFNDEF ISLAND}
        inc( curPos ) ;
      {$ELSE}
        curPos := curPos + 1 ;
      {$ENDIF}
      if (cnt_items > 0) and ( curPos < cnt_items ) then begin
        curShape := TGIS_Shape( Items[ curPos ] ) ;

        if getAggregatedPos( curShape.Uid, pos ) then
          curShape := aggregatedItems[ pos ] ;

        if curShape.FIsNewShape then break ;
      end
      else begin
        curPos := cnt_items ;

        inc( curAggregatedPos ) ;
        if ( cnt_aggrg > 0 ) and ( curAggregatedPos < cnt_aggrg ) then begin
          curShape :=  TGIS_Shape( aggregatedItems[ curAggregatedPos ] ) ;
          if curShape.FIsNewShape then break ;
        end
        else begin
          curAggregatedPos := cnt_aggrg ;
          curShape := nil ;
          break ;
        end ;
      end ;
    end ;
  end;

  if assigned( FOnCursorBeforeFetch ) then
    FOnCursorBeforeFetch( self, _cursor ) ;
end ;

procedure TGIS_LayerVector.cursorNextInternal(
  const _cursor : Integer
) ;
var
  pos       : Integer ;
  cnt_items : Integer ;
  cnt_aggrg : Integer ;
begin

  cnt_items := Items.Count ;
  cnt_aggrg := aggregatedItems.Count ;

  with cursorState[_cursor] do begin
    while True do begin
      {$IFNDEF ISLAND}
        inc( curPos ) ;
      {$ELSE}
        curPos := curPos + 1 ;
      {$ENDIF}
      if (cnt_items > 0) and ( curPos < cnt_items )then begin
        curShape := TGIS_Shape( Items[ curPos ] ) ;

        if getAggregatedPos( curShape.Uid, pos ) then
          curShape := aggregatedItems[ pos ] ;

        if curShape.FIsNewShape then
          break ;
      end
      else begin
        curPos := cnt_items ;

        inc( curAggregatedPos ) ;
        if ( cnt_aggrg > 0 ) and ( curAggregatedPos < cnt_aggrg ) then begin
          curShape := TGIS_Shape( aggregatedItems[ curAggregatedPos ] ) ;
          if curShape.FIsNewShape then
            break ;
        end
        else begin
          curAggregatedPos := cnt_aggrg ;
          curShape := nil ;
          break ;
        end ;
      end ;
    end ;
  end ;
end ;

function TGIS_LayerVector.cursorEofInternal(
  const _cursor : Integer
) : Boolean ;
var
  cnt : Integer ;
begin
  with cursorState[_cursor] do begin
    cnt := Items.Count ;

    if ( cursorState[_cursor].curPos >= 0 ) and
       ( cnt > 0 )                          and
       ( cursorState[_cursor].curPos < cnt )
    then
      Result := False
    else
      Result := True ;

    cnt := aggregatedItems.Count ;

    if ( cursorState[_cursor].curAggregatedPos >= 0 ) and
       ( cnt > 0 )                                    and
       ( cursorState[_cursor].curAggregatedPos < cnt )
    then
      Result := False
    else
      Result := Result and True ;
  end;

end ;

function TGIS_LayerVector.cursorShapeInternal(
  const _cursor : Integer
) : TGIS_Shape ;
var
  cnt : Integer ;
  pos : Integer ;
begin
  with cursorState[ _cursor ] do begin
    if assigned( curShape ) then
      Result := curShape
    else begin
      cnt := Items.Count ;
      if (cnt > 0) and (curPos < cnt) then begin
        Result := TGIS_Shape( Items[ curPos ] ) ;

        if getAggregatedPos( Result.Uid, pos ) then
          Result := aggregatedItems[ pos ] ;
      end
      else begin
        cnt := aggregatedItems.Count ;
        if ( cnt > 0 ) and ( curAggregatedPos < cnt ) then begin
          Result := TGIS_Shape( aggregatedItems[ curAggregatedPos ] ) ;
        end
        else
          Result := nil ;
      end;
    end ;
  end;
end ;

function TGIS_LayerVector.cursorOpen
  :  Integer ;
var
  i : Integer ;
begin
  lockThread ;
  try
    Result := -1 ;

    // find empty cursor
    for i:=1 to length( cursorState ) - 1 do begin
      if not cursorState[i].curInUse then begin
        Result := i ;
        break ;
      end ;
    end ;

    // not found - create new one
    if Result < 0 then begin
      SetLength( cursorState, length( cursorState ) + 1 ) ;
      Result := length( cursorState ) -1 ;
      {$IFDEF GIS_NORECORDS}
        cursorState[Result] := new T_cursorState ;
      {$ENDIF}
      cursorState[Result].curDrawQuery := '' ;
      cursorState[Result].curQuery     := '' ;
      cursorState[Result].curDE9IM     := '' ;

      cursorState[Result].curTopology   := nil ;
      cursorState[Result].curCandidates := nil ;
      cursorState[Result].curSqlQuery   := nil ;
      cursorState[Result].curShape      := nil ;
      cursorState[Result].curRelShape   := nil ;
    end ;

    cursorState[Result].curInUse      := True ;
    cursorState[Result].curCandidates := TGIS_ShapeList.Create( False )  ;
    cursorState[Result].curSqlQuery   := TGIS_SqlQuery.Create ;

    if Result > 0 then
      cursorState[Result].curAggregatedPos := high( Integer ) ;

    if assigned( FOnCursorOpen ) then
      FOnCursorOpen( self, Result ) ;
  finally
    unlockThread ;
  end;
end;

procedure TGIS_LayerVector.cursorClose(
  const _cursor : Integer
) ;
var
  i : Integer ;
begin
  lockThread ;
  try
    cursorState[_cursor].curInUse := False ;

    FreeObject( cursorState[_cursor].curTopology   ) ;
    FreeObject( cursorState[_cursor].curCandidates ) ;
    FreeObject( cursorState[_cursor].curSqlQuery   ) ;

    // truncate cursorState at the tail;
    for i := length( cursorState ) - 1 downto 0 do begin
      if not cursorState[i].curInUse then begin
        SetLength( cursorState, i ) ;
      end
      else
        break ;
    end ;

    // reset closed cursor shapes
    if ( _cursor > 0 ) and ( assigned( Items ) )then
      for i := 0 to Items.Count - 1 do
        if TGIS_Shape( Items[ i ] ).FCursor = _cursor then
          TGIS_Shape( Items[ i ] ).FCursor := 0 ;

    if assigned( FOnCursorClose ) then
      FOnCursorClose( self, _cursor ) ;
  finally
    unlockThread ;
  end;
end;

procedure TGIS_LayerVector.cursorStateSave(
  const _cursor : Integer
) ;
begin
  if _cursor < BUILTIN_CURSORS then
    exit ;

  SetLength( cursorStateStore, length( cursorState ) ) ;
  {$IFDEF GIS_NORECORDS}
    if not assigned( cursorStateStore[_cursor] ) then
      cursorStateStore[_cursor] := new T_cursorState ;
  {$ENDIF}
  cursorStateStore[_cursor].curInUse       :=  cursorState[_cursor].curInUse      ;
  cursorStateStore[_cursor].curFindMode    :=  cursorState[_cursor].curFindMode   ;
  cursorStateStore[_cursor].curDrawQuery   :=  cursorState[_cursor].curDrawQuery  ;
  cursorStateStore[_cursor].curExtent      :=  cursorState[_cursor].curExtent     ;
  cursorStateStore[_cursor].curRawExtent   :=  cursorState[_cursor].curRawExtent  ;
  cursorStateStore[_cursor].curQuery       :=  cursorState[_cursor].curQuery      ;
  cursorStateStore[_cursor].curRelShape    :=  cursorState[_cursor].curRelShape   ;
  cursorStateStore[_cursor].curDE9IM       :=  cursorState[_cursor].curDE9IM      ;
  cursorStateStore[_cursor].curSkipDeleted :=  cursorState[_cursor].curSkipDeleted;
  cursorStateStore[_cursor].curTopology    :=  cursorState[_cursor].curTopology   ;
  cursorStateStore[_cursor].curCandidates  :=  cursorState[_cursor].curCandidates ;
  cursorStateStore[_cursor].curSqlQuery    :=  cursorState[_cursor].curSqlQuery   ;
end;

procedure TGIS_LayerVector.cursorStateRestore(
  const _cursor : Integer
) ;
begin
  if _cursor < BUILTIN_CURSORS then
    exit ;

  cursorState[_cursor].curInUse       :=  cursorStateStore[_cursor].curInUse      ;
  cursorState[_cursor].curFindMode    :=  cursorStateStore[_cursor].curFindMode   ;
  cursorState[_cursor].curDrawQuery   :=  cursorStateStore[_cursor].curDrawQuery  ;
  cursorState[_cursor].curExtent      :=  cursorStateStore[_cursor].curExtent     ;
  cursorState[_cursor].curRawExtent   :=  cursorStateStore[_cursor].curRawExtent  ;
  cursorState[_cursor].curQuery       :=  cursorStateStore[_cursor].curQuery      ;
  cursorState[_cursor].curRelShape    :=  cursorStateStore[_cursor].curRelShape   ;
  cursorState[_cursor].curDE9IM       :=  cursorStateStore[_cursor].curDE9IM      ;
  cursorState[_cursor].curSkipDeleted :=  cursorStateStore[_cursor].curSkipDeleted;
  cursorState[_cursor].curTopology    :=  cursorStateStore[_cursor].curTopology   ;
  cursorState[_cursor].curCandidates  :=  cursorStateStore[_cursor].curCandidates ;
  cursorState[_cursor].curSqlQuery    :=  cursorStateStore[_cursor].curSqlQuery   ;
end;


procedure TGIS_LayerVector.cursorFirst(
  const _cursor      : Integer     ;
  const _viewerCS    : Boolean     ;
  const _extent      : TGIS_Extent ;
  const _query       : String      ;
  const _shape       : TGIS_Shape  ;
  const _de9im       : String      ;
  const _skipDeleted : Boolean
) ;
var
  r   : Boolean ;
begin
  cursorFirstInternal( _cursor, _viewerCS,
                       _extent, _query, _shape, _de9im, _skipDeleted
                     ) ;
  cursorState[ _cursor ].curPos := -1 ;
  while True do begin

    cursorNextInternal( _cursor ) ;
    if cursorEofInternal(_cursor) then exit ;

    if cursorState[ _cursor ].curSkipDeleted and
       cursorShapeInternal(_cursor).IsDeleted
    then
      continue ;

    // isInScope replacement
    r := False ;
    if isShapeVisible( cursorShapeInternal( _cursor ), cursorState[ _cursor ].curExtent, _cursor ) then
      if not IsStringEmpty( cursorState[ _cursor ].curQuery ) then begin
        if cursorState[ _cursor ].curSqlQuery.ParseAsBoolean(
             cursorShapeEx(_cursor),
             False,
             _cursor
           )
        then
          r := True ;
      end
      else
        r := True ;

    if r and assigned( cursorState[ _cursor ].curRelShape ) then begin
      if not TGIS_Topology( cursorState[ _cursor ].curTopology ).Relate(
               cursorState[ _cursor ].curRelShape,
               cursorState[ _cursor ].curShape,
               cursorState[ _cursor ].curDE9IM
             )
      then
        r := False ;
    end ;
    if r then exit ;

  end ;

end ;

procedure TGIS_LayerVector.cursorNext(
  const _cursor : Integer
) ;
var
  shp     : TGIS_Shape ;
begin
  { TODO : add RTree code }

  while True do begin
    if HourglassShake then begin
      cursorState[ _cursor ].curShape := nil ;
    end ;

    cursorNextInternal( _cursor ) ;

    if cursorEof( _cursor ) then exit ;

    shp := cursorShapeEx(_cursor) ;
    if cursorState[ _cursor ].curSkipDeleted and shp.IsDeleted then
      continue ;
    if not isInScope( shp, _cursor ) then
      continue
    else
      exit ;
  end ;
end ;

function TGIS_LayerVector.cursorEof(
  const _cursor : Integer
) : Boolean ;
begin
  Result := cursorEofInternal(_cursor) ;
end ;

function TGIS_LayerVector.cursorShape(
  const _cursor : Integer
) : TGIS_Shape ;
begin
  Result := cursorShapeInternal( _cursor ) ;
end ;

function TGIS_LayerVector.cursorShapeEx(
  const _cursor : Integer
) : TGIS_Shape ;
begin
  Result := cursorShape( _cursor ) ;
  if assigned( Result ) then
    Result.FCursor := _cursor ;
end ;

function TGIS_LayerVector.cursorFindFirst(
  const _cursor      : Integer        ;
  const _viewerCS    : Boolean        ;
  const _extent      : TGIS_Extent    ;
  const _query       : String         ;
  const _shape       : TGIS_Shape     ;
  const _de9im       : String         ;
  const _skipDeleted : Boolean
) : TGIS_Shape ;
var
  res   : TGIS_Uid ;
  first : Boolean ;
  fe    : Double  ;
  boo   : Boolean ;
  ext   : TGIS_Extent ;
begin
  lockThread ;
  try
    cursorFirstInternal( _cursor, _viewerCS,
                         _extent, _query, _shape, _de9im, _skipDeleted
                       ) ;

    if ( _viewerCS
         and
         assigned( Viewer )
       )
       and
       (
         ( ( Viewer.Ref.CS.EPSG <> 0 ) and
           ( CS.EPSG        <> 0 ) and
           ( Viewer.Ref.CS.EPSG <> self.CS.EPSG )
         )
         or
         assigned( FTransform )
       )
    then begin
      if GisIsNoWorld( _extent ) then begin
        findSmartSizeFactor := 1 ;
      end
      else begin
        if GisIsWholeWorld( _extent ) then
          ext := _TGIS_Extent(ProjectedExtent)
        else
          ext := _TGIS_Extent(_extent) ;

        fe := Sqr( cursorState[ _cursor ].curExtent.XMax - cursorState[ _cursor ].curExtent.XMin ) +
              Sqr( cursorState[ _cursor ].curExtent.YMax - cursorState[ _cursor ].curExtent.YMin ) ;
        if fe = 0 then
          fe := 1 ;
        findSmartSizeFactor := Sqrt( Sqr( ext.XMax - ext.XMin ) +
                                     Sqr( ext.YMax - ext.YMin )
                                   ) / Sqrt( fe ) ;
      end ;
    end
    else
      findSmartSizeFactor := 1 ;

    oldMarkerPoint.X := -1E10 ;
    oldMarkerPoint.Y := -1E10 ;

    if GisIsWholeWorld( _extent ) or GisIsNoWorld( _extent ) then
      cursorState[ _cursor ].curFindMode := False
    else begin
      boo := assigned( RTreeFile ) and
             ( GisExtentArea( _extent ) < GisExtentArea( Extent ) / 8 ) ;
      cursorState[ _cursor ].curFindMode := boo ;
    end ;

    first := True ;
    Result := nil ;
    while Result = nil do begin
      if HourglassShake then begin
        Result := nil ;
        cursorInterrupt( _cursor ) ;
        break ;
      end;

      if cursorState[ _cursor ].curFindMode and RTreeFile.Valid then begin

        if first then begin
          // just to ensure proper cursor state
          cursorFirst( _cursor, False, GisNoWorld, '', nil, '', False ) ;
          oldMarkerPoint.X := -1E10 ;
          oldMarkerPoint.Y := -1E10 ;

          res := RTreeFile.FindFirst( _cursor,
                                      cursorState[ _cursor ].curExtent,
                                      -1
                                    ) ;
          cursorState[ _cursor ].curAggregatedPos := -1 ;
        end
        else
          res := RTreeFile.FindNext ( _cursor ) ;

        first := False ;
        if res < 0 then begin
          cursorNextAggregated( _cursor ) ;
          Result := cursorState[_cursor].curShape ;
          break ;
        end ;
        Result := GetShape( res, _cursor ) ;

        if Result = nil then
          continue ;
        if cursorState[ _cursor ].curSkipDeleted and Result.IsDeleted then begin
          Result := nil ;
          continue ;
        end ;
        if not isInScope(Result, _cursor) then begin
          Result := nil ;
          continue ;
        end ;

      end
      else
      begin
        if first then cursorFirst(
                        _cursor, _viewerCS,
                        _extent, _query, _shape, _de9im, _skipDeleted
                      )
                 else cursorNext(
                        _cursor
                      ) ;
        first := False ;
        if not cursorEof(_cursor) then Result := cursorShapeEx( _cursor )
                                  else begin
                                         Result := nil ;
                                         break ;
                                       end ;

      end ;

    end ;

    if cursorState[ _cursor ].curFindMode then
      cursorState[ _cursor ].curShape := Result ;

    if FUseShapeStyleField and ( not ( FIgnoreShapeParams ) ) then
      applyShapeStyleField( Result ) ;

    if assigned( FOnCursorShapeFetch ) then
      {$IFDEF OXYGENE}
        FOnCursorShapeFetch( Self, TGIS_ShapeEventArgs.Create(Result) ) ;
      {$ELSE}
        FOnCursorShapeFetch( Self, Result ) ;
      {$ENDIF}

  finally
    unlockThread ;
  end;
end ;

function TGIS_LayerVector.cursorFindNext(
  const _cursor      : Integer
) : TGIS_Shape ;
var
  res : TGIS_Uid    ;
begin
  lockThread ;
  try
    Result := nil ;

    while Result = nil do begin
      if HourglassShake then begin
        Result := nil ;
        cursorInterrupt( _cursor ) ;
        break ;
      end ;

      if cursorState[ _cursor ].curFindMode and RTreeFile.Valid then begin
        res := RTreeFile.FindNext( _cursor ) ;
        if res < 0 then begin
          cursorNextAggregated( _cursor ) ;
          Result := cursorState[_cursor].curShape ;
          break ;
        end ;
        Result := GetShape( res, _cursor ) ;

        if Result = nil then
          continue ;
        if cursorState[ _cursor ].curSkipDeleted and Result.IsDeleted then begin
          Result := nil ;
          continue ;
        end ;
        if not isInScope( Result, _cursor ) then begin
          Result := nil ;
          continue ;
        end ;
      end
      else begin

        cursorNext(_cursor) ;
        if not cursorEof(_cursor) then Result := cursorShapeEx(_cursor)
                                  else begin
                                         Result := nil ;
                                         break ;
                                       end ;

      end ;

    end ;

    if cursorState[ _cursor ].curFindMode then
      cursorState[ _cursor ].curShape := Result ;

    if FUseShapeStyleField and ( not ( FIgnoreShapeParams ) ) then
      applyShapeStyleField( Result ) ;

    if assigned( FOnCursorShapeFetch ) then
      {$IFDEF OXYGENE}
        FOnCursorShapeFetch( Self, TGIS_ShapeEventArgs.Create(Result) ) ;
      {$ELSE}
        FOnCursorShapeFetch( Self, Result ) ;
      {$ENDIF}

  finally
    unlockThread ;
  end ;
end ;

procedure TGIS_LayerVector.cursorFinish(
  const _cursor : Integer
) ;
begin
  //
end ;

procedure TGIS_LayerVector.cursorInterrupt(
  const _cursor : Integer
) ;
begin
  if assigned( FOnCursorInterrupt ) then
    FOnCursorInterrupt( self, _cursor ) ;
end ;

function TGIS_LayerVector.ForEach(
  const _extent      : TGIS_Extent ;
  const _query       : String      ;
  const _shape       : TGIS_Shape  ;
  const _de9im       : String      ;
  const _skipDeleted : Boolean     ;
  const _scale       : Double      ;
  const _callback    : TGIS_ForEachShapeEvent

) : Boolean ;
var
  i            : Integer           ;
  shp          : TGIS_Shape        ;
  rndr         : Boolean           ;
  cnt          : Integer           ;
  is_visible   : Boolean           ;
  render       : TGIS_ParamsRender ;
  old_scale    : Double            ;
  abrt         : Boolean           ;
  en           : TGIS_LayerVectorEnumerator ;
begin
  Result := True ;

  abrt := False ;

  if assigned( Viewer ) then begin
    old_scale := Viewer.Ref.ScaleAsFloat ;
    Viewer.Ref.Lock() ;
    try
      Viewer.Ref.ScaleAsFloat := old_scale ;
      if Viewer.Ref.Zoom <= 0 then exit ;

      try
        prepareParamsCache( namedStyle ) ;
        cnt := paramsCache.Count ;

        if cnt <= 0 then exit ;

        is_visible := False ;
        for i:= cnt -1 downto 0 do begin
          is_visible := is_visible or
                       TGIS_ParamsSectionVector( paramsCache[i] ).Visible ;
          if is_visible then break ;
        end ;

        if not is_visible then exit ;

        inDraw := True ;
        bIgnoreShapeParams := FIgnoreShapeParams ;

        try
          en := self.Loop( _extent, _query, _shape, _de9im, _skipDeleted
                ).GetEnumerator ;
          try
            while en.MoveNext do begin
              shp := en.GetCurrent ;

              shp.Layer.bIgnoreShapeParams := shp.Layer.IgnoreShapeParams ;
              try
                if checkParamsCache( shp, en.Cursor ) then begin
                  render := TGIS_ParamsSectionVector( Params ).Render ;

                  if not IsStringEmpty( render.Expression ) or
                     not IsStringEmpty( render.Chart ) then
                  begin
                    rndr := lockRender( shp, 0, en.Cursor ) ;
                    if rndr then begin
                      _callback( shp, abrt ) ;
                      if abrt then begin
                        Result := False ;
                        exit ;
                      end ;
                      unlockRender ;
                    end ;
                  end
                  else begin
                    _callback( shp, abrt ) ;
                    if abrt then begin
                      Result := False ;
                      exit ;
                    end ;
                  end ;
                end ;
              finally
                shp.Layer.bIgnoreShapeParams := False ;
              end;
            end ;
          finally
            FreeObject( en ) ;
          end;
        finally
          inDraw := False ;
          bIgnoreShapeParams := False ;
        end ;

      except
        on e : Exception do begin
          Result := False ;
          raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_LAYERBADFORMAT ) +
                                       '; ' + e.Message,
                                       Name, 101
                                     ) ;
        end ;
      end;

    finally
      Viewer.Ref.ScaleAsFloat := old_scale ;
      Viewer.Ref.Unlock( false ) ;
    end;

  end
  else begin
    try
      en := self.Loop( _extent, _query, _shape, _de9im, _skipDeleted
            ).GetEnumerator ;
      try
        while en.MoveNext do begin
          shp := en.GetCurrent ;
          _callback( shp, abrt ) ;
          if abrt then begin
            Result := False ;
            exit ;
          end ;
        end ;
      finally
        FreeObject( en );
      end ;
    except
      on e : Exception do begin
        raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_LAYERBADFORMAT ) +
                                     '; ' + e.Message,
                                     Name, 102
                                   ) ;
        end ;
    end;
  end;
end;

function TGIS_LayerVector.getShapePos(
  const _uid  : TGIS_Uid ;
  var   _ipos : Integer
) : Boolean ;
var
  ilow  : Integer ;
  ihigh : Integer ;
  shp   : TGIS_Shape ;
begin
  _ipos := 0 ;
  ilow  := 0 ;
  ihigh := Items.Count - 1 ;

  while ilow <= ihigh do begin
    _ipos  := ( ihigh + ilow ) div 2 ;
    shp := TGIS_Shape( Items[ _ipos ] ) ;
    if      shp.Uid < _uid then begin
                                  ilow  := _ipos + 1 ;
                                  _ipos := ilow ; // for finding a best
                                                  // fit position
                                end
    else if shp.Uid > _uid then ihigh := _ipos - 1
    else begin
      Result := True ;
      shp := TGIS_Shape( Items[_ipos] ) ;
      if shp.IsReverted then begin
        Items.Delete( _ipos ) ;
        FreeObject( shp ) ;
        Result := getShapePos( _uid, _ipos ) ;
      end ;
      exit ;
    end ;
  end ;
  Result := False ;
end ;

procedure TGIS_LayerVector.prepareCandidates(
  const _cursor : Integer
) ;
{$IFDEF DCC}
var
  itm : TGIS_Shape ;
{$ENDIF}
begin
  cursorState[ _cursor ].curCandidates.Clear ;
  for itm in Items do
    cursorState[ _cursor ].curCandidates.Add( itm ) ;
  for itm in aggregatedItems do begin
    if itm.FIsNewShape then
      cursorState[ _cursor ].curCandidates.Add( itm ) ;
  end;
end ;

procedure TGIS_LayerVector.removeCandidate(
  const _cursor : Integer ;
  const _shp    : TGIS_Shape
) ;
var
  k : Integer ;

  { Find candidate on the list using bisection.
  }
  function find_candidate(
    const _candidate : TGIS_Shape
  ) : Integer ;
  var
    ipos  : Integer ;
    ilow  : Integer ;
    ihigh : Integer ;
    shp   : TGIS_Shape ;
    uid   : TGIS_Uid ;
  begin
    Result := -1 ;

    if not assigned( _candidate ) then exit ;

    uid := _candidate.Uid ;

    ilow  := 0 ;
    ihigh := cursorState[ _cursor ].curCandidates.Count - 1 ;

    while ilow <= ihigh do begin
      ipos := ( ihigh + ilow ) div 2 ;
      shp  := TGIS_Shape( cursorState[ _cursor ].curCandidates[ ipos ] ) ;
      if      shp.Uid < uid then begin
                                   ilow := ipos + 1 ;
                                 end
      else if shp.Uid > uid then ihigh := ipos - 1
      else begin
        Result := ipos ;
        exit ;
      end ;
    end ;
  end ;

begin
  k := find_candidate( _shp ) ;
  if k >= 0 then
    cursorState[ _cursor ].curCandidates.Delete( k ) ;
end ;

function TGIS_LayerVector.nextCandidate(
  const _cursor : Integer
) : TGIS_Shape ;
var
  pos : Integer ;
begin
  Result := nil ;
  if cursorState[ _cursor ].curCandidates.Count > 0 then begin
    Result := TGIS_Shape( cursorState[ _cursor ].curCandidates[0] ) ;

    if getAggregatedPos( Result.Uid, pos ) then
      Result := aggregatedItems[ pos ] ;
    cursorState[ _cursor ].curCandidates.Delete(0);
  end ;
end ;

function TGIS_LayerVector.getFieldInternal(
  const _uid      : TGIS_Uid   ;
  const _name     : String  ;
  const _cursor   : Integer
) : Variant ;
begin
  // only for save inheritance
  Result := NullVar ;
end ;

function TGIS_LayerVector.bindField(
  const _name    : String ;
  const _cursor  : Integer
) : Integer ;
var
  wasjoin : Boolean ;

    {$IFDEF CLR}
      dr        : IDataReader ;
      dt        : DataTable   ;
      fldDR_NET : DataRow     ;
      fldDT_NET : DataColumn  ;
      i         : Integer     ;
    {$ENDIF}

  {$IFNDEF GIS_NODB}
    fld_DB : TField  ;
  {$ENDIF}
  fld_name : String  ;

  {$IFNDEF GIS_NOADO_JOIN}
    function set_fld_ADO
      : Integer ;
    var
      ii      : Integer ;
      fld_ADO : Field   ;
    begin
      Result := -1 ;
      fld_name := FromJoinFieldName( _name ) ;
      for ii := 0 to _Recordset(JoinADO).Fields.Count -1 do
        if CompareText( _Recordset(JoinADO).Fields[ ii ].Name, fld_name ) = 0 then
        begin
          Result := ii ;
          break ;
        end ;

      if Result > -1 then
        fld_ADO :=  _Recordset(JoinADO).Fields[ fld_name ] ;
      if assigned( fld_ADO ) then begin
        if high( rJoin.FieldsADO ) < Result + 1 then
          SetLength( rJoin.FieldsADO, Result + 1 ) ;
        rJoin.FieldsADO[ Result ] := fld_ADO ;
        Result := Result + GIS_JOIN_FIELD_ID ;
      end ;
    end;
  {$ENDIF}

  {$IFNDEF GIS_NOJDBC}
    function set_fld_jdbc
      : Integer ;
    var
      ii        : Integer;
      fld_jdbc  : String;
     begin
      result := -1;
      fld_name := _name;
      for ii := 1 to java.sql.ResultSet(JoinJDBC).getMetaData.ColumnCount do begin
        if  CompareText(java.sql.ResultSet(JoinJDBC).getMetaData.ColumnName[ii], fld_name) = 0 then begin
          result := ii;
          SetLength( rJoin.Columns, Result + 1 );
          rJoin.Columns[ii] := ii;
          break;
        end;
      end;
      if result > 0 then
        //repeat
          fld_jdbc := java.sql.ResultSet(JoinJDBC).getString(fld_name);
          if assigned(fld_jdbc) then begin
            if high( rJoin.FieldsJDBC ) < Result + 1 then
              SetLength( rJoin.FieldsJDBC, Result + 1 );
            rJoin.FieldsJDBC[ Result ] := fld_jdbc ;
            //break;
           end;
        Result := Result + GIS_JOIN_FIELD_ID - 1;

      end;
  {$ENDIF}

begin
  Result := -1 ;
  {$IFNDEF GIS_NOADO}
    {$IFDEF CLR}
      fldDR_NET := nil ;
      fldDT_NET := nil ;
    {$ENDIF}
  {$ENDIF}

  fld_name := '' ; // to avoid hints

  if cursorState[ _cursor ].curBindOffset < 0 then begin
    if Fields.Count > 0 then begin
      cursorState[ _cursor ].curBindOffset := bindFieldInternal(
                                                TGIS_FieldInfo( Fields[ 0 ] ).Name,
                                                _cursor
                                              ) ;
      if cursorState[ _cursor ].curBindOffset < 0 then
        cursorState[ _cursor ].curBindOffset := 0 ;
    end
    else
      cursorState[ _cursor ].curBindOffset := 0 ;
  end ;

  // is build in field
  Result := FindField( _name ) ;
  if Result >= GIS_FIELD_ID_UID then exit ;

  // is internal field
  Result := bindFieldInternal( _name, _cursor ) ;
  if Result < 0 then
    Result := FindField( _name ) ;
  if Result >= 0 then
    exit ;

  // is joined field
  wasjoin := False ;

  {$IFNDEF GIS_NODB}
    if ( not wasjoin) and assigned( JoinDB ) then begin
      wasjoin := True ;
      fld_name := FromJoinFieldName( _name ) ;
      fld_DB := JoinDB.FieldByName( fld_name ) ;
      if assigned( fld_DB ) then begin
        Result := fld_DB.FieldNo ;
        if high( rJoin.FieldsDB ) < Result + 1 then
          SetLength( rJoin.FieldsDB, Result + 1 ) ;
        rJoin.FieldsDB[ Result ] := fld_DB ;
        Result := Result + GIS_JOIN_FIELD_ID ;
      end ;
    end ;
  {$ENDIF}


    {$IFDEF CLR}
      if ( not wasjoin) and assigned( JoinNET ) then begin
        wasjoin := True ;
        fld_name := FromJoinFieldName( _name ) ;
        if JoinNET is IDataReader then begin
          dr := JoinNET as IDataReader ;
          for i := 0 to dr.GetSchemaTable.Rows.Count -1 do
            if CompareText(
              dr.GetSchemaTable.Rows[i].Item[ 'ColumnName' ].ToString,
              fld_name
            ) = 0 then
            begin
              Result := i ;
              break ;
            end ;

          if Result > -1 then
            fldDR_NET := dr.GetSchemaTable.Rows[ Result ] ;
          if assigned( fldDR_NET ) then begin
            if high( rJoin.FieldsRowsNET ) < Result + 1 then
              SetLength( rJoin.FieldsRowsNET, Result + 1 ) ;
            rJoin.FieldsRowsNET[ Result ] := fldDR_NET ;
            Result := Result + GIS_JOIN_FIELD_ID ;
          end ;
        end
        else if JoinNET is DataTable then begin
          dt := JoinNET as DataTable ;
          for i := 0 to dt.Columns.Count -1 do
            if CompareText(
              dt.Columns[ i ].ColumnName,
              fld_name
            ) = 0 then
            begin
              Result := i ;
              break ;
            end ;

          if Result >= 0 then
            fldDT_NET := dt.Columns[ fld_name ] ;
          if assigned( fldDT_NET ) then begin
            if high( rJoin.FieldsColsNET ) < Result + 1 then
              SetLength( rJoin.FieldsColsNET, Result + 1 ) ;
            rJoin.FieldsColsNET[ Result ] := fldDT_NET ;
            Result := Result + GIS_JOIN_FIELD_ID ;
          end ;
        end ;
      end ;
    {$ENDIF}


  {$IFNDEF GIS_NOADO_JOIN}
    if ( not wasjoin) and assigned( JoinADO ) then begin
      //wasjoin := True ;
      Result := set_fld_ADO ;
    end ;
  {$ENDIF}
  {$IFNDEF GIS_NOJDBC}
    if ( not wasjoin) and assigned( JoinJDBC ) then begin
      //wasjoin := True ;
      Result := set_fld_jdbc ;
    end ;
  {$ENDIF}

end ;

function TGIS_LayerVector.bindFieldInternal(
  const _name    : String ;
  const _cursor  : Integer
) : Integer ;
begin
  // only for save inheritance
  Result := FindFieldInternal( _name ) ;
end ;

function TGIS_LayerVector.getBindedField(
  const _shape  : TObject ;
  const _field  : Integer ;
  const _cursor : Integer
) : Variant ;
var
  id      : Integer    ;
  shp     : TGIS_Shape ;
  iscs    : Boolean    ;
  wasjoin : Boolean  ;

  {$IFNDEF GIS_NOADO_JOIN}
    function _convertADOFieldCP
      : Variant ;
    begin
      Result := ConvertADOFieldCP( rJoin.FieldsADO[ id ],
                                   JoinCodePage
                                 ) ;
    end ;
  {$ENDIF}
  {$IFNDEF GIS_NOJDBC}
    function _convertJDBCFieldCP
      : Variant ;
    begin
      result := ConvertJDBCFieldCP(rJoin.FieldsJDBC[id + 1], JoinCodePage);
    end;
  {$ENDIF}
begin
  Result := Unassigned ;

  shp := TGIS_Shape( _shape ) ;

  if _field < 0 then exit ;

  if not assigned( shp ) then exit ;

  iscs := CS.EPSG > 0  ;

  if _field >= GIS_FIELD_ID_UID  then begin
    Result := shp.getVirtualField( _field, iscs ) ;
    if not VarIsEmpty( Result ) then
      exit ;
  end ;

  id := _field - cursorState[ _cursor ].curBindOffset ;
  if assigned( shp.mappedFields ) then
    if ( id >= 0 ) and shp.mappedFields.Exists( id ) then begin
      Result := shp.mappedFields[id] ;
      if not VarIsEmpty( Result ) then exit ;
    end ;
  if _field < GIS_JOIN_FIELD_ID then
    try
      Result := getBindedFieldInternal( _shape, _field, _cursor ) ;
      if VarIsEmpty( Result ) then // non exiting fields
        Result := NullVar ;
      exit ;
    except
      Result := Unassigned ;
      exit ;
    end ;

  id := _field - GIS_JOIN_FIELD_ID ;
  if shp.syncJoin then begin
    wasjoin := False ;

    {$IFNDEF GIS_NODB}
      if ( not wasjoin) and assigned( JoinDB ) then begin
        wasjoin := True ;
        Result := ConvertDBFieldCP( rJoin.FieldsDB[ id ],
                                    JoinCodePage
                                  ) ;
      end ;
    {$ENDIF}


      {$IFDEF CLR}
        if ( not wasjoin) and assigned( JoinNET ) then begin
          wasjoin := True ;
          if JoinNET is IDataReader then
            Result := ConvertNETFieldCP( IDataReader(JoinNET),
                                         rJoin.FieldsRowsNET[ id ],
                                         JoinCodePage
                                       )
          else if JoinNET is DataTable then
            Result := ConvertNETFieldCP( DataTable(JoinNET).Rows[rJoin.RowNET],
                                         rJoin.FieldsColsNET[ id ],
                                         JoinCodePage
                                       ) ;
        end ;
      {$ENDIF}


    {$IFNDEF GIS_NOADO_JOIN}
      if ( not wasjoin) and assigned( JoinADO ) then begin
        //wasjoin := True ;
        Result := _convertADOFieldCP ;
      end ;
    {$ENDIF}
    {$IFNDEF GIS_NOJDBC}
      if ( not wasjoin) and assigned( JoinJDBC ) then begin
        //wasjoin := True ;
        Result := _convertJDBCFieldCP ;
      end ;
    {$ENDIF}
  end ;
end ;

function TGIS_LayerVector.getBindedFieldInternal(
  const _shape  : TObject ;
  const _field  : Integer ;
  const _cursor : Integer
) : Variant ;
begin
  // only for save inheritance
  Result := NullVar ;
end ;

function TGIS_LayerVector.getStatistics(
  const _field    : String  ;
  const _function : String
) : Variant ;
var
  sfield    : String ;
  sfunction : String ;
  res       : TGIS_StatisticsResult ;

  procedure ensure_statistics(
    const _name : String;
    const _fun  : TGIS_StatisticalFunction
  ) ;
  begin
    Statistics.Add( _name, TGIS_StatisticalFunctions.Create( _fun ) ) ;
  end ;

begin
  Result := NullVar ;

  sfunction := UpperCase( Trim ( _function ) ) ;
  sfield    := Trim( _field ) ;

  res := Statistics.Get( sfield ) ;

  if      sfunction = 'COUNT' then begin
    if assigned( res ) and
       ( res.Count.Calculated or res.Count.Requested ) then
      Result := res.Count.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Count ) ;
  end
  else if sfunction = 'AVG' then begin
    if assigned( res ) and
       ( res.Average.Calculated or res.Average.Requested ) then
      Result := res.Average.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Average ) ;
  end
  else if sfunction = 'COUNTNULL' then begin
    if assigned( res ) and
       ( res.CountMissings.Calculated or res.CountMissings.Requested ) then
      Result := res.CountMissings.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.CountMissings ) ;
  end
  else if sfunction = 'MAX' then begin
    if assigned( res ) and
       ( res.Max.Calculated or res.Max.Requested ) then
      Result := res.Max.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Max ) ;
  end
  else if sfunction = 'MAJORITY' then begin
    if assigned( res ) and
       ( res.Majority.Calculated or res.Majority.Requested ) then
      Result := res.Majority.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Majority ) ;
  end
  else if sfunction = 'MEDIAN' then begin
    if assigned( res ) and
       ( res.Median.Calculated or res.Median.Requested ) then
      Result := res.Median.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Median ) ;
  end
  else if sfunction = 'MIN' then begin
    if assigned( res ) and
       ( res.Min.Calculated or res.Min.Requested ) then
      Result := res.Min.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Min ) ;
  end
  else if sfunction = 'MINORITY' then begin
    if assigned( res ) and
       ( res.Minority.Calculated or res.Minority.Requested ) then
      Result := res.Minority.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Minority ) ;
  end
  else if sfunction = 'RANGE' then begin
    if assigned( res ) and
       ( res.Range.Calculated or res.Range.Requested ) then
      Result := res.Range.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Range ) ;
  end
  else if sfunction = 'STDEV' then begin
    if assigned( res ) and
       ( res.StandardDeviation.Calculated or res.StandardDeviation.Requested ) then
      Result := res.StandardDeviation.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.StandardDeviation ) ;
  end
  else if sfunction = 'SUM' then begin
    if assigned( res ) and
       ( res.Sum.Calculated or res.Sum.Requested ) then
      Result := res.Sum.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Sum ) ;
  end
  else if sfunction = 'VARIANCE' then begin
    if assigned( res ) and
       ( res.Variance.Calculated or res.Variance.Requested ) then
      Result := res.Variance.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Variance ) ;
  end
  else if sfunction = 'VARIETY' then begin
    if assigned( res ) and
       ( res.Variety.Calculated or res.Variety.Requested ) then
      Result := res.Variety.Value
    else
      ensure_statistics( sfield, TGIS_StatisticalFunction.Variety ) ;
  end ;
end;

function TGIS_LayerVector.isShapeVisible(
  const _shape  : TGIS_Shape ;
  const _extent : TGIS_Extent ;
  const _cursor : Integer
) : Boolean ;
var
  box   : TGIS_Extent ;
  ctx   : TGIS_Point  ;
  ssize : Integer     ;
  vwr   : TGIS_ViewerRef ;
begin
  if not assigned( _shape ) or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  Result := True ;

  // shape bounding + shape size
  box := _shape.Extent ;
  vwr := Viewer ;

  // is visible area > 0
  if (_extent.XMin > _extent.XMax) or (_extent.YMin > _extent.YMax) then
  begin
    Result := False ;
    exit ;
  end ;

  // is any part of a shape bounding inside visible area
  if box.XMax < _extent.XMin then begin
    Result := False ;
    exit ;
  end ;
  if box.XMin > _extent.XMax then begin
    Result := False ;
    exit ;
  end ;
  if box.YMax < _extent.YMin then begin
    Result := False ;
    exit ;
  end ;
  if box.YMin > _extent.YMax then begin
    Result := False ;
    exit ;
  end ;

  if assigned( vwr )
     and
     vwr.Ref.InPaint
     and
     assigned( _shape.Layer.ParentLayer )
     and not _shape.Layer.Active
  then begin
    Result := False ;
    exit ;
  end ;

  if assigned( FDynamicAggregator ) and FDynamicAggregator.IsPreparing then
    exit ;


  // very small shapes (other than points) are not visible
  if (_cursor = 0) and assigned( vwr ) and vwr.Ref.InPaint then begin
    if ( SelectedList.Count = 0 ) or ( not _shape.IsSelected ) then begin
      ssize := _shape.SmartSize ;
      if ssize <> 0 then begin
        if _shape.ShapeType = TGIS_ShapeType.MultiPoint then begin
          // ignore single point within multipoint scenario
          if GisIsEmptyExtent( _shape.Extent ) then begin
            if ( GisPoint2Point( oldMarkerPoint, _shape.Centroid )
                 * vwr.Ref.Zoom * findSmartSizeFactor
               ) <= vwr.Ref.TwipsToPixels(ssize)
            then
              Result := False ;
          end;
        end
        else if _shape.ShapeType = TGIS_ShapeType.Point then begin
          ctx := GisPoint( box.XMin, box.YMin ) ;
          if ( GisPoint2Point( oldMarkerPoint, ctx )
               * vwr.Ref.Zoom * findSmartSizeFactor
             ) <= vwr.Ref.TwipsToPixels(ssize)
          then
            Result := False ;
        end
        else begin
          if ( ( ( box.XMax - box.XMin ) + ( box.YMax - box.YMin )
               ) * vwr.Ref.Zoom * findSmartSizeFactor
             ) <= vwr.Ref.TwipsToPixels(ssize)
          then
            Result := False ;
        end ;
      end ;
    end ;
  end ;
end ;

procedure TGIS_LayerVector.setUp();
begin
  inherited ;

  FSupportedShapes := GisGetEmptyShapeType ;
  FSupportedShapes := GisAddShapeType( FSupportedShapes, TGIS_ShapeType.Point ) ;
  FSupportedShapes := GisAddShapeType( FSupportedShapes, TGIS_ShapeType.Arc ) ;
  FSupportedShapes := GisAddShapeType( FSupportedShapes, TGIS_ShapeType.Polygon ) ;
  FSupportedShapes := GisAddShapeType( FSupportedShapes, TGIS_ShapeType.MultiPoint ) ;
  FSupportedShapes := GisAddShapeType( FSupportedShapes, TGIS_ShapeType.Complex ) ;
  FSupportedShapes := GisAddShapeType( FSupportedShapes, TGIS_ShapeType.MultiPatch ) ;

  FSupportedDimensions := GisGetEmptyDimensionType ;
  FSupportedDimensions := GisAddDimensionType( FSupportedDimensions, TGIS_DimensionType.XY ) ;
  FSupportedDimensions := GisAddDimensionType( FSupportedDimensions, TGIS_DimensionType.XYZ ) ;
  FSupportedDimensions := GisAddDimensionType( FSupportedDimensions, TGIS_DimensionType.XYM ) ;
  FSupportedDimensions := GisAddDimensionType( FSupportedDimensions, TGIS_DimensionType.XYZM ) ;
  FFileInfo := 'Generic Vector Layer' ;
end ;

procedure TGIS_LayerVector.setUp2 ;
begin
  inherited ;

  // turn off any opened Rtree - important for example for MIF reopening
  UseRTree := False ;

  if SafeFileExists( PathRTree ) then
    UseRTree := True
  else begin
    if assigned( Viewer ) then
      UseRTree := Viewer.Ref.UseRTree ;
  end ;

  ReadFieldDefinition ;
  ReadFieldRules ;
end ;

procedure TGIS_LayerVector.setUp3 ;
begin
  if GisTestDimensionType( TGIS_DimensionType.XYZM, SupportedDimensions ) then
  begin
    fset_View3DMode( TGIS_3DLayerType.Shapes ) ;

    Params.SetGround( TGIS_3DGroundType.AboveZero ) ;
    Params.SetBasement( TGIS_3DBasementType.Off ) ;
  end
  else
  if GisTestDimensionType( TGIS_DimensionType.XYM, SupportedDimensions ) then
  begin
    fset_View3DMode( TGIS_3DLayerType.Shapes );

    Params.SetGround( TGIS_3DGroundType.OnDem ) ;
    Params.SetBasement( TGIS_3DBasementType.Lowest ) ;
  end
  else
  if GisTestDimensionType( TGIS_DimensionType.XYZ, SupportedDimensions ) then
  begin
    fset_View3DMode( TGIS_3DLayerType.Shapes ) ;

    Params.SetGround( TGIS_3DGroundType.AboveZero ) ;
    Params.SetBasement( TGIS_3DBasementType.Off ) ;
  end
  else
  begin
    fset_View3DMode( TGIS_3DLayerType.Off );

    Params.SetGround( TGIS_3DGroundType.OnDem ) ;
    Params.SetBasement( TGIS_3DBasementType.Off ) ;
  end ;
end ;

procedure TGIS_LayerVector.applyConfigOptions(
  const _cfg : TGIS_ConfigAbstract
) ;
var
  saggregartor : String ;
  oaggregator :  TGIS_DynamicAggregatorAbstract ;
begin
  inherited ;

  with TGIS_Config( _cfg ) do begin
    FMultipassRendering :=
      ReadBoolean( GIS_INI_MULTIPASSRENDERING, FMultipassRendering ) ;

    FIgnoreShapeParams :=
      ReadBoolean( GIS_INI_IGNORESHAPEPARAMS , FIgnoreShapeParams ) ;

    FScope            :=
      ReadString( GIS_INI_SCOPE             , FScope      );

    FScopeExtent.XMin :=
      ReadFloat ( GIS_INI_SCOPEEXTENT_XMIN  , FScopeExtent.XMin ) ;
    FScopeExtent.XMax :=
      ReadFloat ( GIS_INI_SCOPEEXTENT_XMAX  , FScopeExtent.XMax ) ;
    FScopeExtent.YMin :=
      ReadFloat ( GIS_INI_SCOPEEXTENT_YMIN  , FScopeExtent.YMin ) ;
    FScopeExtent.YMax :=
      ReadFloat ( GIS_INI_SCOPEEXTENT_YMAX  , FScopeExtent.YMax ) ;

    JoinPrimary :=
      ReadString ( GIS_INI_JOIN_PRIMARY     , JoinPrimary       ) ;
    JoinForeign :=
      ReadString ( GIS_INI_JOIN_FOREIGN     , JoinForeign       ) ;

    saggregartor :=
      ReadString ( GIS_INI_AGGREGATOR_NAME  , ''                ) ;

    if saggregartor <> '' then begin
      oaggregator := TGIS_DynamicAggregatorFactory.CreateInstance(
                             saggregartor,
                             self
                           ) ;
      oaggregator.useConfig := True ;
      DynamicAggregator := oaggregator ;
      if assigned( DynamicAggregator ) then begin
        DynamicAggregator.applyConfigOptions( _cfg ) ;
        DynamicAggregator.SetUp ;
      end ;
      oaggregator.useConfig := False ;
    end;
  end ;
end ;

procedure TGIS_LayerVector.storeConfigOptions(
  const _cfg : TGIS_ConfigAbstract
) ;
begin
  inherited ;

  with TGIS_Config( _cfg ) do begin
    WriteBoolean(
      GIS_INI_MULTIPASSRENDERING, FMultipassRendering, False
    ) ;

    WriteBoolean(
      GIS_INI_IGNORESHAPEPARAMS , FIgnoreShapeParams, False
    ) ;

    WriteString (
      GIS_INI_SCOPE             , FScope           , ''
    ) ;
    WriteFloat  (
      GIS_INI_SCOPEEXTENT_XMIN  , FScopeExtent.XMin, GisNoWorld.XMin
    ) ;
    WriteFloat  (
      GIS_INI_SCOPEEXTENT_XMAX  , FScopeExtent.XMax, GisNoWorld.XMax
    ) ;
    WriteFloat  (
      GIS_INI_SCOPEEXTENT_YMIN  , FScopeExtent.YMin, GisNoWorld.YMin
    ) ;
    WriteFloat  (
      GIS_INI_SCOPEEXTENT_YMAX  , FScopeExtent.YMax, GisNoWorld.YMax
    ) ;

    WriteString (
      GIS_INI_JOIN_PRIMARY      , JoinPrimary      , ''
    ) ;
    WriteString (
      GIS_INI_JOIN_FOREIGN      , JoinForeign      , ''
    ) ;

    if not assigned( DynamicAggregator ) then
      WriteString (
        GIS_INI_AGGREGATOR_NAME , ''               , ''
      )
    else begin
      WriteString (
        GIS_INI_AGGREGATOR_NAME , DynamicAggregator.Name, ''
      ) ;
      DynamicAggregator.storeConfigOptions(  _cfg ) ;
    end ;

  end ;
end ;

function TGIS_LayerVector.isInScope(
  const _shape  : TGIS_Shape ;
  const _cursor : Integer
) : Boolean ;
begin
  {$IFDEF MONO}
    {$WARNING '### Verify MONO code'}
    Result := True ;
  {$ELSE}
    Result := False ;

    if not assigned( _shape ) then exit ;

    with cursorState[ _cursor ] do begin
      if isShapeVisible( _shape, curExtent, _cursor ) then begin
        if not IsStringEmpty( curQuery ) then begin
          Result := curSqlQuery.ParseAsBoolean(
                      _shape,
                      False,
                      _cursor
                    ) ;
        end
        else
          Result := True
      end ;
      if Result and assigned( curRelShape ) then begin
        if not TGIS_Topology( curTopology ).Relate(
                 curRelShape, _shape, curDE9IM
               )
        then
          Result := False ;
      end ;

    end ;
  {$ENDIF}
end ;

function TGIS_LayerVector.getEdited(
  const _shape : TGIS_Shape
) : TGIS_Shape ;
var
  ipos : Integer ;
begin
  Result := _shape ;

  if not assigned( _shape ) then exit ;

  if getShapePos( _shape.Uid, ipos ) then begin
    Result := TGIS_Shape( Items[ ipos ] ) ;
  end ;

  if getAggregatedPos( Result.Uid, ipos ) then begin
    Result := TGIS_Shape( aggregatedItems[ ipos ] ) ;
  end ;

end ;

function TGIS_LayerVector.lockRender(
  const _shape  : TGIS_Shape ;
  const _value  : Double ;
  const _cursor : Integer
) : Boolean ;
var
  i             : Integer ;
  use_renderer  : Boolean ;
  render_color  : TGIS_Color ;
  render_size   : Integer ;
  params_render : TGIS_ParamsRender  ;
  params_line   : TGIS_ParamsLine    ;
  params_area   : TGIS_ParamsArea    ;
  params_marker : TGIS_ParamsMarker  ;
  params_label  : TGIS_ParamsLabel   ;
  params_chart  : TGIS_ParamsChart   ;
  chartobj      : TList<TGIS_SqlQuery> ;

  procedure alter_line ;
  begin
    if not rLockedRender.bLine then begin
      rLockedRender.bLine := True ;
      rLockedRender.pLine.Assign( params_line ) ;
    end ;
  end ;

  procedure alter_area ;
  begin
    if not rLockedRender.bArea then begin
      rLockedRender.bArea := True ;
      rLockedRender.pArea.Assign( params_area ) ;
    end ;
  end ;

  procedure alter_marker ;
  begin
    if not rLockedRender.bMarker then begin
      rLockedRender.bMarker := True ;
      rLockedRender.pMarker.Assign( params_marker ) ;
    end ;
  end ;

  procedure alter_label ;
  begin
    if not rLockedRender.bLabel then begin
      rLockedRender.bLabel := True ;
      rLockedRender.pLabel.Assign( params_label ) ;
    end ;
  end ;

  procedure alter_chart ;
  begin
    if not rLockedRender.bChart then begin
      rLockedRender.bChart := True ;
      rLockedRender.pChart.Assign( params_chart ) ;
    end ;
  end ;

begin
  LockRenderInternal ;
  try
    Result := False;
    use_renderer := prepareRender( _shape, _value, _cursor, Params, render_color, render_size ) ;

    params_render := Params.Render ;
    params_line   := Params.Line   ;
    params_area   := Params.Area   ;
    params_marker := Params.Marker ;
    params_label  := Params.Labels ;
    params_chart  := Params.Chart  ;

    if not IsStringEmpty( params_render.Chart ) then begin
      if assigned( _shape ) then begin
        chartobj := params_render.ChartObj ;
        SetLength( params_chart.ValuesInternal, chartobj.Count ) ;
        for i:=0 to high( params_chart.ValuesInternal ) do begin
          if assigned( chartobj[i] ) then
            params_chart.ValuesInternal[i] :=
              TGIS_SqlQuery( chartobj[i] ).ParseAsFloat( _shape, 0, _cursor )
          else
            params_chart.ValuesInternal[i] := GIS_MAX_DOUBLE ;
        end ;
      end ;
    end ;

    // apply render values
    rLockedRender.oldSerial := Params.Serial;
    rLockedRender.bLine     := False ;
    rLockedRender.bArea     := False ;
    rLockedRender.bMarker   := False ;
    rLockedRender.bLabel    := False ;
    rLockedRender.bChart    := False ;

    if params_line.Width               = GIS_RENDER_SIZE  then begin
       alter_line ;
       if use_renderer then
         params_line.Width            := render_size
       else
         params_line.Width            := rLockedRender.dLine.Width ;
     end ;
    if params_line.Color.ARGB          = TGIS_Color.RenderColor.ARGB then begin
       alter_line ;
       if use_renderer then
         params_line.Color            := render_color
       else
         params_line.Color            := rLockedRender.dLine.Color ;
     end ;
    if params_line.OutlineWidth        = GIS_RENDER_SIZE  then begin
       alter_line ;
       if use_renderer then
         params_line.OutlineWidth     := render_size
       else
         params_line.OutlineWidth     := rLockedRender.dLine.OutlineWidth ;
     end ;
    if params_line.OutlineColor.ARGB   = TGIS_Color.RenderColor.ARGB then begin
       alter_line ;
       if use_renderer then
         params_line.OutlineColor     := render_color
       else
         params_line.OutlineColor     := rLockedRender.dLine.OutlineColor ;
     end ;
    if params_line.OffsetX             = GIS_RENDER_SIZE  then begin
       alter_line ;
       if use_renderer then
         params_line.OffsetX          := render_size
       else
         params_line.OffsetX          := rLockedRender.dLine.OffsetX ;
     end ;
    if params_line.OffsetY             = GIS_RENDER_SIZE  then begin
       alter_line ;
       if use_renderer then
         params_line.OffsetY          := render_size
       else
         params_line.OffsetY          := rLockedRender.dLine.OffsetY ;
     end ;
    if params_area.Color.ARGB          = TGIS_Color.RenderColor.ARGB then begin
       alter_area ;
       if use_renderer then
         params_area.Color            := render_color
       else
         params_area.Color            := rLockedRender.dArea.Color ;
     end ;
    if params_area.OutlineColor.ARGB   = TGIS_Color.RenderColor.ARGB then begin
       alter_area ;
       if use_renderer then
         params_area.OutlineColor     := render_color
       else
         params_area.OutlineColor     := rLockedRender.dArea.OutlineColor
     end ;
    if params_area.OutlineWidth        = GIS_RENDER_SIZE  then begin
       alter_area ;
       if use_renderer then
         params_area.OutlineWidth     := render_size
       else
         params_area.OutlineWidth     := rLockedRender.dArea.OutlineWidth
     end ;
    if params_area.OffsetX             = GIS_RENDER_SIZE  then begin
       alter_area ;
       if use_renderer then
         params_area.OffsetX          := render_size
       else
         params_area.OffsetX          := rLockedRender.dArea.OffsetX ;
     end ;
    if params_area.OffsetY             = GIS_RENDER_SIZE  then begin
       alter_area ;
       if use_renderer then
         params_area.OffsetY          := render_size
       else
         params_area.OffsetY          := rLockedRender.dArea.OffsetY ;
     end ;
    if params_marker.Size              = GIS_RENDER_SIZE  then begin
       alter_marker ;
       if use_renderer then
         params_marker.Size           := render_size
       else
         params_marker.Size           := rLockedRender.dMarker.Size
     end ;
    if params_marker.Color.ARGB        = TGIS_Color.RenderColor.ARGB then begin
       alter_marker ;
       if use_renderer then
         params_marker.Color         := render_color
       else
         params_marker.Color         := rLockedRender.dMarker.Color ;
     end ;
    if params_marker.OutlineColor.ARGB = TGIS_Color.RenderColor.ARGB then begin
       alter_marker ;
       if use_renderer then
         params_marker.OutlineColor   := render_color
       else
         params_marker.OutlineColor   := rLockedRender.dMarker.OutlineColor
     end ;
    if params_marker.OutlineWidth      = GIS_RENDER_SIZE  then begin
       alter_marker ;
       if use_renderer then
         params_marker.OutlineWidth   := render_size
       else
         params_marker.OutlineWidth   := rLockedRender.dMarker.OutlineWidth ;
     end ;
    if params_marker.OffsetX           = GIS_RENDER_SIZE  then begin
       alter_marker ;
       if use_renderer then
         params_marker.OffsetX        := render_size
       else
         params_marker.OffsetX        := rLockedRender.dMarker.OffsetX ;
     end ;
    if params_marker.OffsetY           = GIS_RENDER_SIZE  then begin
       alter_marker ;
       if use_renderer then
         params_marker.OffsetY        := render_size
       else
         params_marker.OffsetY        := rLockedRender.dMarker.OffsetY ;
     end ;
    if params_label.Color.ARGB         = TGIS_Color.RenderColor.ARGB then begin
       alter_label ;
       if use_renderer then
         params_label.Color           := render_color
       else
         params_label.Color           := rLockedRender.dLabel.Color ;
     end ;
    if params_label.OutlineColor.ARGB  = TGIS_Color.RenderColor.ARGB then begin
       alter_label ;
       if use_renderer then
         params_label.OutlineColor    := render_color
       else
         params_label.OutlineColor    := rLockedRender.dLabel.OutlineColor ;
     end ;
    if params_label.OutlineWidth       = GIS_RENDER_SIZE  then begin
       alter_label ;
       if use_renderer then
         params_label.OutlineWidth    := render_size
       else
         params_label.OutlineWidth    := rLockedRender.dLabel.OutlineWidth ;
     end ;
    if params_label.FontSize           = GIS_RENDER_SIZE  then begin
       alter_label ;
       if use_renderer then
         params_label.FontSize        := render_size
       else
         params_label.FontSize        := rLockedRender.dLabel.FontSize ;
     end ;
    if params_label.FontColor.ARGB     = TGIS_Color.RenderColor.ARGB then begin
       alter_label ;
       if use_renderer then
         params_label.FontColor       := render_color
       else
         params_label.FontColor       := rLockedRender.dLabel.FontColor ;
     end ;
    if params_label.OffsetX            = GIS_RENDER_SIZE  then begin
       alter_label ;
       if use_renderer then
         params_label.OffsetX         := render_size
       else
         params_label.OffsetX         := rLockedRender.dLabel.OffsetX ;
     end ;
    if params_label.OffsetY            = GIS_RENDER_SIZE  then begin
       alter_label ;
       if use_renderer then
         params_label.OffsetY         := render_size
       else
         params_label.OffsetY         := rLockedRender.dLabel.OffsetY ;
     end ;
    if params_chart.Size               = GIS_RENDER_SIZE  then begin
       alter_chart ;
       if use_renderer then
         params_chart.Size            := render_size
       else
         params_chart.Size            := rLockedRender.dChart.Size ;
     end ;

    Result := True ;
  finally
    if not Result then
      UnlockRenderInternal ;
  end;
end;

function TGIS_LayerVector.prepareRender(
  const _shape        : TGIS_Shape  ;
  const _value        : Double      ;
  const _cursor       : Integer ;
  const _paramsVector : TGIS_ParamsSectionVector ;
  var   _renderColor  : TGIS_Color ;
  var   _renderSize   : Integer
) : Boolean ;
var
  render_factor                   : Double  ;
  prm_min_val, prm_max_val        : Double  ;
  prm_min_val_ex, prm_max_val_ex  : Double ;
  min_val, max_val                : Double ;
  min_gap, max_gap                : Double ;
  delta                           : Double ;
  curr_zones                      : Integer ;
  use_band_ex, band_ex_first      : Boolean ;
  is_band_ex, is_band_std, is_gap : Boolean ;
  params_render                   : TGIS_ParamsRender  ;

  function greater_then( const a, b, eps : Double ) : Boolean ; inline ;
  begin
    Result := ( a > b + eps ) ;
  end;

  function greater_equal( const a, b, eps : Double ) : Boolean ; inline ;
  begin
    Result := ( a >= b - eps ) ;
  end;

  function less_then( const a, b, eps : Double ) : Boolean ; inline ;
  begin
    Result := ( a < b + eps ) ;
  end;

  function make_color( const _val : Double; const _bandEx : Boolean ) : TGIS_Color ;
  var
    start_color        : TGIS_Color ;
    end_color          : TGIS_Color ;
    interpolation_base : Double ;
  begin
    if max_val <> min_val then begin
      if assigned( params_render.ColorRamp ) then begin
        Result := ColorFromColorRamp(
          params_render.ColorRamp,
          min_val,
          max_val,
          _val,
          lastColorRampZone
        ) ;
      end
      else begin
        interpolation_base := params_render.InterpolationBase;
        if _bandEx then begin
          start_color := params_render.StartColorEx ;
          end_color := params_render.EndColorEx ;
          if params_render.ZonesEx < 0 then
            interpolation_base := GIS_INTERPOLATE_BASE_LOG ;
        end
        else begin
          start_color := params_render.StartColor ;
          end_color := params_render.EndColor ;
          if params_render.Zones < 0 then
            interpolation_base := GIS_INTERPOLATE_BASE_LOG ;
        end ;

        Result := GradientColor(
          start_color,
          end_color,
          min_val,
          max_val,
          _val,
          params_render.ColorInterpolationMode,
          interpolation_base
        ) ;
      end;
    end
    else
      Result := params_render.ColorDefault ;
  end ;

  function make_size( const _val : Double; const _bandEx : Boolean ) : Integer ;
  var
    start_size         : Integer ;
    end_size           : Integer ;
    result_to_twips    : Boolean;
    interpolation_base : Double ;
  begin
    if max_val <> min_val then begin
      interpolation_base := params_render.InterpolationBase;
      if _bandEx then begin
        start_size :=  params_render.StartSizeEx ;
        end_size := params_render.EndSizeEx ;
        if params_render.ZonesEx < 0 then
          interpolation_base := GIS_INTERPOLATE_BASE_LOG ;
      end
      else begin
        start_size :=  params_render.StartSize ;
        end_size := params_render.EndSize ;
        if params_render.Zones < 0 then
          interpolation_base := GIS_INTERPOLATE_BASE_LOG ;
      end;

      result_to_twips := False ;
      if ( ( Abs(start_size) >= GIS_AUTOSIZE_SIZE ) or
           ( Abs(end_size) >= GIS_AUTOSIZE_SIZE ) or
           ( (start_size > 0) and (end_size < 0) ) or
           ( (start_size < 0) and (end_size > 0) ) ) and
         assigned(Viewer) then begin
        // unify size units are have a different kind
        // (units with opposite signs, map and screen units)
        result_to_twips := True;
        start_size := Viewer.Ref.TwipsToPixels(start_size);
        end_size := Viewer.Ref.TwipsToPixels(end_size);
      end;

      Result := RoundS( InterpolateValue(
        min_val, max_val,
        start_size, end_size,
        _val,
        interpolation_base
      ) ) ;

      if result_to_twips then
        Result := Viewer.Ref.PixelsToTwips(Result);
    end
    else
      Result := params_render.SizeDefault ;
  end ;

  //? refactor in future
  procedure process_band(
    const _zonesCount : Integer ;
    const _useBandEx  : Boolean ;
    const _minVal     : Double ;
    const _maxVal     : Double
  ) ;
  begin
    curr_zones := Abs( _zonesCount ) ;
    use_band_ex := _useBandEx ;
    if curr_zones < 0 then begin
      min_val := GIS_MAX_DOUBLE ;
      max_val := GIS_MAX_DOUBLE ;
    end
    else begin
      min_val := _minVal ;
      max_val := _maxVal ;
    end ;
  end;

begin
  Result := False ;  // use_renderer
  // previous order of thr standard & extended bands (deprecated)
  band_ex_first := True ;

  params_render := _paramsVector.Render ;
  // default render values
  _renderSize  := params_render.SizeDefault ;
  _renderColor := params_render.ColorDefault ;

  if IsStringEmpty( params_render.Expression ) then begin
    Result := True ;
    exit ;
  end ;

  delta := GIS_DOUBLE_RESOLUTION ;
  is_band_std := params_render.Zones <> 0 ;
  if is_band_std then begin
    if params_render.MinVal < params_render.MaxVal then begin
      prm_min_val := params_render.MinVal ;
      prm_max_val := params_render.MaxVal ;
      delta := Max( delta, ( prm_max_val - prm_min_val ) * GIS_DOUBLE_RESOLUTION ) ;
    end
    else begin
      Result := True ;
      exit ;
    end ;
  end ;

  is_band_ex := params_render.ZonesEx <> 0;
  if is_band_ex then begin
    if params_render.MinValEx < params_render.MaxValEx then begin
      prm_min_val_ex := params_render.MinValEx ;
      prm_max_val_ex := params_render.MaxValEx ;
      delta := Max( delta, ( prm_max_val_ex - prm_min_val_ex ) * GIS_DOUBLE_RESOLUTION ) ;
    end
    else begin
      Result := True ;
      exit ;
    end;

    if is_band_std then begin
      // new (more intuitive) solution
      if ( prm_min_val < prm_min_val_ex ) or
         ( prm_max_val < prm_max_val_ex ) then
        band_ex_first := False ;
    end;
  end ;

  if ( not is_band_std ) and ( not is_band_ex ) then begin
    Result := True ;
    exit ;
  end ;

  try
    // calculate min/max val for zone snapping
    // if rndfactor is out of scope
    min_val := GIS_MAX_DOUBLE ;
    max_val := -GIS_MAX_DOUBLE ;

    if is_band_std then begin
      min_val := Min( min_val, prm_min_val ) ;
      max_val := Max( max_val, prm_max_val ) ;
    end;

    if is_band_ex then begin
      min_val := Min( min_val, prm_min_val_ex ) ;
      max_val := Max( max_val, prm_max_val_ex ) ;
    end ;

    // the gap is only considered when both bands exist
    is_gap := False ;
    if is_band_std and is_band_ex then begin
      min_gap := GIS_MAX_DOUBLE ;
      max_gap := -GIS_MAX_DOUBLE ;

      if band_ex_first and not GisIsSameValue( prm_min_val, prm_max_val_ex, delta ) then
      begin
        is_gap := True ;
        min_gap := prm_max_val_ex ;
        max_gap := prm_min_val ;
      end
      else if not band_ex_first and not GisIsSameValue( prm_max_val, prm_min_val_ex, delta ) then
      begin
        is_gap := True ;
        min_gap := prm_max_val ;
        max_gap := prm_min_val_ex ;
      end ;
    end ;

    // parse an expression
    if assigned( _shape ) then begin
      // default value is minval - 1e7 to be significantly less then
      // minval to avoid rounding errors
      self.BindSqlQueryInternal( params_render.ExpressionObj ) ;
      render_factor := params_render.ExpressionObj.ParseAsFloat(
        _shape,
        min_val - 1e7,
        _cursor
      ) ;
      if render_factor < min_val then begin
        Result := True ;
        exit ;
      end;
    end
    else begin
      render_factor := _value ;
    end ;

    // check for a possible gap between bands
    if is_gap then begin
      if greater_then( render_factor, min_gap, delta ) and
         less_then( render_factor, max_gap, -delta ) then
      begin
        Result := True ;
        exit ;
      end ;
    end ;

    if greater_equal( render_factor, min_val, delta ) and
       less_then( render_factor, max_val, delta ) then
    begin
      // calculate zones values (especially for logarithmic scale)
      // be certain that logarithmic scale for Ex ban has an opposite
      // direction so it is thick near the max value
      if is_band_ex then begin
        // mode: extended band first in Params.Renderer (old, deprecated)
        if band_ex_first then begin
          // standard band
          if greater_equal( render_factor, prm_min_val, delta ) and
             less_then( render_factor, prm_max_val, delta ) then
          begin
            process_band( params_render.Zones, False, prm_min_val, prm_max_val ) ;
          end
          // extended band
          else begin
            process_band( params_render.ZonesEx, True, prm_min_val_ex, prm_max_val_ex ) ;
          end ;
        end
        // mode: standard band first in Params.Renderer (new, intuitive)
        else begin
          // extended band
          if greater_equal( render_factor, prm_min_val_ex, delta ) and
            less_then(render_factor, prm_max_val_ex, delta ) then
          begin
            process_band( params_render.ZonesEx, True, prm_min_val_ex, prm_max_val_ex ) ;
          end
          // standard band
          else begin
            process_band( params_render.Zones, False, prm_min_val, prm_max_val ) ;
          end ;
        end;
      end
      else begin
        process_band( params_render.Zones, False, prm_min_val, prm_max_val ) ;
      end;

      // calculate the render color and size
      if curr_zones > 0 then begin
        _renderColor := make_color( render_factor, use_band_ex ) ;
        _renderSize  := make_size ( render_factor, use_band_ex ) ;
      end ;
    end ;

    Result := True ; // proper rendering values assigned
  except
    // silent, render default value
  end ;
end ;

procedure TGIS_LayerVector.unlockRender ;
begin
  if rLockedRender.bLine   then Params.Line.Assign  ( rLockedRender.pLine   ) ;
  if rLockedRender.bArea   then Params.Area.Assign  ( rLockedRender.pArea   ) ;
  if rLockedRender.bMarker then Params.Marker.Assign( rLockedRender.pMarker ) ;
  if rLockedRender.bLabel  then Params.Labels.Assign( rLockedRender.pLabel  ) ;
  if rLockedRender.bChart  then Params.Chart.Assign ( rLockedRender.pChart  ) ;

  TGIS_ParamsSection( Params ).Serial := rLockedRender.oldSerial ;

  UnlockRenderInternal ;
end ;

function TGIS_LayerVector.legendRender(
  const _sectionIdx : Integer ;
  const _value      : Double ;
  const _params     : TGIS_ParamsSectionVector
) : Boolean ;
var
  render_color  : TGIS_Color ;
  render_size   : Integer ;
  params_line   : TGIS_ParamsLine ;
  params_area   : TGIS_ParamsArea ;
  params_marker : TGIS_ParamsMarker ;
  params_label  : TGIS_ParamsLabel ;
  params_chart  : TGIS_ParamsChart ;
begin
  Result := False ;

  _params.Assign( ParamsList.Items[_sectionIdx] ) ;
  if Params.InternalIndex = _sectionIdx then begin
    if rLockedRender.bLine   then _params.Line.Assign  ( rLockedRender.pLine   ) ;
    if rLockedRender.bArea   then _params.Area.Assign  ( rLockedRender.pArea   ) ;
    if rLockedRender.bMarker then _params.Marker.Assign( rLockedRender.pMarker ) ;
    if rLockedRender.bLabel  then _params.Labels.Assign( rLockedRender.pLabel  ) ;
    if rLockedRender.bChart  then _params.Chart.Assign ( rLockedRender.pChart  ) ;
  end ;

  prepareRender( nil, _value, 0, _params, render_color, render_size ) ;

  params_line   := _params.Line   ;
  params_area   := _params.Area   ;
  params_marker := _params.Marker ;
  params_label  := _params.Labels ;
  params_chart  := _params.Chart  ;

  // apply render values
  if params_line.Width               =  GIS_RENDER_SIZE  then
     params_line.Width               := render_size ;
  if params_line.Color.ARGB          =  TGIS_Color.RenderColor.ARGB then
     params_line.Color               := render_color ;
  if params_line.OutlineWidth        =  GIS_RENDER_SIZE  then
     params_line.OutlineWidth        := render_size ;
  if params_line.OutlineColor.ARGB   =  TGIS_Color.RenderColor.ARGB then
     params_line.OutlineColor        := render_color ;
  if params_line.OffsetX             =  GIS_RENDER_SIZE  then
     params_line.OffsetX             := render_size ;
  if params_line.OffsetY             =  GIS_RENDER_SIZE  then
     params_line.OffsetY             := render_size ;
  if params_area.Color.ARGB          =  TGIS_Color.RenderColor.ARGB then
     params_area.Color               := render_color ;
  if params_area.OutlineColor.ARGB   =  TGIS_Color.RenderColor.ARGB then
     params_area.OutlineColor        := render_color ;
  if params_area.OutlineWidth        =  GIS_RENDER_SIZE  then
     params_area.OutlineWidth        := render_size ;
  if params_area.OffsetX             =  GIS_RENDER_SIZE  then
     params_area.OffsetX             := render_size ;
  if params_area.OffsetY             =  GIS_RENDER_SIZE  then
     params_area.OffsetY             := render_size ;
  if params_marker.Size              =  GIS_RENDER_SIZE  then
     params_marker.Size              := render_size ;
  if params_marker.Color.ARGB        =  TGIS_Color.RenderColor.ARGB then
     params_marker.Color             := render_color ;
  if params_marker.OutlineColor.ARGB =  TGIS_Color.RenderColor.ARGB then
     params_marker.OutlineColor      := render_color ;
  if params_marker.OutlineWidth      =  GIS_RENDER_SIZE  then
     params_marker.OutlineWidth      := render_size ;
  if params_marker.OffsetX           =  GIS_RENDER_SIZE  then
     params_marker.OffsetX           := render_size ;
  if params_marker.OffsetY           =  GIS_RENDER_SIZE  then
     params_marker.OffsetY           := render_size ;
  if params_label.Color.ARGB         =  TGIS_Color.RenderColor.ARGB then
     params_label.Color              := render_color ;
  if params_label.OutlineColor.ARGB  =  TGIS_Color.RenderColor.ARGB then
     params_label.OutlineColor       := render_color ;
  if params_label.OutlineWidth       =  GIS_RENDER_SIZE  then
     params_label.OutlineWidth       := render_size ;
  if params_label.FontSize           =  GIS_RENDER_SIZE  then
     params_label.FontSize           := render_size ;
  if params_label.FontColor.ARGB     =  TGIS_Color.RenderColor.ARGB then
     params_label.FontColor          := render_color ;
  if params_label.OffsetX            =  GIS_RENDER_SIZE  then
     params_label.OffsetX            := render_size ;
  if params_label.OffsetY            =  GIS_RENDER_SIZE  then
     params_label.OffsetY            := render_size ;
  if params_chart.Size               =  GIS_RENDER_SIZE  then
     params_chart.Size               := render_size ;

  Result := True ;
end ;

function TGIS_LayerVector.checkParamsCache(
  const _shp    : TGIS_Shape ;
  const _cursor : Integer
) : Boolean ;
var
  i         : Integer       ;
  sql_query : TGIS_SqlQuery ;
  cnt       : Integer       ;
begin
  Result := False ;

  cnt := paramsCache.Count ;
  if cnt = 0 then begin
    Result := True ;
    exit ;
  end;


  if FMultipassRendering then begin
    for i := 0 to cnt - 1 do begin
      sql_query := TGIS_ParamsSectionVector(
                     paramsCache[i]
                   ).QueryObj ;

      if not TGIS_ParamsSectionVector(
        paramsCache[i]
      ).Visible then continue ;

      if assigned( sql_query ) and
         not IsStringEmpty( sql_query.Query ) then
      begin
        if not sql_query.ParseAsBoolean( _shp,
                                         False,
                                         _cursor
                                       )
        then
          continue ;
      end;

      ParamsList.Selected := TGIS_ParamsSectionVector(
                               paramsCache[i]
                             ).InternalIndex ;

      if Params.Visible then begin
        Result := True ;
        break ;
      end;
    end ;
  end
  else begin
    for i:= cnt -1 downto 0 do begin
      sql_query := TGIS_ParamsSectionVector(
                     paramsCache[i]
                   ).QueryObj ;
      if assigned( sql_query ) and
         not IsStringEmpty( sql_query.Query ) then
      begin
        if not sql_query.ParseAsBoolean(
                 _shp,
                 False,
                 _cursor
               )
        then
          continue ;
        optimizeParamsCache( i, True  ) ;
      end
      else begin
        optimizeParamsCache( i, False ) ;
      end ;

      Result := Params.Visible ;
      break ;
    end ;
  end;

end;

procedure TGIS_LayerVector.queueFlash(
  const _uid : TGIS_Uid
) ;
var
  i : Integer ;
begin
  i := length( oFlashQueue ) ;
  SetLength( oFlashQueue, i + 1 ) ;

  oFlashQueue[i] := _uid ;
end ;

procedure TGIS_LayerVector.releaseFlash(
  const _uid : TGIS_Uid
) ;
var
  i, j : Integer ;
  len : Integer ;
begin
  if not assigned( oFlashQueue ) then exit ;
  len := length( oFlashQueue ) ;
  for i := 0 to len - 1 do
    if ( oFlashQueue[i] = _uid ) then begin
      if ( i + 1 < len ) then begin
        for j := i to len - 2 do
          oFlashQueue[j] := oFlashQueue[j+1] ;
      end ;
      SetLength( oFlashQueue, len - 1 ) ;
      break ;
    end ;
end ;

function TGIS_LayerVector.doCreateShape(
  const _shape : TGIS_Shape
) : TGIS_Shape ;
var
  bad : Boolean ;
begin
  bad := False ;

  Result := _shape ;


  if Result.FShapeType  = TGIS_ShapeType.Unknown then
    Result.FShapeType := DefaultShapeType ;
  if Result.FDimension = TGIS_DimensionType.Unknown then
    Result.FDimension := DefaultDimension ;

  // multipatch is always ZM
  if Result.ShapeType = TGIS_ShapeType.MultiPatch then
    Result.FDimension := TGIS_DimensionType.XYZM ;

  if not GisTestShapeType( Result.FShapeType, SupportedShapes ) then
    bad := True ;
  if not GisTestDimensionType( Result.FDimension, SupportedDimensions ) then
    bad := True ;

  if bad then begin
    FreeObject( Result ) ;
    exit ;
  end;

  Result.FLayer := self ;
  Result.FUid        := GetNewUid ;
  Result.FIsNewShape := True ;

  Result.FIsEditable := True ;
  Items.Add( Result ) ;
  Result.AddToIndex ;

  Result.layerModified( False ) ;
end ;

{$IFDEF CLR or ISLAND}
  function TGIS_LayerVector.doCreateShapeFromType(
    const _type : &Type
  ) : TGIS_Shape ;
  begin
    {$IFDEF CLR}
    Result := Activator.CreateInstance( _type, DefaultDimension ) as TGIS_Shape ;
    {$ENDIF}
    {$IFDEF ISLAND}
      Result := nil ; //??
    {$ENDIF}
  end;
{$ENDIF}

{$IFDEF JAVA}
  function TGIS_LayerVector.doCreateShapeFromType(
    const _type : &Class
  ) : TGIS_Shape ;
  var
    args : array of &Class ;
  begin
    args := new &Class[1] ;

    // bypassing Oxygene bug
    args[0] := typeOf( TGIS_DimensionType ) ;
    //args[0] := typeOf( Integer ) ;

    Result := _type.getDeclaredConstructor(args).newInstance(DefaultDimension)
               as TGIS_Shape ;
  end;
{$ENDIF}

procedure TGIS_LayerVector.applyShapeStyleField(
  const _shape : TGIS_Shape
) ;
var
  cfg : TGIS_ConfigShapeStyle ;
begin
  if not assigned( _shape ) then exit ;

  cfg := TGIS_ConfigShapeStyle.Create ;
  try
    cfg.Text := String( _shape.GetField( GIS_FIELD_STYLE ) );

    _shape.Params.LoadFromConfig( cfg );
  finally
    FreeObject( cfg ) ;
  end;
end ;

function TGIS_LayerVector.getAggregatedPos(
  const _uid         : TGIS_Uid       ;
  var   _ipos        : Integer
) : Boolean ;
var
  ilow  : Integer ;
  ihigh : Integer ;
  shp   : TGIS_Shape ;
begin
  _ipos := 0 ;
  ilow  := 0 ;
  ihigh := aggregatedItems.Count - 1 ;

  while ilow <= ihigh do begin
    _ipos  := ( ihigh + ilow ) div 2 ;
    shp := TGIS_Shape( aggregatedItems[ _ipos ] ) ;
    if      shp.Uid < _uid then begin
                                  ilow  := _ipos + 1 ;
                                  _ipos := ilow ; // for finding a best
                                                  // fit position
                                end
    else if shp.Uid > _uid then ihigh := _ipos - 1
    else begin
      Result := True ;
      shp := TGIS_Shape( aggregatedItems[_ipos] ) ;
      exit ;
    end ;
  end ;
  Result := False ;
end;

procedure TGIS_LayerVector.cursorNextAggregated(
  const _cursor : Integer
) ;
var
  cnt_items  : Integer ;
  cnt_prcssd : Integer ;
begin

  cnt_items  := Items.Count ;
  cnt_prcssd := aggregatedItems.Count ;

  with cursorState[_cursor] do begin
    curPos := cnt_items ;

    while True do begin

      curPos := cnt_items ;

      inc( curAggregatedPos ) ;
      if (cnt_prcssd > 0) and ( curAggregatedPos < cnt_prcssd ) then begin
        curShape := TGIS_Shape( aggregatedItems[ curAggregatedPos ] ) ;
        if curShape.FIsNewShape then
          break ;
      end
      else begin
        curAggregatedPos := cnt_prcssd ;
        curShape := nil ;
        break ;
      end ;
    end ;
  end ;
end ;

procedure TGIS_LayerVector.Build(
  const _path   : String ;
  const _extent : TGIS_Extent;
  const _type   : TGIS_ShapeType
) ;
begin
  Build( _path, _extent, _type, TGIS_DimensionType.Unknown ) ;
end ;

procedure TGIS_LayerVector.Build(
  const _path   : String ;
  const _extent : TGIS_Extent;
  const _type   : TGIS_ShapeType ;
  const _dim    : TGIS_DimensionType
) ;
begin
  Extent           := _extent ;
  Path             := _path ;
  DefaultDimension := _dim ;
end ;

procedure TGIS_LayerVector.InitializeDirectWrite(
  const _path        : String           ;
  const _extent      : TGIS_Extent      ;
  const _type        : TGIS_ShapeType   ;
  const _dim         : TGIS_DimensionType
) ;
begin
  Extent           := _extent ;
  Path             := _path ;
  DefaultDimension := _dim ;
  DefaultShapeType := _type ;
end ;

procedure TGIS_LayerVector.FinalizeDirectWrite ;
begin
  //
end ;

procedure TGIS_LayerVector.FinalizeRead ;
begin
  //
end ;

procedure TGIS_LayerVector.ImportStructure(
  const _layer : TGIS_LayerVector
) ;
var
  i         : Integer ;
  fld       : TGIS_FieldInfo ;
  fname     : String ;
  borig_uid : Boolean ;
begin
  borig_uid := GisMetadataAsBoolean( METADATA_WRITEORIGINALUID, False ) ;

  for i:=0 to _layer.Fields.Count - 1 do begin
    fld := _layer.FieldInfo( i ) ;

    if fld.FileFormat and not fld.IsUID then continue ;
    if fld.Temporary  then continue ;

    if fld.Deleted then begin
      fld := FieldInfo( FindField( fld.NewName )  ) ;
      if assigned( fld ) then
        fld.Deleted := True ;
      continue
    end ;

    if fld.IsUID and borig_uid then
      fname := GIS_SQL_ORIGINAL_UID_NAME
    else
      fname := fld.NewName ;

    if FieldInfo( FindField( fname ) ) = nil then begin
      AddField( fname,
                fld.FieldType,
                fld.NewWidth,
                fld.NewDecimal
              ) ;
      if Fields.Count > 0 then begin
        with FieldInfo( Fields.Count -1 ) do begin
          IsUID := fld.IsUID ;
        end ;
      end ;
    end;
  end ;
  if UseShapeStyleField then begin
    if FieldInfo( FindField( GIS_FIELD_STYLE ) ) = nil then begin
      AddField( GIS_FIELD_STYLE,
                TGIS_FieldType.String,
                STYLE_FIELD_WIDTH,
                0
              ) ;
    end;

  end;
end ;

procedure TGIS_LayerVector.MergeStructure(
  const _layer    : TGIS_LayerVector ;
  const _restrict : Boolean
) ;
begin
  MergeStructure( _layer, _restrict, False ) ;
end ;

procedure TGIS_LayerVector.MergeStructure(
  const _layer         : TGIS_LayerVector ;
  const _restrict      : Boolean          ;
  const _useExportName : Boolean
) ;
var
  i, k  : Integer ;
  fld   : TGIS_FieldInfo ;
  fname : String ;
begin
  for i := 0 to _layer.Fields.Count - 1 do begin
    fld   := _layer.FieldInfo( i ) ;
    if _useExportName then
      fname := fld.ExportName
    else
      fname := fld.NewName ;

    k := FindField( fname ) ;

    if not (TGIS_FieldFlags.Exportable in fld.Flags) then continue ;

    if FieldInfo( k ) = nil then
      AddField( fname, fld.FieldType, fld.NewWidth, fld.NewDecimal )
    else begin
      if FieldInfo( k ).NewWidth <> fld.NewWidth then
      begin
        if not _restrict then
          FieldInfo( k ).NewWidth := Max( FieldInfo( k ).NewWidth,
                                          fld.NewWidth
                                         )
        else raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_WRONGFIELD ), '', 0 );
      end;

      if not _restrict then begin
        // SQL layers changes boolean fields into string
        if ( fld.FieldType = TGIS_FieldType.Boolean ) and
           (( FieldInfo( k ).FieldType <> TGIS_FieldType.Boolean ) and
            ( FieldInfo( k ).FieldType <> TGIS_FieldType.String  )) then
          raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_WRONGFIELD ), '', 0 );
      end
      else begin
        if FieldInfo( k ).FieldType <> fld.FieldType then
          raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_WRONGFIELD ), '', 0 );
      end;
    end;

    if fld.Deleted then begin
      fld := FieldInfo( k  ) ;
      fld.Deleted := True ;
    end ;
  end ;

end ;

procedure TGIS_LayerVector.ExportStructureToFLD ;
var
  ini   : TGIS_IniFile ;
  i     : Integer ;
  isfld : Boolean ;
  sprev : String ;
  lst   : TStringList ;
begin
  if IsEmbeddedSQLPath( PathFLD ) or IsStringEmpty(Path) then exit ;
  isfld := False ;

  ini := TGIS_IniFile.Create( PathFLD ) ;
  lst := TStringList.Create ;
  try
    ini.GetStrings( lst ) ;
    lst.Sort ;
    sprev := lst.Text ;
  finally
    FreeObject( lst ) ;
    FreeObject( ini ) ;
  end;

  ini := TGIS_IniFile.Create( GetTemporaryName( PathFLD ) ) ;
  try
    for i := 0 to Fields.Count - 1 do begin
      with FieldInfo(i) do begin
        if ExportName <> NewName then begin
          ini.WriteString( GIS_INI_FIELDS_HEADER, ExportName, NewName ) ;
          isfld := True ;
        end ;
      end ;
    end ;

    if isfld then begin
      lst := TStringList.Create ;
      try
        ini.GetStrings( lst ) ;
        isfld := lst.Text <> sprev ;
      finally
        FreeObject( lst ) ;
      end;
    end;


    // save file if required
    if isfld then begin
      ini.UpdateFile ;

      {$IFDEF DCC}System.SysUtils.{$ENDIF}DeleteFile( GetBackupName( PathFLD ) ) ;
      {$IFDEF DCC}System.SysUtils.{$ENDIF}RenameFile( PathFLD, GetBackupName( PathFLD ) ) ;
      try
        if not RenameFile( GetTemporaryName( PathFLD ), PathFLD ) then
          raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FILEWRITE ), PathFLD,
                                       GetLastError
                                     ) ;
      except
        RenameFile( GetBackupName( PathFLD ), PathFLD ) ;
      end ;
    end ;
  finally
    FreeObject( ini ) ;
  end ;
end ;

procedure TGIS_LayerVector.ReadFieldRules ;
begin
  if not IsServerPath( Path ) and SafeFileExists( PathFLDX ) then
    TGIS_FieldRulesOperations.ParseFldx( PathFLDX, self ) ;
end ;

procedure TGIS_LayerVector.SaveFieldRules ;
begin
  TGIS_FieldRulesOperations.SaveFldx( PathFLDX, self ) ;
end ;

procedure TGIS_LayerVector.ReadFieldDefinition ;
var
  i     : Integer      ;
  ini   : TGIS_IniFile ;
  sname : String       ;
begin
  if not IsEmbeddedSQLPath( Path ) and SafeFileExists( PathFLD ) then begin
    // read long field names
    ini := TGIS_IniFile.Create( PathFLD ) ;
    try
      for i := 0 to Fields.Count-1 do begin
        with FieldInfo( i ) do begin
          sname := ini.ReadString( GIS_INI_FIELDS_HEADER, Name, NewName ) ;
          if sname <> NewName then begin
            NewName := sname ;
            helperFindField.Clear ;
          end ;
        end ;
      end ;
    finally
      FreeObject( ini ) ;
    end ;
  end ;
end ;

procedure TGIS_LayerVector.ImportLayer(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _truncated : Boolean
) ;
begin
  ImportLayerEx( _layer, _extent, _type, _scope, nil, '', _truncated ) ;
end;

procedure TGIS_LayerVector.ImportLayer(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _shape     : TGIS_Shape       ;
  const _de9im     : String           ;
  const _truncated : Boolean
) ;
begin
  ImportLayerEx( _layer, _extent, _type, _scope, _shape, _de9im, _truncated ) ;
end;

procedure TGIS_LayerVector.ImportLayerEx(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _shape     : TGIS_Shape       ;
  const _de9im     : String           ;
  const _truncated : Boolean
) ;
var
  shp        : TGIS_Shape  ;
  shp_tmp    : TGIS_Shape  ;
  ex         : TGIS_Extent ;
  shape_no   : Cardinal    ;
  end_uid    : TGIS_Uid       ;
  abrt       : Boolean     ;
  old_scope  : String      ;
  lp         : TGIS_LayerVectorEnumerator ;
begin
  if not assigned( _layer ) then exit ;

  shape_no := 0 ;
  end_uid  := _layer.GetLastUid ;
  abrt     := False ;

  RevertAll ;

  ImportStructure( _layer ) ;

  ex := GisCommonExtent( _layer.Extent, _extent ) ;

  RaiseBusyPrepare( _layer, Format( _rsrc( GIS_RS_BUSY_SAVE ), [Name] ) ) ;
  abrt := RaiseBusyEvent( self, -1, -1 ) ;

  try
    old_scope := _layer.Scope ;
    _layer.Scope := '' ;
    try
      lp := _layer.Loop( ex, _scope, _shape, _de9im ).GetEnumerator() ;
      try
        while lp.MoveNext do begin // iterate all shapes
          shp := lp.GetCurrent ;
          shp_tmp := shp.PrepareExportShape(
                           nil, _extent, _truncated, True
                         ) ;
          try
            if assigned( shp_tmp ) and
               ( not shp_tmp.IsDeleted ) and
               ( ( _type = shp_tmp.ShapeType   ) or
                 ( _type = TGIS_ShapeType.Unknown )
               ) then
            begin
              self.AddShape( shp_tmp, True ) ;
            end ;
          finally
            if shp <> shp_tmp then FreeObject( shp_tmp ) ;
          end ;

          if shape_no mod 100 = 1 then begin
            abrt := RaiseBusyEvent( self, shp.Uid, end_uid ) ;
            if abrt then break ;
          end ;
          inc( shape_no ) ;
        end ;
      finally
        FreeObject( lp ) ;
      end;
    finally
      _layer.Scope := old_scope ;
    end ;
  finally
    abrt := RaiseBusyEvent( self, -1, -1 ) ;
    RaiseBusyRelease( _layer ) ;
  end ;
end ;

procedure TGIS_LayerVector.MergeLayer(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _truncated : Boolean          ;
  const _restrict  : Boolean
) ;
begin
  MergeLayerEx(_layer, _extent, _type, _scope, nil, '', _truncated, _restrict ) ;
end;

procedure TGIS_LayerVector.MergeLayer(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _shape     : TGIS_Shape       ;
  const _de9im     : String           ;
  const _truncated : Boolean          ;
  const _restrict  : Boolean
) ;
begin
  MergeLayerEx(_layer, _extent, _type, _scope, _shape, _de9im, _truncated, _restrict ) ;
end;

procedure TGIS_LayerVector.MergeLayerEx(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _shape     : TGIS_Shape       ;
  const _de9im     : String           ;
  const _truncated : Boolean          ;
  const _restrict  : Boolean
) ;
var
  shp        : TGIS_Shape  ;
  shp_tmp    : TGIS_Shape  ;
  ex         : TGIS_Extent ;
  shape_no   : Cardinal    ;
  end_uid    : TGIS_Uid     ;
  abrt       : Boolean     ;
  old_scope  : String      ;
  lp         : TGIS_LayerVectorEnumerator ;
begin
  if not assigned( _layer ) then exit ;

  SaveData ;  // save current data before the merge

  shape_no := 0 ;
  end_uid  := _layer.GetLastUid ;
  abrt     := False ;

  MergeStructure( _layer, _restrict ) ;

  ex := GisCommonExtent( _layer.Extent, _extent ) ;

  RaiseBusyPrepare( _layer, Format( _rsrc( GIS_RS_BUSY_SAVE ), [Name] ) ) ;
  abrt := RaiseBusyEvent( self, -1, -1 ) ;
  try
    old_scope := _layer.Scope ;
    _layer.Scope := '' ;

    try
      lp := _layer.Loop( ex, _scope, _shape, _de9im ).GetEnumerator() ;
      try
        while lp.MoveNext do begin // iterate all shapes
          shp := lp.GetCurrent ;
          shp_tmp := shp.PrepareExportShape(
                           nil, _extent, _truncated, True
                         ) ;
          try
            if assigned( shp_tmp ) and
               ( not shp_tmp.IsDeleted ) and
               ( ( _type = shp_tmp.ShapeType   ) or
                 ( _type = TGIS_ShapeType.Unknown )
               ) then
            begin
              self.AddShape( shp_tmp, True ) ;
            end ;
          finally
            if shp <> shp_tmp then FreeObject( shp_tmp ) ;
          end ;

          if shape_no mod 100 = 1 then begin
            abrt := RaiseBusyEvent( self, shp.Uid, end_uid ) ;
            if abrt then break ;
          end ;
          inc( shape_no ) ;
        end ;
      finally
        FreeObject( lp ) ;
      end;
    finally
      _layer.Scope := old_scope ;
    end ;
  finally
    abrt := RaiseBusyEvent( self, -1, -1 ) ;
    _layer.RaiseBusyRelease( _layer ) ;
  end ;
end ;

procedure TGIS_LayerVector.ExportLayer(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _truncated : Boolean
) ;
begin
  _layer.ImportLayerEx( self, _extent, _type, _scope, nil, '', _truncated ) ;
end;

procedure TGIS_LayerVector.ExportLayer(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _shape     : TGIS_Shape       ;
  const _de9im     : String           ;
  const _truncated : Boolean
) ;
begin
  _layer.ImportLayerEx( self, _extent, _type, _scope, _shape, _de9im, _truncated ) ;
end;

procedure TGIS_LayerVector.ExportLayerEx(
  const _layer     : TGIS_LayerVector ;
  const _extent    : TGIS_Extent      ;
  const _type      : TGIS_ShapeType   ;
  const _scope     : String           ;
  const _shape     : TGIS_Shape       ;
  const _de9im     : String           ;
  const _truncated : Boolean
) ;
begin
  _layer.ImportLayerEx( self, _extent, _type, _scope, _shape, _de9im, _truncated ) ;
end;

function TGIS_LayerVector.AddShape(
  const _shape     : TGIS_Shape
) : TGIS_Shape ;
begin
  Result := AddShape( _shape, False ) ;
end ;

function TGIS_LayerVector.AddShape(
  const _shape     : TGIS_Shape ;
  const _copyfield : Boolean
) : TGIS_Shape ;
var
  ll   : TGIS_LayerVector ;
begin
  Result := nil ;
  if not assigned( _shape ) then exit ;

  if assigned( _shape.Layer )               and
     ( _shape.Layer.CS.CanConvert( CS )     or
       ( assigned( _shape.Layer.Transform ) and
         _shape.Layer.Transform.Active
       )
     )
  then
    Result := _shape.CreateCopyCS( CS )
  else
    Result := _shape.CreateCopy ;

  Result.Layer       := self              ;
  Result.FUid        := GetNewUid         ;
  Result.FIsNewShape := True ;

  Result.FIsEditable := True ;
  Items.Add( Result ) ;
  Result.AddToIndex ;
  Result.layerModified( False ) ;

  if not Result.IsEmpty then
    if not GisIsSameExtent( Result.Extent, Extent ) then
      Extent := GisMaxExtent( Result.Extent, Extent ) ;

  // if _shape layer is different than this, clear fields
  ll := _shape.Layer ;
  if assigned( ll ) and ( ll <> Self ) then
    FreeObject( Result.mappedFields ) ;

  if not _copyfield then exit ;

  // copy structure
  ll := _shape.Layer ;
  if not assigned( ll ) then exit ;
  ImportStructure( ll ) ;

  Result.CopyFields( _shape ) ;
end ;

procedure TGIS_LayerVector.WriteShapeDirect(
  const _shape     : TGIS_Shape
) ;
begin
  AddShape( _shape ) ;
end ;

function TGIS_LayerVector.CreateShape(
  const _type : TGIS_ShapeType
) : TGIS_Shape ;
begin
  Result := CreateShape( _type, TGIS_DimensionType.Unknown ) ;
end ;

function TGIS_LayerVector.CreateShape(
  const _type : TGIS_ShapeClass
) : TGIS_Shape ;
begin
  {$IFDEF DCC}
    Result := _type.Create( DefaultDimension ) ;
  {$ENDIF}
  {$IFDEF OXYGENE}
    Result := doCreateShapeFromType(_type.ActualType) ;
  {$ENDIF}
  Result := doCreateShape( Result ) ;
end;


function TGIS_LayerVector.CreateShape(
  const _type : TGIS_ShapeType ;
  const _dim  : TGIS_DimensionType
) : TGIS_Shape ;
var
  tmpshp  : TGIS_Shape          ;
  shptype : TGIS_ShapeType      ;
  dim     : TGIS_DimensionType  ;
begin
  Result := nil ;

  // if shape is unknown then any (first form allowed) shape
  // will be created
  if TGIS_ShapeType.Unknown         = _type then shptype := DefaultShapeType
                                            else shptype := _type ;

  if TGIS_DimensionType.Unknown = _dim  then dim := DefaultDimension
                                        else dim := _dim ;
  // multipatch is always ZM
    if _type = TGIS_ShapeType.MultiPatch then
      dim := TGIS_DimensionType.XYZM ;

  // is a correct shape given?
    if not GisTestShapeType( shptype, SupportedShapes ) then exit ;

    if not GisTestDimensionType( dim, SupportedDimensions ) then exit ;

  case shptype of
     TGIS_ShapeType.Point :
        tmpshp := TGIS_ShapePoint.Create( nil, nil, False, 0, self, dim ) ;
     TGIS_ShapeType.MultiPoint :
        tmpshp := TGIS_ShapeMultiPoint.Create( nil, nil, False, 0, self, dim ) ;
     TGIS_ShapeType.Arc :
        tmpshp := TGIS_ShapeArc.Create( nil, nil, False, 0, self, dim ) ;
     TGIS_ShapeType.Polygon :
        tmpshp := TGIS_ShapePolygon.Create( nil, nil, False, 0, self, dim ) ;
     TGIS_ShapeType.Complex :
        tmpshp := TGIS_ShapeComplex.Create( nil, nil, False, 0, self, dim ) ;
     TGIS_ShapeType.MultiPatch :
        tmpshp := TGIS_ShapeMultiPatch.Create( nil, nil, False, 0, self, dim ) ;
     else
        exit ; // no one meet our criteria
   end ;

  Result := doCreateShape( tmpshp ) ;
end ;

function TGIS_LayerVector.FindFirst
  : TGIS_Shape ;
begin
  Result := FindFirst( GisWholeWorld, '', nil, '', True ) ;
end ;

function TGIS_LayerVector.FindFirst(
  const _extent      : TGIS_Extent
) : TGIS_Shape ;
begin
  Result := FindFirst( _extent, '', nil, '', True ) ;
end ;

function TGIS_LayerVector.FindFirst(
  const _extent      : TGIS_Extent      ;
  const _query       : String
) : TGIS_Shape ;
begin
  Result := FindFirst( _extent, _query, nil, '', True ) ;
end;

function TGIS_LayerVector.FindFirst(
  const _extent      : TGIS_Extent      ;
  const _query       : String           ;
  const _shape       : TGIS_Shape       ;
  const _de9im       : String
) : TGIS_Shape ;
begin
  Result := FindFirst( _extent, _query, _shape, _de9im, True ) ;
end;

function TGIS_LayerVector.FindFirst(
  const _extent      : TGIS_Extent      ;
  const _query       : String           ;
  const _shape       : TGIS_Shape       ;
  const _de9im       : String           ;
  const _skipDeleted : Boolean
) : TGIS_Shape ;
begin

  Result := cursorFindFirst( 0, True,
                             _extent, _query, _shape, _de9im, _skipDeleted
                           ) ;
end ;

function TGIS_LayerVector.FindNext
  : TGIS_Shape ;
begin
  Result := cursorFindNext( 0 ) ;
end ;

function TGIS_LayerVector.&Loop
  : TGIS_LayerVectorEnumeratorFactory ;
begin
  Result := self.Loop( self.Extent, '', nil, '', True ) ;
end;

function TGIS_LayerVector.&Loop(
  const _extent      : TGIS_Extent
) : TGIS_LayerVectorEnumeratorFactory ;
begin
  Result := self.Loop( _extent, '', nil, '', True ) ;
end;

function TGIS_LayerVector.&Loop(
  const _extent      : TGIS_Extent      ;
  const _query       : String
) : TGIS_LayerVectorEnumeratorFactory ;
begin
  Result := self.Loop( _extent, _query, nil, '', True ) ;
end;

function TGIS_LayerVector.&Loop(
  const _extent      : TGIS_Extent ;
  const _query       : String      ;
  const _shape       : TGIS_Shape  ;
  const _de9im       : String
) : TGIS_LayerVectorEnumeratorFactory ;
begin
  Result := self.Loop( _extent, _query, _shape, _de9im, True ) ;
end;

function TGIS_LayerVector.&Loop(
  const _extent      : TGIS_Extent ;
  const _query       : String      ;
  const _shape       : TGIS_Shape  ;
  const _de9im       : String      ;
  const _skipDeleted : Boolean
) : TGIS_LayerVectorEnumeratorFactory ;
begin
  Result := TGIS_LayerVectorEnumeratorFactory.Create ;

  Result.SetUp( self, _extent, _query, _shape, _de9im, _skipDeleted );
end;

function TGIS_LayerVector.GetShape(
  const _uid : TGIS_Uid
) : TGIS_Shape ;
begin
  Result := GetShape( _uid, 1 ) ;
end ;

function TGIS_LayerVector.GetShape(
  const _uid    : TGIS_Uid ;
  const _cursor : Integer
) : TGIS_Shape ;
var
  ipos : Integer ;
begin
  with cursorState[ _cursor ] do begin
    if getShapePos( _uid, ipos )
      then curShape := TGIS_Shape( Items[ ipos ] )
      else curShape := nil ;

    if assigned( curShape ) and
       getAggregatedPos( curShape.Uid, ipos )
    then
      curShape := TGIS_Shape( aggregatedItems[ ipos ] ) ;

    rJoin.Reset := True ;
    Result := curShape ;
  end ;
end ;

function TGIS_LayerVector.GetSelectedCount
  : Integer ;
var
  i   : Integer ;
begin
  Result := 0 ;

  for i := 0 to Items.Count - 1 do
    if TGIS_Shape( Items[ i ] ).IsSelected then
      inc( Result ) ;
end ;

function TGIS_LayerVector.GetLastUid
  : TGIS_Uid ;
begin
  if Items.Count = 0 then Result := 0
                     else Result := TGIS_Shape(Items.Last).Uid ;
end ;

function TGIS_LayerVector.GetNewUid
  : TGIS_Uid ;
begin
  Result := GetLastUid + 1 ;
end ;

function TGIS_LayerVector.GetField(
  const _uid  : TGIS_Uid ;
  const _name : String
) : Variant ;
var
  shp : TGIS_Shape ;
begin
  Result := Unassigned ;

  shp := cursorShapeEx(0) ;
  if ( not assigned( shp ) ) or ( shp.Uid <> _uid ) then
    shp := GetShape( _uid ) ;

  if assigned( shp ) then
    Result := shp.GetField( _name ) ;
end ;

function TGIS_LayerVector.GetFieldEx(
  const _uid  : TGIS_Uid ;
  const _name : String
) : Variant ;
var
  shp : TGIS_Shape ;
begin
  Result := Unassigned ;

  shp := cursorShapeEx(0) ;
  if ( not assigned( shp ) ) or ( shp.Uid <> _uid ) then
    shp := GetShape( _uid ) ;

  if assigned( shp ) then
    Result := shp.GetFieldEx( _name ) ;
end ;

procedure TGIS_LayerVector.BindSqlQueryInternal(
  const _sqlquery : TGIS_SqlQuery
) ;
begin
  _sqlquery.BindSqlQueryCallBack(
     {$IFDEF OXYGENE}
       @bindField,
       @getBindedField,
       @getStatistics
     {$ELSE}
       bindField,
       getBindedField,
       getStatistics
     {$ENDIF}
  ) ;
end;

function TGIS_LayerVector.DrawEx(
  const _extent : TGIS_Extent
) : Boolean ;
var
  i            : Integer           ;
  dynext       : TGIS_Extent       ;
  shp          : TGIS_Shape        ;
  sql_query    : TGIS_SqlQuery     ;
  rndr         : Boolean           ;
  params_label : TGIS_ParamsLabel  ;
  cnt          : Integer           ;
  is_visible   : Boolean           ;
  render       : TGIS_ParamsRender ;
  {$IFDEF OXYGENE}
    e          : TGIS_ShapeEventArgs ;
  {$ENDIF}
  msg          : String ;

  prm          : Integer ;
  prm_query    : String ;
  tmp_query    : String ;
  edt          : IGIS_Editor ;
  edt_has_snap : Boolean ;

  // perform shape draw
  procedure do_draw( const _mode : TGIS_RendererMultipassMode ) ;
  begin
    if shp.IsHidden then
      exit ;

    chartHint := chartHint or
                 not IsStringEmpty( shp.Params.Chart.Values ) ;
    {$IFDEF OXYGENE}
      if assigned( FOnPaintShape )
         then begin
           e := TGIS_ShapeEventArgs.Create( shp ) ;
           try
             FOnPaintShape( self, e ) ;
           finally
             FreeObject( e ) ;
           end ;
         end
    {$ELSE}
      if assigned( PaintShapeEvent )
         then PaintShapeEvent( self, shp )
    {$ENDIF}
      else
        shp.Draw( _mode ) ;

      if ( Integer( _mode )
           and
           Integer( TGIS_RendererMultipassMode.Line )
         ) = 0
      then
        exit ;

      if chartHint then begin
        {$IFDEF OXYGENE}
          if assigned( FOnPaintShapeChart ) then begin
            e := TGIS_ShapeEventArgs.Create( shp ) ;
            try
              FOnPaintShapeChart( self, e ) ;
            finally
              FreeObject( e ) ;
            end ;
          end
        {$ELSE}
          if assigned( PaintShapeChartEvent )
            then PaintShapeChartEvent( self, shp )
        {$ENDIF}
           else shp.DrawChart ;
      end ;
      if labelHint then begin
        {$IFDEF OXYGENE}
          if assigned( FOnPaintShapeLabel ) then begin
            e := TGIS_ShapeEventArgs.Create( shp ) ;
            try
              FOnPaintShapeLabel( self, e ) ;
            finally
              FreeObject( e ) ;
            end ;
          end
        {$ELSE}
          if assigned( PaintShapeLabelEvent )
            then PaintShapeLabelEvent( self, shp )
        {$ENDIF}
           else shp.DrawLabel ;
      end ;
  end ;

  procedure read_metadata ;
  var
    stmp : String ;
  begin
    stmp := GisMetadataAsString( METADATA_ROTATESYMBOLS, '' ) ;
    if      stmp = 'NO'        then FSymbolingMode := 0
    else if stmp = 'BYFIELD'   then FSymbolingMode := 1
    else if stmp = 'WITHANGLE' then FSymbolingMode := 2
    else if stmp = 'ALL'       then FSymbolingMode := 3
    else                            FSymbolingMode := 1 ;

    stmp := GisMetadataAsString( METADATA_ROTATELABELS, '' ) ;

    if      stmp = 'NO'        then FLabelingMode := 0
    else if stmp = 'BYFIELD'   then FLabelingMode := 1
    else if stmp = 'WITHANGLE' then FLabelingMode := 2
    else if stmp = 'ALL'       then FLabelingMode := 3
    else                            FLabelingMode := 1 ;
  end ;
begin
  Result := inherited DrawEx( _extent ) ;
  if not Result then Exit ;

  if ( FSymbolingMode = -1 ) or (FLabelingMode = -1 ) then
    read_metadata;

  try
    if not assigned( Viewer ) then exit ;

    if Viewer.Ref.Zoom <= 0 then exit ;

    if assigned( FDynamicAggregator ) then begin
      FDynamicAggregator.clearContext ;
      if assigned( Viewer ) and
         ( not GisIsNoWorld( Viewer.Ref.TemporaryVisibleExtent ) )
      then
        dynext := Viewer.Ref.TemporaryVisibleExtent
      else
        dynext := _extent ;

      FDynamicAggregator.Prepare( dynext, cursorState[ 0 ].curDrawQuery  ) ;
      FDynamicAggregator.prepareContext ;
    end ;


    {$IFDEF OXYGENE}
      labelHint := assigned( FOnPaintShapeLabel ) ;
      chartHint := assigned( FOnPaintShapeChart ) ;
    {$ELSE}
      labelHint := assigned( PaintShapeLabelEvent ) ;
      chartHint := assigned( PaintShapeChartEvent ) ;
    {$ENDIF}

    if FPixelsPerInch <> TGIS_RendererAbstract( FRenderer ).PPI then begin
      FPixelsPerInch := TGIS_RendererAbstract( FRenderer ).PPI ;
    end ;

    prepareParamsCache( namedStyle ) ;
    cnt := paramsCache.Count ;

    if cnt <= 0 then exit ;

    is_visible := False ;
    for i:= cnt -1 downto 0 do begin
      is_visible := is_visible or
                    TGIS_ParamsSectionVector( paramsCache[i] ).Visible ;
      if is_visible then break ;
    end ;

    if not is_visible then exit ;

    edt := Viewer.Ref.Editor ;
    inDraw := True ;
    bIgnoreShapeParams := FIgnoreShapeParams ;

    try

      if FMultipassRendering then begin

        // line outlines only
        for prm := 0 to cnt - 1 do begin
          sql_query := TGIS_ParamsSectionVector(
                              paramsCache[prm]
                       ).QueryObj ;

          if not TGIS_ParamsSectionVector(
                              paramsCache[prm]
                       ).Visible then continue ;


          if assigned( sql_query ) then
            prm_query := sql_query.Query
          else
            prm_query := '' ;

          ParamsList.Selected := TGIS_ParamsSectionVector(
                                   paramsCache[prm]
                                 ).InternalIndex ;

          if Params.Line.OutlineWidth = 0 then continue ;

          if not IsStringEmpty( cursorState[ 0 ].curDrawQuery ) then
            tmp_query := Format( '(%s) and (%s)',
                                 [ cursorState[ 0 ].curDrawQuery, prm_query ]
                               )
          else
            tmp_query := prm_query ;

          shp := FindFirst( _extent, tmp_query ) ;
          while shp <> nil do begin // iterate all shapes
            shp.Layer.bIgnoreShapeParams := shp.Layer.IgnoreShapeParams ;
            try
              render := TGIS_ParamsSectionVector( Params ).Render ;

              if not IsStringEmpty( render.Expression ) or
                 not IsStringEmpty( render.Chart ) then
              begin
                rndr := lockRender( shp, 0, 0 ) ;
                if rndr then begin
                  do_draw( TGIS_RendererMultipassMode.Outline ) ;

                  Result := True ;
                  unlockRender ;
                end ;
              end
              else begin
                do_draw( TGIS_RendererMultipassMode.Outline ) ;
                Result := True ;
              end ;
            finally
              shp.Layer.bIgnoreShapeParams := False ;
            end;
            shp := FindNext ;
          end ;
        end ;

        // regular shapes
        for prm := 0 to cnt - 1 do begin
          sql_query := TGIS_ParamsSectionVector(
                              paramsCache[prm]
                       ).QueryObj ;

          if not TGIS_ParamsSectionVector(
                              paramsCache[prm]
                       ).Visible then continue ;


          if assigned( sql_query ) then
            prm_query := sql_query.Query
          else
            prm_query := '' ;

          ParamsList.Selected := TGIS_ParamsSectionVector(
                              paramsCache[prm]
                       ).InternalIndex ;


          if not IsStringEmpty( cursorState[ 0 ].curDrawQuery ) then
            tmp_query := Format( '(%s) and (%s)',
                                 [ cursorState[ 0 ].curDrawQuery, prm_query ]
                               )
          else
            tmp_query := prm_query ;

          shp := FindFirst( _extent, tmp_query ) ;
          while shp <> nil do begin // iterate all shapes
            shp.Layer.bIgnoreShapeParams := shp.Layer.IgnoreShapeParams ;
            try
                params_label := shp.Params.Labels ;
                labelHint := labelHint or
                              ( params_label.Visible and
                                ( not IsStringEmpty( params_label.Field ) or
                                  not IsStringEmpty( params_label.Value )
                                )
                              ) ;
                render := TGIS_ParamsSectionVector( Params ).Render ;

                if not IsStringEmpty( render.Expression ) or
                    not IsStringEmpty( render.Chart ) then
                begin
                  rndr := lockRender( shp, 0, 0 ) ;
                  if rndr then begin
                    do_draw( TGIS_RendererMultipassMode.Line ) ;

                    Result := True ;
                    unlockRender ;
                  end ;
                end
                else begin
                  do_draw( TGIS_RendererMultipassMode.Line ) ;
                  Result := True ;
                end ;
            finally
              shp.Layer.bIgnoreShapeParams := False ;
            end;
            shp := FindNext ;
          end ;
        end ;

      end
      else begin
        edt_has_snap := ( edt.ViewerEnabled or edt.InEdit )
                        and
                        edt.ShowTracking
                        and
                        assigned( edt.SnapLayer )
                        and
                        edt.FindSnapLayer(self) ;

        shp := FindFirst( _extent, cursorState[ 0 ].curDrawQuery ) ;
        while shp <> nil do begin // iterate all shapes
          shp.Layer.bIgnoreShapeParams := shp.Layer.IgnoreShapeParams ;
          try
            if checkParamsCache( shp, 0 ) then begin

              if shp.SmartSize <> 0 then begin
                // apply smartsize hint for Pooinmts only when shape was drawn
                if shp.ShapeType = TGIS_ShapeType.MultiPoint then begin
                   // ignore single point within multipoint scenario
                   if GisIsEmptyExtent( shp.Extent ) then
                     oldMarkerPoint := shp.Centroid ;
                end
                else
                if shp.ShapeType = TGIS_ShapeType.Point then
                  // only for smarsize
                  oldMarkerPoint := shp.Centroid ;
              end;


              params_label := shp.Params.Labels ;
              labelHint := labelHint or
                            ( params_label.Visible and
                              ( not IsStringEmpty( params_label.Field ) or
                                not IsStringEmpty( params_label.Value )
                              )
                            ) ;
              render := TGIS_ParamsSectionVector( Params ).Render ;

              if not IsStringEmpty( render.Expression ) or
                  not IsStringEmpty( render.Chart ) then
              begin
                rndr := lockRender( shp, 0, 0 ) ;
                if rndr then begin
                  do_draw( TGIS_RendererMultipassMode.Single ) ;
                  Result := True ;
                  unlockRender ;
                end ;
              end
              else begin
                do_draw( TGIS_RendererMultipassMode.Single ) ;
                Result := True ;
              end ;

              if edt_has_snap and ( shp <> edt.CurrentShape ) then
                shp.DrawTrackingPoints ;
            end ;
          finally
            shp.Layer.bIgnoreShapeParams := False ;
          end;
          shp := FindNext ;
        end ;

      end ;

    finally
      inDraw := False ;
      bIgnoreShapeParams := False ;
      cursorFinish(0);
      if assigned( FDynamicAggregator ) then begin
        FDynamicAggregator.clearContext ;
      end;
    end ;

  except
    on ex : Exception do begin
      msg := ex.Message ;
      raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_LAYERBADFORMAT ) +
                                    '; ' + msg,
                                    Name, 103
                                  ) ;
    end ;
  end;
end ;

function TGIS_LayerVector.DrawSelectedEx(
  const _extent : TGIS_Extent
) : Boolean ;
var
  cnt        : Integer ;
  is_visible : Boolean ;
  i          : Integer ;
  shp        : TGIS_Shape ;
begin
  Result := inherited DrawEx( _extent ) ;
  if not Result then Exit ;

  // parameters' service like in DrawEx
  prepareParamsCache( namedStyle ) ;
  cnt := paramsCache.Count ;

  if cnt <= 0 then exit ;

  is_visible := False ;
  for i:= cnt -1 downto 0 do begin
    is_visible := is_visible or
                  TGIS_ParamsSectionVector( paramsCache[i] ).Visible ;
    if is_visible then break ;
  end ;

  if not is_visible then exit ;

  inDraw := True ;
  bIgnoreShapeParams := FIgnoreShapeParams ;
  try
    { TODO -cImprove : To be optimized }
    for i := 0  to SelectedList.Count -1 do begin
      shp := GetShape(SelectedList[i]) ;
      if assigned( shp ) then begin
        shp.Layer.bIgnoreShapeParams := shp.Layer.IgnoreShapeParams ;
        try
          if checkParamsCache( shp, 0 ) then
            TGIS_RendererAbstract( Renderer ).RenderShape( shp, True ) ;
        finally
          shp.Layer.bIgnoreShapeParams := False ;
        end;
      end ;
    end;

  finally
    inDraw := False ;
    bIgnoreShapeParams := False ;
  end ;
end;

procedure TGIS_LayerVector.DrawFlash ;
var
  i : Integer ;
begin
  inherited ;

  if not assigned( oFlashQueue ) then exit ;
  for i := 0 to high( oFlashQueue ) do
    TGIS_RendererAbstract( Renderer ).RenderShapeFlashed( GetShape(oFlashQueue[i]) ) ;
end ;

function TGIS_LayerVector.DrawScope(
  const _query : String;
  const _style : String
) : Boolean ;
var
  old_scope : String ;
begin
  with cursorState[ 0 ] do begin

    old_scope := curDrawQuery ;

    curDrawQuery := _query ;
    namedStyle := _style ;
    labelHint := True ;

    Result := Draw ;

    curDrawQuery := old_scope ;
    namedStyle := '' ;

  end ;
end ;

function TGIS_LayerVector.DrawChart
  : Boolean ;
var
  shp       : TGIS_Shape        ;
  rndr      : Boolean           ;
  cnt       : Integer           ;
  render    : TGIS_ParamsRender ;
  {$IFDEF OXYGENE}
    e       : TGIS_ShapeEventArgs ;
  {$ENDIF}
begin
  Result := False ;

  with cursorState[ 0 ] do begin

    try
      if Viewer.Ref.Zoom <= 0 then exit ;

      try
        chartHint := True ;

        if not chartHint then exit ;

        prepareParamsCache( namedStyle ) ;
        cnt := paramsCache.Count ;

        if cnt <= 0 then exit ;

        inDraw := True ;
        bIgnoreShapeParams := FIgnoreShapeParams ;
        try
          shp := FindFirst( drawExtentEx, curDrawQuery ) ;
          while assigned( shp ) do begin // iterate all shapes
            shp.Layer.bIgnoreShapeParams := shp.Layer.IgnoreShapeParams ;
              if checkParamsCache( shp, 0 ) then begin
                if ( shp.Params.Chart.Size <> 0  ) or
                   {$IFDEF OXYGENE}
                     assigned( FOnPaintShapeChart )
                   {$ELSE}
                     assigned( PaintShapeChartEvent )
                   {$ENDIF}
                then begin
                  render := TGIS_ParamsSectionVector( Params ).Render ;
                  if not IsStringEmpty( render.Expression ) or
                     not IsStringEmpty( render.Chart )
                  then begin
                    rndr := lockRender( shp, 0, 0 ) ;
                    if rndr then begin
                      {$IFDEF OXYGENE}
                        if assigned( FOnPaintShapeChart ) then begin
                          e := TGIS_ShapeEventArgs.Create( shp ) ;
                          try
                            {$IFDEF JAVA}
                              FOnPaintShapeChart( self, e ) ;
                            {$ELSE}
                              FOnPaintShapeChart( self, e ) ;
                            {$ENDIF}
                          finally
                            FreeObject( e ) ;
                          end ;
                        end
                      {$ELSE}
                        if assigned( PaintShapeChartEvent ) then
                          PaintShapeChartEvent( self, shp )
                      {$ENDIF}
                        else
                          shp.DrawChart ;
                      Result := True ;
                      unlockRender ;
                    end ;
                  end
                  else begin
                    {$IFDEF OXYGENE}
                      if assigned( FOnPaintShapeChart ) then begin
                        e := TGIS_ShapeEventArgs.Create( shp ) ;
                        try
                          {$IFDEF JAVA}
                            FOnPaintShapeChart( self, e ) ;
                          {$ELSE}
                            FOnPaintShapeChart( self, e ) ;
                          {$ENDIF}
                        finally
                          FreeObject( e ) ;
                        end ;
                      end
                    {$ELSE}
                      if assigned( PaintShapeChartEvent ) then
                        PaintShapeChartEvent( self, shp )
                    {$ENDIF}
                      else
                        shp.DrawChart ;
                    Result := True ;
                  end ;
                end ;
              end ;
            shp := FindNext ;
          end ;
        finally
          inDraw := False ;
          bIgnoreShapeParams := False ;
        end ;

      finally
        chartHint := False ;
      end ;

    except
      on ex : Exception do begin
        raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_LAYERBADFORMAT ) +
                                     '; ' + ex.Message,
                                     Name, 106
                                   ) ;
      end ;
    end;

  end ;
end ;

procedure TGIS_LayerVector.FlashShape(
  const _uid   : TGIS_Uid ;
  const _times : Integer ;
  const _delay : Integer
) ;
begin
  if not assigned( Viewer ) then
    exit ;

  if Viewer.Ref.IsBusy then exit ;
  try
    Viewer.Ref.HourglassPrepare;

    queueFlash( _uid ) ;

    Viewer.Ref.ViewerParent.ControlFlash( _times, _delay ) ;
    if Viewer.Ref.Items.Count = 0 then  begin
      exit ;
    end ;

    releaseFlash( _uid ) ;
  finally
    Viewer.Ref.HourglassRelease;
  end;
end;

procedure TGIS_LayerVector.InvalidateScope(
  const _query : String ;
  const _style : String
) ;
var
  shp : TGIS_Shape ;
begin
  prepareParamsCache( _style ) ;
  shp := FindFirst( drawExtent, _query ) ;
  while assigned( shp ) do begin // iterate all shape
    cursorShapeEx(0).Invalidate ;
    shp := FindNext ;
  end ;
end ;

procedure TGIS_LayerVector.InvalidateSelection ;
begin
  if assigned( Viewer ) then
    Viewer.Ref.InvalidateSelection ;
end;

function TGIS_LayerVector.CentroidScope(
  const _query : String ;
  const _centroid : TGIS_Point
) : TGIS_Point  ;
var
  shp : TGIS_Shape ;
begin
  Result := _centroid ;

  shp := FindFirst( GisWholeWorld, _query ) ;

  if assigned( shp ) then  Result := shp.Centroid ;
end ;

procedure TGIS_LayerVector.Delete(
  const _uid : TGIS_Uid
) ;
var
  shp : TGIS_Shape ;
begin
  shp := GetShape( _uid ) ;
  if assigned( shp ) then begin
    shp.MakeEditable.Delete ;
  end ;
end ;

procedure TGIS_LayerVector.Revert(
  const _uid : TGIS_Uid
) ;
var
  ipos : Integer     ;
  shp  : TGIS_Shape ;
begin
  if getShapePos( _uid, ipos ) then begin
    shp := TGIS_Shape( Items[ipos]) ;
    if shp.IsModified then begin
      shp.Delete ;
      Items.Delete( ipos ) ;

      if UseRTree then begin
        shp := GetShape( _uid ) ;
        if assigned( shp ) then
          shp.AddToIndex ;
      end;
    end
    else begin
      Items.Delete( ipos ) ;
    end ;
  end ;
end ;

procedure TGIS_LayerVector.RevertShapes ;
var
  i : Integer ;
begin
  for i:= Items.Count -1 downto 0 do begin
    Revert( TGIS_Shape( Items[i]).Uid ) ;
  end ;
  Items.Clear ;
end ;


procedure TGIS_LayerVector.RevertAll ;
var
  i : Integer ;
begin
  RevertShapes ;

  for i:= FFields.Count -1 downto 0 do begin
    if not FieldInfo(i).Saved then begin // newly created - delete
      FFields.Delete( i ) ;
    end
    else begin // read from file
      with FieldInfo(i) do begin
        Deleted    := False ;
        NewName    := Name ;
        NewWidth   := Width ;
        NewDecimal := Decimal ;
      end ;
    end ;
  end ;
  helperFindField.Clear ;
  helperFindFieldInternal.Clear ;

  FIsModified := False ;
end ;

procedure TGIS_LayerVector.Deselect(
  const _uid : TGIS_Uid
) ;
begin
  FSelectedList.Remove( _uid );
  InvalidateSelection ;
end ;

procedure TGIS_LayerVector.DeselectAll ;
begin
  FSelectedList.Clear ;
  InvalidateSelection ;
end ;

procedure TGIS_LayerVector.SaveData ;
var
  i  : Integer ;
  lv : TGIS_LayerVector ;
begin
  FSelectedList.Clear ;

  if not ( TGIS_LayerSubType.Persistent in SubType ) then begin
    // do only for pure in memory layers
    lv := TGIS_LayerVector.Create ;
    try
      lv.ImportLayer( self, self.Extent, TGIS_ShapeType.Unknown, '', False );
      self.ImportLayer( lv, lv.Extent, TGIS_ShapeType.Unknown, '', False );
      FIsModified := False ;
    finally
      FreeObject( lv ) ;
    end ;
  end
  else begin
    for i := Items.Count - 1 downto 0 do
      if Items[i].IsDeleted then
        Items.Delete(i) ;
  end ;

  FIsModified := False ;
end ;

function TGIS_LayerVector.MustSave
  : Boolean ;
var
  i   : Integer ;
  fld : TGIS_FieldInfo ;
begin
  if not ( TGIS_LayerSubType.Persistent in SubType ) then begin
    Result := False ;
    exit ;
  end;

  Result := inherited MustSave or FIsModified  ;

  for i:=0 to Fields.Count -1 do begin
    fld := FieldInfo( i ) ;
    if assigned( fld.Rules ) then
      Result := Result or TGIS_FieldRule( fld.Rules ).Modified ;
  end;
end ;

procedure TGIS_LayerVector.RecalcExtent ;
var
  ex : TGIS_Extent3D ;
begin
  Lock ;
  try ;
    ex := Extent3D ;

    cursorFirst( 0, False,
                 GisWholeWorld, '', nil, '', True
               ) ;

    if not cursorEof(0) then // do not override extent for an empty layer
      ex := cursorShapeEx(0).Extent3D ;

    while not cursorEof(0) do begin // iterate all shapes
      // skip deleted shapes
      if not cursorShapeEx(0).IsDeleted then
        ex := GisMaxExtent3D( ex, cursorShapeEx(0).Extent3D ) ;

      cursorNext(0) ;
    end ;
    Extent3D := ex ;
  finally
    Unlock ;
  end ;
end ;

function TGIS_LayerVector.Locate(
  const _ptg     : TGIS_Point ;
  const _prec    : Double
) : TGIS_Shape ;
begin
  Result := Locate( _ptg, _prec, True ) ;
end ;

function TGIS_LayerVector.Locate(
  const _ptg     : TGIS_Point ;
  const _prec    : Double     ;
  const _visible : Boolean
) : TGIS_Shape ;
var
  dist : Double  ;
  part : Integer ;
  proj : TGIS_Point ;
begin
  Result := LocateEx( _ptg, _prec, -1, dist, part, proj, _visible ) ;
end ;

function  TGIS_LayerVector.LocateEx(
  const _ptg     : TGIS_Point ;
  const _prec    : Double     ;
  const _uid     : TGIS_Uid   ;
  var   _dist    : Double     ;
  var   _part    : Integer    ;
  var   _proj    : TGIS_Point
) : TGIS_Shape ;
begin
  Result := LocateEx( _ptg, _prec, _uid, _dist, _part, _proj, True ) ;
end ;

function  TGIS_LayerVector.LocateEx(
  const _ptg     : TGIS_Point ;
  const _prec    : Double     ;
  const _uid     : TGIS_Uid   ;
  var   _dist    : Double     ;
  var   _part    : Integer    ;
  var   _proj    : TGIS_Point ;
  const _visible : Boolean
) : TGIS_Shape ;
var
  distp : Double ;
begin
  Result := LocateEx( _ptg, _prec, _uid, _dist, _part, _proj, distp, _visible ) ;
end ;

function  TGIS_LayerVector.LocateEx(
  const _ptg         : TGIS_Point ;
  const _prec        : Double     ;
  const _uid         : TGIS_Uid   ;
  var   _dist        : Double     ;
  var   _part        : Integer    ;
  var   _proj        : TGIS_Point ;
  var   _dist_prefer : Double     ;
  const _visible     : Boolean
) : TGIS_Shape ;
var
  i         : Integer    ;
  min_uid   : TGIS_Uid    ;
  cnt       : Integer    ;
  tmp1      : Double     ;
  tmp2      : Double     ;
  dist2     : Double     ;
  proj_ptg  : TGIS_Point ;
  proj      : TGIS_Point ;
  shp       : TGIS_Shape ;
  prec      : Double     ;
  is_visible: Boolean    ;
  sql_query : TGIS_SqlQuery ;
  ptfix     : Double     ;
begin
  Result     := nil ;

  if assigned( Viewer ) and
     Viewer.Ref.InPaint
  then
    exit ;

  if Basemap then
    exit ;

  if not IsOpened then
    Open ;

  _dist      := GIS_MAX_DOUBLE ;
  _dist_prefer := GIS_MAX_DOUBLE ;
  dist2      := GIS_MAX_DOUBLE ;
  min_uid    := GIS_MIN_INTEGER ;
  proj       := _ptg  ;
  cnt        := 0     ;

  if _visible then begin
    prepareParamsCache( '' ) ;

    cnt := paramsCache.Count ;

    is_visible := False ;

    for i:= cnt -1 downto 0 do begin
      is_visible := is_visible or
                    TGIS_ParamsSectionVector( paramsCache[i] ).Visible ;
      if is_visible then break ;
    end ;

    is_visible := is_visible or ( not assigned( Viewer ) ) ;

    if not is_visible then begin
      Result := nil ;
      _proj  := proj;
      exit;
    end;
  end ;

  // calculate front attract (points within 3 pixels should
  // more attractive then line or polygons
  if assigned( Viewer ) then
    ptfix := 3 / Viewer.Ref.Zoom
  else
    ptfix := 0 ;

  shp := FindFirst(
           GisExtent( _ptg.X - _prec, _ptg.Y - _prec,
                      _ptg.X + _prec, _ptg.Y + _prec
                    )
         ) ;
  while shp <> nil do begin
    if shp is TGIS_ShapeComplex then begin
      if assigned(
           TGIS_Shape(
              TGIS_ShapeComplex( shp ).Locate( _ptg, _prec, _visible, tmp1 )
           )
         )
      then begin
        _dist := tmp1 ;
        _dist_prefer := _dist  ;

        Result := shp ;
        exit ;
      end;
    end
    else begin
      if ( not shp.IsHidden ) or ( not _visible ) then begin
        if ( shp is TGIS_ShapePolygon ) and
          ( not GisIsPointInsidePolygon( _ptg, TGIS_ShapePolygon( shp ), -1 ) )
        then
          prec := GIS_MAX_DOUBLE   // point is outside - so we are trying
                                   // to find a distance to the border
        else
          prec := _prec ;

        is_visible := True ;

        if _visible then begin
          is_visible := False ;


          if FMultipassRendering then begin
            for i := 0 to cnt - 1 do begin
              sql_query := TGIS_ParamsSectionVector(
                             paramsCache[i]
                           ).QueryObj ;

              if not TGIS_ParamsSectionVector(
                       paramsCache[i]
                     ).Visible then continue ;

              if ( assigned( sql_query )
                   and
                   ( not IsStringEmpty( sql_query.Query ) )
                 )
              then begin
                if not sql_query.ParseAsBoolean( shp,
                                                 False,
                                                 0
                                               )
                 then
                   continue ;
              end;

              ParamsList.Selected := TGIS_ParamsSectionVector(
                                       paramsCache[i]
                                     ).InternalIndex ;

              if Params.Visible then begin
                is_visible := True ;
                break ;
              end;
            end
          end
          else begin
            is_visible := checkParamsCache( shp, 0 ) ;
          end ;
        end ;

        if is_visible then begin
          for i:= 0 to shp.GetNumParts-1 do begin
            tmp1 := shp.Distance2Part( _ptg, prec, i, proj_ptg ) ;

            case shp.ShapeType of
              TGIS_ShapeType.Point       ,
              TGIS_ShapeType.MultiPoint  : if ptfix = 0
                                           then tmp2 := tmp1 * 0.9
                                           else tmp2 := Max(0,tmp1 -ptfix) ;
              else                              tmp2 := tmp1 ;
            end ;

            if shp.Uid <> _uid then
              if ( tmp2 <= dist2 ) and ( tmp1 <= _dist) then begin
                // better then previous (or laid on top) - makes it default
                _dist      := tmp1     ;
                dist2      := tmp2     ;
                _dist_prefer := dist2  ;
                _part      := i        ;
                proj       := proj_ptg ;
                min_uid    := shp.Uid  ;
              end ;
          end ;
        end ;
      end ;

    end;

    shp := FindNext ;
  end ;

  if ( _dist <= Abs( _prec ) ) and ( min_uid > GIS_MIN_INTEGER ) then
    Result := GetShape( min_uid )
  else if _visible then begin
    Result := nil ;

    if assigned( Viewer ) and
      Viewer.Ref.LabelsReg.FindShape( _ptg, Self.GetHashCode, min_uid ) then
    begin
      Result := GetShape( min_uid ) ;
      prec := _prec ;
      if assigned( Result ) then begin
        for i:= 0 to Result.GetNumParts-1 do begin
          tmp1 := Result.Distance2Part( _ptg, prec, i, proj_ptg ) ;

          case Result.ShapeType of
          TGIS_ShapeType.Point       ,
          TGIS_ShapeType.MultiPoint  : if ptfix = 0
                                         then tmp2 := tmp1 * 0.9
                                         else tmp2 := tmp1 -ptfix ;
            else                      tmp2 := tmp1 ;
          end ;
          if tmp2 <= dist2 then begin
            _dist    := tmp1     ;
            dist2    := tmp2     ;
            _part    := i        ;
            proj     := proj_ptg ;
          end ;
        end ;
      end ;
    end ;

  end ;
  _proj := proj
end ;

function TGIS_LayerVector.FindField(
  const _name : String
) : Integer ;
var
  i   : Integer ;
  idx : {$IFDEF JAVA} nullable {$ENDIF} Integer ;
begin
  Result := -1 ;

  // clear helper for empty field list
  if ( Fields.Count < 1 ) then begin
    helperFindField.Clear ;
    helperFindFieldInternal.Clear ;
  end ;

  // create cached list
  if helperFindField.Count < 1 then begin
    for i := 0 to FFieldsVirtual.Count -1 do begin
      helperFindField.Add( FieldInfo(i+ GIS_FIELD_ID_UID).NewName, i + GIS_FIELD_ID_UID ) ;
    end ;
  end ;
  if Fields.Count + FFieldsVirtual.Count <> helperFindField.Count then begin
    for i := 0 to Fields.Count -1 do begin
      helperFindField.Add( FieldInfo(i).NewName, i ) ;
    end ;
  end;
  assert( Fields.Count + FFieldsVirtual.Count = helperFindField.Count ) ;

  // general case
  if ( Result < 0 ) and helperFindField.TryGetValue( _name, idx ) then
    Result := idx ;
end ;

function TGIS_LayerVector.FindFieldInternal(
  const _name : String
) : Integer ;
var
  i   : Integer ;
  idx : {$IFDEF JAVA} nullable {$ENDIF} Integer ;
begin
  Result := -1 ;

  // clear helper for empty field list
  if ( Fields.Count < 1 ) or
     ( Fields.Count <> helperFindFieldInternal.Count )
  then begin
    helperFindField.Clear ;
    helperFindFieldInternal.Clear ;
  end ;

  // create cached list
  if helperFindFieldInternal.Count < 1 then begin
    for i := 0 to Fields.Count -1 do begin
      helperFindFieldInternal.Add( FieldInfo(i).Name, i ) ;
    end ;
  end ;
  assert( Fields.Count = helperFindFieldInternal.Count ) ;

  // general case
  if ( Result < 0 ) and helperFindFieldInternal.TryGetValue( _name, idx ) then
    Result := idx ;
end ;

function TGIS_LayerVector.GetUniqueFieldName(
  const _name     : String
) : String ;
var
  i    : Integer ;
begin
  Result := _name ;
  i := 0 ;
  while FindField( Result ) >= 0 do begin
    if i < 24 then
      Result := _name + '_' + Char( 65 + i )
    else
      Result := _name + '_' + IntToStr( i ) ;
    inc( i ) ;
  end ;
end;

procedure TGIS_LayerVector.AddField(
  const _name    : String         ;
  const _type    : TGIS_FieldType ;
  const _width   : Integer        ;
  const _decimal : Integer
) ;
var
  fld : TGIS_FieldInfo ;
begin
  if FindField( _name ) >= 0 then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDEXIST ), _name, 0 ) ;
  end ;

  fld := TGIS_FieldInfo.Create() ;
  fld.Deleted       := False      ;
  fld.Saved         := False      ;
  fld.FieldType     := _type      ;
  fld.Name          := _name      ;
  fld.Width         := _width     ;
  fld.Decimal       := _decimal   ;
  fld.NewName       := _name      ;
  fld.NewWidth      := _width     ;
  fld.NewDecimal    := _decimal   ;
  fld.Binary        := 0          ;
  fld.ExportName    := ''         ;
  fld.Hidden        := False      ;
  fld.ReadOnly      := False      ;
  fld.FileFormat    := False      ;
  fld.Temporary     := False      ;
  fld.IsUID         := False      ;

  FFields.Add( fld ) ;

  FIsModified := True ;

  helperFindField.Add( _name, FFields.Count -1 ) ;
  helperFindFieldInternal.Add( _name, FFields.Count -1 ) ;
end ;

procedure TGIS_LayerVector.AddFieldInternal(
  const _name    : String         ;
  const _type    : TGIS_FieldType ;
  const _width   : Integer        ;
  const _decimal : Integer
) ;
begin
  AddFieldInternal( _name, _type, _width, _decimal, True, 0 ) ;
end ;

procedure TGIS_LayerVector.AddFieldInternal(
  const _name    : String         ;
  const _type    : TGIS_FieldType ;
  const _width   : Integer        ;
  const _decimal : Integer        ;
  const _saved   : Boolean        ;
  const _binary  : Integer
) ;
var
  fld : TGIS_FieldInfo ;
begin
  if FindField( _name ) >= 0 then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDEXIST ), _name, 0 ) ;
  end ;

  if _name = GIS_FIELD_STYLE then
    FUseShapeStyleField := True ;

  fld := TGIS_FieldInfo.Create() ;
  fld.Deleted       := False      ;
  fld.Saved         := _saved     ;
  fld.FieldType     := _type      ;
  fld.Name          := _name      ;
  fld.Width         := _width     ;
  fld.Decimal       := _decimal   ;
  fld.NewName       := _name      ;
  fld.NewWidth      := _width     ;
  fld.NewDecimal    := _decimal   ;
  fld.Binary        := _binary    ;
  fld.ExportName    := ''         ;
  fld.Hidden        := False      ;
  fld.ReadOnly      := False      ;
  fld.FileFormat    := False      ;
  fld.Temporary     := False      ;
  fld.IsUID         := False      ;

  FFields.Add( fld ) ;

  helperFindField.Add( _name, FFields.Count -1 ) ;
  helperFindFieldInternal.Add( _name, FFields.Count -1 ) ;
end ;

procedure TGIS_LayerVector.RenameField(
  const _name : String ;
  const _newname : String ;
  const _width : Integer ;
  const _decimal : Integer
) ;
var
  fld : TGIS_FieldInfo ;
begin
  fld := FieldInfo( FindField( _name )  ) ;
  if fld = nil then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDNOEXIST ), _name, 0 ) ;
  end ;

  if TGIS_FieldFlags.ReadOnly in fld.Flags then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDREADONLY ), _name, 0 ) ;
  end ;

  if CompareText( _name, _newname ) <> 0 then
    if FindField( _newname ) >= 0 then begin
      raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDEXIST ), _newname, 0 ) ;
    end ;

  if CompareText( _name, _newname ) <> 0 then begin
    fld.NewName     := _newname ;
    FIsModified := True ;
  end ;
  if fld.NewWidth   <> _width   then begin
    fld.NewWidth    := _width   ;
    FIsModified := True ;
  end ;
  if fld.NewDecimal <> _decimal then begin
    fld.NewDecimal  := _decimal ;
    FIsModified := True ;
  end ;

  helperFindField.Clear ;
end ;

procedure TGIS_LayerVector.DeleteField(
  const _name : String
) ;
var
  fld : TGIS_FieldInfo ;
begin
  fld := FieldInfo( FindField( _name ) ) ;
  if fld = nil then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDNOEXIST ), _name, 0 ) ;
  end ;

  if TGIS_FieldFlags.ReadOnly in fld.Flags then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDREADONLY ), _name, 0 ) ;
  end ;

  fld.Deleted := True ;

  FIsModified := True ;
end ;

function TGIS_LayerVector.FieldInfo(
  const _id : Integer
) : TGIS_FieldInfo ;
var
  id : Integer ;
begin
  Result := nil ;

  if (_id >= 0) and (_id < FFields.Count) then begin
    Result := TGIS_FieldInfo( FFields[_id] ) ;
    exit ;
  end ;

  id := _id - GIS_FIELD_ID_UID ;

  if (id >= 0) and (id < FFieldsVirtual.Count) then begin
    Result := TGIS_FieldInfo( FFieldsVirtual[id] ) ;
  end ;
end;

procedure TGIS_LayerVector.PrepareExportFieldNames(
  const _maxwidth : Integer
) ;
begin
  PrepareExportFieldNames( _maxwidth, False, True ) ;
end ;

procedure TGIS_LayerVector.PrepareExportFieldNames(
  const _maxwidth : Integer ;
  const _forced   : Boolean
) ;
begin
  PrepareExportFieldNames( _maxwidth, _forced, True ) ;
end ;

procedure TGIS_LayerVector.PrepareExportFieldNames(
  const _maxwidth     : Integer ;
  const _forced       : Boolean ;
  const _useUpperCase : Boolean
) ;
const
  RESERVED_WORDS : array[0..31] of String =
     ('UID', 'ADD', 'ALTER', 'AND', 'AS', 'ASC', 'BETWEEN', 'BY', 'COLUMN',
      'CREATE', 'DELETE', 'DESC', 'DROP', 'EXISTS', 'FOR', 'FROM', 'IN',
      'INSERT', 'INTO', 'IS', 'LIKE', 'NOT', 'NULL', 'OR', 'ORDER', 'SELECT',
      'SET', 'TABLE', 'UPDATE', 'VALUES', 'WHERE', 'NULL');

var
  i,j      : Integer ;
  cnt      : Integer ;
  name_tmp : String  ;
  {$IFDEF OXYGENE}
    name_tmp_sb : StringBuilder ;
  {$ENDIF}
  name_len : Integer ;

  function find_name(
    const _idx  : Integer ;
    const _name : String
  ) : Boolean ;
  var
   i1 : Integer ;
  begin
    Result := False ;
    for i1 := 0 to FFields.Count -1 do begin
      if i1 = _idx then continue ;
      if CompareText( FieldInfo( i1 ).ExportName, _name ) = 0 then begin
        Result := True ;
        exit ;
      end ;
    end ;
  end ;
begin

  for i := 0 to FFields.Count - 1 do begin
    if ( not _forced ) and
       ( FieldInfo( i ).Saved
         and
         ( FieldInfo( i ).Name = FieldInfo( i ).NewName )
       )
    then
      name_tmp := FieldInfo( i ).NewName
    else begin
      name_len := length( FieldInfo( i ).NewName ) ;
      if _maxwidth > 4 then name_len := Min( name_len + 2, _maxwidth )
                       else name_len := Min( name_len + 2, 4         ) ;
      if _useUpperCase then
        name_tmp := Trim(
                      Copy(
                        UpperCase( FieldInfo( i ).NewName ),
                        StringFirst,
                        name_len )
                    )
      else
        name_tmp := Trim( Copy( FieldInfo( i ).NewName, StringFirst, name_len ) ) ;

      if length( name_tmp ) = 0 then name_tmp := 'FIELD' ;

      {$IFDEF OXYGENE}
        name_tmp_sb := StringBuilder.Create( name_tmp ) ;
      {$ENDIF}

      if not InCharSet( name_tmp[StringFirst], [ '_', 'az', 'AZ', '_'] ) then
        {$IFNDEF OXYGENE}
          name_tmp[StringFirst] := 'F' ;
        {$ELSE}
          name_tmp_sb[StringFirst] := 'F';
        {$ENDIF}

      for j := StringFirst + 1 to StringLast( name_tmp ) do begin
        if not InCharSet( name_tmp[j], ['09','az', 'AZ', '_'] )
        then
          {$IFNDEF OXYGENE}
            name_tmp[j] := '_' ;
          {$ELSE}
            name_tmp_sb[j] := '_' ;
          {$ENDIF}
      end ;

      {$IFDEF OXYGENE}
        name_tmp := name_tmp_sb.ToString ;
      {$ENDIF}

      cnt := 1 ;
      while find_name( i, name_tmp ) do begin
        // truncate to maxwidth - 2 char and add number
        name_tmp := Format( '%s%.2x',
                            [ Copy( name_tmp, StringFirst, name_len -2 ), cnt ]
                          ) ;
        inc( cnt ) ;
        if cnt >= 255 then begin // 2 letters exceeded
          while find_name( i, name_tmp ) do begin
            // truncate to maxwidth - 3 char and add number
            name_tmp := Format( '%s%.3x',
                                [ Copy( name_tmp, StringFirst, name_len -3 ), cnt ]
                              ) ;
            inc( cnt ) ;
          end ;
          break ;
        end ;
      end ;
    end ;

    for j := 0 to length( RESERVED_WORDS ) - 1 do
      if CompareText( name_tmp, RESERVED_WORDS[j] ) = 0 then
        name_tmp := name_tmp + '_' ;

    if FieldInfo( i ).ExportName <> name_tmp then begin
      FieldInfo( i ).ExportName := name_tmp ;
      FIsModified := True ;
    end ;

  end ;
end ;

procedure TGIS_LayerVector.LegendInfo(
  const _id     : Integer ;
  const _params : TGIS_ParamsSectionVector
) ;
begin
  LegendInfo( Params.InternalIndex, _id, _params ) ;
end ;

function TGIS_LayerVector.LegendInfo(
  const _sectionIdx : Integer ;
  const _id         : Integer ;
  const _params     : TGIS_ParamsSectionVector
) : Boolean ;
var
  current_value : Double  ;
  precision     : Integer ;
  delta         : Double  ; // for precision calculation
  prec_factor   : Double  ;
  render        : TGIS_ParamsRender ;
  field_index          : Integer ;
  is_field_date         : Boolean ;
  str           : String  ;
  {$IFDEF OXYGENE}
  dt            : TDateTime ;
  {$ENDIF}

  function try_get_value_and_delta(
    const _zoneId : Integer ;
    const _render : TGIS_ParamsRender ;
    var   _value  : Double ;
    var   _delta  : Double
  ) : Boolean ;
  var
    min_val            : Double ;
    max_val            : Double ;
    epsilon            : Double ;
    interpolation_base : Double ;
    zones              : Integer ;
    abs_zones          : Integer ;
    abs_zone_id        : Integer ;
  begin
    Result := False ;

    // standard band
    if _zoneId  > 0 then begin
      zones := _render.Zones ;
      min_val := _render.MinVal ;
      max_val := _render.MaxVal ;
    end
    // extended band
    else begin
      zones := _render.ZonesEx ;
      min_val := _render.MinValEx ;
      max_val := _render.MaxValEx ;
    end;

    if zones = 0 then
      exit ;

    if zones < 0 then
      // logarithmic scale
      interpolation_base := GIS_INTERPOLATE_BASE_LOG
    else
      // linear scale
      interpolation_base := 1 ;

    abs_zones := Abs( zones ) ;
    abs_zone_id :=  Abs( _zoneId ) ;
    _delta := Abs( max_val - min_val ) / abs_zones ;

    current_value := InterpolateValue(
      1,
      abs_zones,
      min_val,
      max_val,
      abs_zone_id,
      interpolation_base
    ) ;

    // imperceptibly decrease the value of the last zone before gap
    // to get proper end color
    if abs_zone_id = abs_zones then begin
      epsilon := ( max_val - min_val ) * GIS_SINGLE_RESOLUTION ;
      current_value := current_value - epsilon;
    end;

    Result := True;
  end ;

begin
  Result := False ;

  if not paramsCacheUpdated then
    exit ;

  current_value := GIS_MAX_DOUBLE ;

  if _id = 0 then
    exit ;

  render := TGIS_ParamsSectionVector( ParamsList.Items[_sectionIdx] ).Render ;
  if not try_get_value_and_delta( _id, render, current_value, delta ) then
    exit ;

  // apply params
  if not legendRender( _sectionIdx, current_value,  _params ) then
    exit ;

  // attach values based on band type and calculate minimum delta
  // calculate precision
  precision := render.Round ;
  if precision = 0 then begin
    if delta > 0 then
      precision := -RoundS( Log10( delta ) - 1 )
    else
      precision := 8 ;
  end
  else begin
    if precision < 0 then precision := precision + 1 ;
  end ;

  is_field_date := False ;
  field_index  := FindField( render.Expression ) ;
  if field_index > -1 then begin
    if FieldInfo(field_index).FieldType = TGIS_FieldType.Date then
      is_field_date := True ;
  end ;

  // calculate label name value (and round it)
  try
    if current_value > GIS_HALF_MAX_DOUBLE then Abort ;

    prec_factor := Power( 10, Abs( precision ) ) ;
    if precision < 0 then
      current_value := RoundS( current_value / prec_factor ) * prec_factor
    else if precision > 0 then
      current_value := RoundS( current_value * prec_factor ) / prec_factor
    else
      current_value := RoundS( current_value ) ;

    if is_field_date then begin
     {$IFDEF OXYGENE}
       {$IFDEF ISLAND}
         dt  := VarToDateTime( current_value ) ;
         str := dt.ToString ;
       {$ELSE}
         dt  := TDateTime.FromOADate( current_value ) ;
         if ( dt.Hour = 0 ) and ( dt.Minute = 0 ) and ( dt.Second = 0 ) then
           str := dt.ToShortDateString
         else
           str := dt.ToString ;
       {$ENDIF}
     {$ELSE}
       str := DateTimeToStr( current_value );
     {$ENDIF}
      _params.Legend := str ;
    end
    else begin
      if precision > 9 then
        _params.Legend := Format('%.*e', [ Abs(5), current_value ] )
      else if precision > 0 then
        _params.Legend := Format('%.*f', [ Abs(precision), current_value ] )
      else
        {$IFDEF CLR}
          // because of compiler error
          precision := 0 ;
          _params.Legend := Format('%.*f', [ precision, current_value ] ) ;
        {$ELSE}
          _params.Legend := Format('%.*f', [ 0, current_value ] ) ;
        {$ENDIF}
    end ;
  except
    _params.Legend := '#ERR' ;
  end ;

  Result := True ;
end ;

procedure TGIS_LayerVector.ParamsAsDrawn(
  const _shp     : TGIS_Shape ;
  const _params  : TGIS_ParamsSectionVector
) ;
var
  i            : Integer           ;
  rndr         : Boolean           ;
  cnt          : Integer           ;
  is_visible   : Boolean           ;
  render       : TGIS_ParamsRender ;
  shp          : TGIS_Shape        ;
begin
  if not assigned( _params ) then exit ;

  if assigned( Viewer ) then begin
    Viewer.Ref.Lock() ;
    try
      if Viewer.Ref.Zoom <= 0 then exit ;

      try
        prepareParamsCache( namedStyle ) ;
        cnt := paramsCache.Count ;

        if cnt <= 0 then exit ;

        is_visible := False ;
        for i:= cnt -1 downto 0 do begin
          is_visible := is_visible or
                       TGIS_ParamsSectionVector( paramsCache[i] ).Visible ;
          if is_visible then break ;
        end ;
        if not is_visible then exit ;

        inDraw := True ;
        bIgnoreShapeParams := FIgnoreShapeParams ;
        try
          shp := _shp ;
          if assigned( shp ) then
            shp.Layer.bIgnoreShapeParams := shp.Layer.IgnoreShapeParams ;
          try
            if checkParamsCache( shp, 0 ) then begin
              render := TGIS_ParamsSectionVector( Params ).Render ;

              if not IsStringEmpty( render.Expression ) or
                 not IsStringEmpty( render.Chart ) then
              begin
                rndr := lockRender( shp, 0, 0 ) ;
                if rndr then begin
                  _params.Assign( Params ) ;
                  unlockRender ;
                end ;
              end
              else begin
                _params.Assign( Params ) ;
              end ;
            end ;
          finally
            if assigned( shp ) then
              shp.Layer.bIgnoreShapeParams := False ;
          end;
        finally
          inDraw := False ;
          bIgnoreShapeParams := False ;
        end ;
      except
        on e : Exception do begin
          raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_LAYERBADFORMAT ) +
                                       '; ' + e.Message,
                                       Name, 101
                                     ) ;
        end ;
      end ;
    finally
      Viewer.Ref.Unlock( false ) ;
    end;
  end
  else begin
    _params.Assign( Params ) ;
  end;
end ;

function TGIS_LayerVector.GetAvailableLayers
  : TGIS_LayerInfoList  ;
begin
  Result := inherited GetAvailableLayers ;
  Result.Add(
    TGIS_LayerInfo.Create( Name,
                           TGIS_RegisteredLayerType.Vector,
                           DefaultShapeType
                          )
  ) ;
end ;

function TGIS_LayerVector.IsVector
  : Boolean ;
begin
  Result := True ;
end ;

function TGIS_LayerVector.IsVector3D
  : Boolean ;
begin
  Result := ( TGIS_DimensionType.XYM  in SupportedDimensions ) or
            ( TGIS_DimensionType.XYZM in SupportedDimensions ) or
            ( TGIS_DimensionType.XYZ  in SupportedDimensions ) ;
end ;

function TGIS_LayerVector.MustCalculateStatistics
  : Boolean ;
var
  old_sel : Integer ;
  i,k     : Integer ;
  shp     : TGIS_ShapePoint ;
begin
  Result := False ;


  shp := TGIS_ShapePoint.Create ;

  try
    shp.AddPart ;
    shp.AddPoint( GisCenterPoint( Self.Extent ) ) ;
    shp.Layer := Self ;

    old_sel := ParamsList.Selected ;

    for i := 0 to ParamsList.Count -1 do begin
       ParamsList.Selected := i ;

       // test if statistics is used within query
       if not IsStringEmpty( Params.Query ) then begin
         Params.QueryObj.ParseAsBoolean(
           shp, False, TGIS_Shape(shp).FCursor
         ) ;
       end;

       // test if statistics is used within labels
       TGIS_Shape(shp).GetLabel ;

       // future use; currently does not support statistics data
       {
         shp.Params.Line.Width ;
         shp.Params.Line.OutlineWidth ;
         shp.Params.Marker.Size ;
         shp.Params.Marker.OutlineWidth ;
         shp.Params.Area.SymbolSize ;
         shp.Params.Area.OutlineWidth ;
         shp.Params.Labels.Width ;
         shp.Params.Labels.Height ;
         shp.Params.Labels.OutlineWidth ;
         shp.Params.Labels.FontSize ;
       }

       // test if statistics is used within render expression
       if not IsStringEmpty( Params.Render.Expression ) then begin
          Params.Render.ExpressionObj.ParseAsFloat(
             shp, 0, TGIS_Shape(shp).FCursor
          ) ;
       end;

       // test if statistics is used within chars expression
       if not IsStringEmpty( Params.Render.Chart ) then begin
          for k := 0 to Params.Render.ChartObj.Count -1 do begin
            if assigned( Params.Render.ChartObj[k] ) then
                TGIS_SqlQuery( Params.Render.ChartObj[k] ).ParseAsFloat(
                  shp, 0, TGIS_Shape(shp).FCursor
                ) ;
          end ;
      end ;
    end ;

    ParamsList.Selected := old_sel ;
  finally
    FreeObject( shp ) ;
  end;

  Result := inherited ;
end;

procedure TGIS_LayerVector.LockRenderInternal ;
begin
  rLockedRender.oLock.LockThread ;
end ;

procedure TGIS_LayerVector.UnlockRenderInternal ;
begin
  rLockedRender.oLock.UnlockThread ;
end ;

procedure TGIS_LayerVector.ReorderShapeUids ;
var
  i,j : Integer ;
  shp : TGIS_Shape ;
begin
  j := 1 ;
  for i := 0 to Items.Count-1 do begin
    shp := Items[i] ;
    shp.FUid := j ;
    inc( j ) ;
  end ;
end ;

{$IFDEF CLR}
  function  TGIS_LayerVector.AssignedLabelPosEvent
    : Boolean ;
  begin
    Result := assigned( LabelPosEvent ) ;
  end ;

  procedure TGIS_LayerVector.RaiseLabelPosEvent(
    _sender : Object ;
    _e      : TGIS_ShapePosEventArgs
  ) ;
  begin
    if AssignedLabelPosEvent then
      LabelPosEvent( _sender, _e ) ;
  end ;
{$ENDIF}

{$ENDREGION 'TGIS_LayerVector'}

{$REGION 'TGIS_LayerVectorEnumerator'}

constructor TGIS_LayerVectorEnumerator.Create(
  const _factory     : TGIS_LayerVectorEnumeratorFactory ;
  const _lv          : TGIS_LayerVector ;
  const _extent      : TGIS_Extent      ;
  const _query       : String           ;
  const _shape       : TGIS_Shape       ;
  const _de9im       : String           ;
  const _skipDeleted : Boolean
);
begin
  inherited Create ;

  oFactory         := _factory     ;
  paramLayer       := _lv          ;
  paramExtent      := _extent      ;
  paramQuery       := _query       ;
  paramShape       := _shape       ;
  paramDe9im       := _de9im       ;
  paramSkipDeleted := _skipDeleted ;

  currCursor       := -1           ;

  bSublayer        :=  paramLayer is TGIS_LayerSublayerVector ;

  Reset ;
end;

constructor TGIS_LayerVectorEnumerator.Create(
  const _lv          : TGIS_LayerVector ;
  const _extent      : TGIS_Extent      ;
  const _query       : String           ;
  const _shape       : TGIS_Shape       ;
  const _de9im       : String           ;
  const _skipDeleted : Boolean
);
begin
  Create(
    nil          ,
    _lv          ,
    _extent      ,
    _query       ,
    _shape       ,
    _de9im       ,
    _skipDeleted
  ) ;
end;

{$IFNDEF MANAGED}

  destructor TGIS_LayerVectorEnumerator.Destroy ;
  begin
    paramLayer.cursorClose( currCursor )  ;
    FreeObject( oFactory ) ;
    inherited ;
  end;
{$ELSE}

  procedure TGIS_LayerVectorEnumerator.Dispose ;
  begin
    paramLayer.cursorClose( currCursor )  ;
    {$IFNDEF OXYGENE}
      inherited ;
    {$ENDIF}
  end;
{$ENDIF}

procedure TGIS_LayerVectorEnumerator.Reset ;
begin
  if currCursor <> -1 then
    paramLayer.cursorClose( currCursor )  ;

  currCursor := paramLayer.cursorOpen ;
  currShape  := paramLayer.cursorFindFirst(
                   currCursor, False,
                   paramExtent,
                   paramQuery,
                   paramShape,
                   paramDe9im,
                   paramSkipDeleted
                 ) ;
  currBof    := True ;
end;

function TGIS_LayerVectorEnumerator.MoveNext
  : Boolean;
begin
  while True do begin

    if currBof then
      currBof := False
    else
      currShape := paramLayer.cursorFindNext( currCursor ) ;

    if bSublayer
       and
       assigned( currShape )
       and
       ( currShape.Layer <> paramLayer ) // loop only sublayayers
    then
      continue
    else
      break ;
  end;

  Result := currShape <> nil ;
end;

function TGIS_LayerVectorEnumerator.GetCurrent
  : TGIS_Shape ;
begin
  Result := currShape ;
end;

function TGIS_LayerVectorEnumerator.BindField(
  const _name : String
) : Integer ;
begin
  Result := paramLayer.bindField( _name, currCursor ) ;
end;

function TGIS_LayerVectorEnumerator.GetField(
  const _field : Integer
) : Variant ;
begin
  Result := paramLayer.getBindedField( currShape, _field, currCursor ) ;
end;


{$IFDEF CLR}
  function TGIS_LayerVectorEnumerator.fget_current_obj
    : TObject ;
  begin
    Result := currShape ;
  end;
{$ENDIF}

{$IFDEF JAVA}
  method TGIS_LayerVectorEnumerator.hasNext : Boolean ;
  begin
    Result := MoveNext ;
  end ;

  method TGIS_LayerVectorEnumerator.next : TObject;
  begin
    Result := GetCurrent ;
  end ;

  method TGIS_LayerVectorEnumerator.&remove ;
  begin

  end ;
{$ENDIF}

{$ENDREGION 'TGIS_LayerVectorEnumerator'}

{$REGION 'TGIS_LayerVectorEnumeratorFactoryLinq'}

procedure TGIS_LayerVectorEnumeratorFactory.SetUp(
  const _lv          : TGIS_LayerVector ;
  const _extent      : TGIS_Extent      ;
  const _query       : String           ;
  const _shape       : TGIS_Shape       ;
  const _de9im       : String           ;
  const _skipDeleted : Boolean
);
begin
  stateLayer       := _lv          ;
  stateExtent      := _extent      ;
  statequery       := _query       ;
  stateShape       := _shape       ;
  stateDe9im       := _de9im       ;
  stateSkipDeleted := _skipDeleted ;
end;

{$IFDEF JAVA}
  method TGIS_LayerVectorEnumeratorFactory.&iterator
    : java.util.Iterator<TObject> ;
  begin
    Result := GetEnumerator ;
  end ;
{$ENDIF}

function TGIS_LayerVectorEnumeratorFactory.GetEnumerator
  : TGIS_LayerVectorEnumerator ;
begin
  Result := TGIS_LayerVectorEnumerator.Create(
    self             ,
    stateLayer       ,
    stateExtent      ,
    statequery       ,
    stateShape       ,
    stateDe9im       ,
    stateSkipDeleted
  ) ;
end ;

{$IFDEF CLR}
function TGIS_LayerVectorEnumeratorFactory.ToLinq
  : TGIS_LayerVectorEnumeratorFactoryLinq ;
begin
  Result := TGIS_LayerVectorEnumeratorFactoryLinq.Create(
              TGIS_LayerVectorEnumerator.Create(
                  self             ,
                  stateLayer       ,
                  stateExtent      ,
                  statequery       ,
                  stateShape       ,
                  stateDe9im       ,
                  stateSkipDeleted
                )
            ) ;
end ;

constructor TGIS_LayerVectorEnumeratorFactoryLinq.Create(
  const _en : TGIS_LayerVectorEnumerator
 ) ;
begin
  inherited Create ;
  en := _en ;
end;

function TGIS_LayerVectorEnumeratorFactoryLinq.GetEnumerator
  : IEnumerator ;
begin
  Result := en ;
end ;
{$ENDIF}

{$ENDREGION 'TGIS_LayerVectorEnumeratorFactoryLinq'}

{$REGION 'TGIS_DynamicAggregatorAbstract'}

constructor TGIS_DynamicAggregatorAbstract.Create(
  const _layer : TGIS_LayerVector
) ;
begin
  if not assigned( _layer ) then
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_LAYERNOEXIST ), '' , 0 ) ;

  FIsPreparing := False ;
  FLayer       := _layer ;
  FThreshold := AGGREGATOR_THRESHOLD ;
  RadiusAsText := AGGREGATOR_RADIUS_TXT ;
end;

procedure TGIS_DynamicAggregatorAbstract.SetUp ;
begin
  Layer.DynamicAggregator := self ;
end ;

procedure TGIS_DynamicAggregatorAbstract.fset_Radius(
  const _value : Integer
) ;

  function size_to_size_as_text(
    const _value : Integer
  ) : String ;
  var
    sec : TGIS_ParamsRender ;
  begin
    sec := TGIS_ParamsRender.Create ;
    try
      sec.StartSize := _value ;
      Result := sec.StartSizeAsText ;
    finally
      FreeObject( sec ) ;
    end ;
  end;
begin
  if FRadius = _value then exit ;

  FRadius := _value ;
  FRadiusAsText := size_to_size_as_text( _value ) ;
end;

procedure TGIS_DynamicAggregatorAbstract.fset_RadiusAsText(
  const _value : String
) ;
var
  radius_tmp : Integer ;

  function size_as_text_to_size(
    const _value : String
  ) : Integer ;
  var
    sec : TGIS_ParamsRender ;
  begin
    sec := TGIS_ParamsRender.Create ;
    try
      sec.StartSizeAsText := _value ;
      Result := sec.StartSize ;
    finally
      FreeObject( sec ) ;
    end ;
  end;

begin
  if FRadiusAsText = _value then exit ;

  FRadiusAsText := _value ;

  radius_tmp := size_as_text_to_size( _value ) ;
  if radius_tmp = -1999999999 then
    // when radius_tmp exceed 999 km reassign 'Radius'
    Radius := radius_tmp
  else
    FRadius := radius_tmp ;
end;

function TGIS_DynamicAggregatorAbstract.fget_Caption
  : String ;
begin
  Result := FName ;
end;

procedure TGIS_DynamicAggregatorAbstract.fset_Threshold(
  const _value : Integer
) ;
begin
  FThreshold := Max( AGGREGATOR_MIN_THRESHOLD, _value ) ;
end;

procedure TGIS_DynamicAggregatorAbstract.clearContext ;
begin
  FLayer.aggregatedItems.Clear ;
  FLayer.aggregatedItemsAttributes.Clear ;

  FLayer.cursorState[ 0 ].curAggregatedPos := high( Integer ) ;

  iUidOffset := 0 ;

  FIsPreparing := True ;
end;

procedure TGIS_DynamicAggregatorAbstract.prepareContext ;
var
  pos : Integer ;
  tmp : Int64 ;
begin
  if sizeOf( TGIS_Uid ) = 8 then
    tmp := $7FFFFFFFFFFFFFFF - $7F000000
  else
    tmp := $7FFFFFFF - $7F000000  ;
  if FLayer.getAggregatedPos( tmp, pos ) then
    FLayer.cursorState[ 0 ].curAggregatedPos := pos ;

  FIsPreparing := False ;
end;

procedure TGIS_DynamicAggregatorAbstract.applyConfigOptions(
  const _cfg : TGIS_ConfigAbstract
) ;
begin
  with TGIS_Config( _cfg ) do begin
    Layer.DynamicAggregator.Radius :=
      ReadInteger( GIS_INI_AGGREGATOR_RADIUS, Layer.DynamicAggregator.Radius ) ;
    Layer.DynamicAggregator.Threshold :=
      ReadInteger( GIS_INI_AGGREGATOR_THRESHOLD, Layer.DynamicAggregator.Threshold) ;
  end ;
end ;

procedure TGIS_DynamicAggregatorAbstract.storeConfigOptions(
  const _cfg : TGIS_ConfigAbstract
) ;
var
  dyn_agg           : TGIS_DynamicAggregatorAbstract ;
  def_size      : Integer ;
  def_min_count : Integer ;
begin
  dyn_agg := TGIS_DynamicAggregatorFactory.CreateInstance(
    Layer.DynamicAggregator.Name,
    Layer
  ) ;
  try
    def_size := dyn_agg.Radius ;
    def_min_count := dyn_agg.Threshold ;

    with TGIS_Config( _cfg ) do begin
      WriteInteger(
        GIS_INI_AGGREGATOR_RADIUS, Layer.DynamicAggregator.Radius, def_size
      ) ;
      WriteInteger(
        GIS_INI_AGGREGATOR_THRESHOLD, Layer.DynamicAggregator.Threshold, def_min_count
      ) ;
    end ;
  finally
    FreeObject( dyn_agg ) ;
  end;
end;

procedure  TGIS_DynamicAggregatorAbstract.useShapeType(
  const _type    : TGIS_ShapeType
) ;
begin
  Layer.aggregatorShapeType := _type ;
end;

procedure TGIS_DynamicAggregatorAbstract.HideShape(
  const _uid : TGIS_Uid
) ;
var
  shp : TGIS_ShapePoint ;
begin
  // create a dummy shape just to mark it as deleted
  shp := TGIS_ShapePoint.Create ;
  shp.IsDeleted := True ;
  shp.FUid      := _uid ;

  AddShape( shp, nil ) ;
end;

procedure TGIS_DynamicAggregatorAbstract.AddShape(
  const _shape : TGIS_Shape ;
  const _attr  : TObject
) ;
var
  ipos : Integer ;
begin
  if assigned( _attr ) then begin
    FLayer.aggregatedItemsAttributes.Add( _attr ) ;
    _shape.Layer := FLayer ;
    _shape.TagPointer := _attr ;
    _shape.Tag := AGGREGATED_MAGIC_NUMBER ;
    _shape.FUid := $FFFFFF + iUidOffset ;
    inc( iUidOffset ) ;
  end ;

  if FLayer.getAggregatedPos( _shape.Uid, ipos ) then begin
  end
  else begin
    if ipos < FLayer.aggregatedItems.Count then
      FLayer.aggregatedItems.Insert( ipos, _shape )
    else
      FLayer.aggregatedItems.Add( _shape ) ;
  end;

end;

procedure TGIS_DynamicAggregatorAbstract.AddShape(
  const _shape : TGIS_Shape ;
  const _value : Variant    ;
  const _uids  : TGIS_UidArray
) ;
var
  val : TGIS_DynamicAggregatorValue ;
begin
  val := nil ;
  if _value <> NullVar then begin
    val := TGIS_DynamicAggregatorValue.Create ;
    val.Value := _value ;
    val.Uids  := _uids  ;
  end ;

  _shape.FIsNewShape := True ;

  AddShape( _shape, val ) ;
end;

class procedure TGIS_DynamicAggregatorFactory.&Register(
  const _name  : String ;
  const _class : TGIS_DynamicAggregatorAbstractClass
) ;
begin
  allAggregators().AddOrSetValue( _name, _class ) ;
  FreeObject( oAggregatorsNames ) ;
end ;

class function TGIS_DynamicAggregatorFactory.allAggregators
  : TDictionary< String, TGIS_DynamicAggregatorAbstractClass > ;
var
  thc : TGIS_ThreadClass ;
begin
  if not assigned( oAggregators ) then begin
    thc := TGIS_ThreadClass.Create ;
      try
        thc.LockThread ;
        try
          oAggregators := TDictionary<
                            String,
                            TGIS_DynamicAggregatorAbstractClass
                          >.Create ;
        finally
          thc.UnlockThread ;
        end;
      finally
        FreeObject( thc );
      end;
  end ;

  Result := oAggregators ;
end ;

class function TGIS_DynamicAggregatorFactory.CreateInstance(
  const _name  : String ;
  const _layer : TGIS_LayerVector
) : TGIS_DynamicAggregatorAbstract ;
var
  tp  : TGIS_DynamicAggregatorAbstractClass ;
  obj : TGIS_DynamicAggregatorAbstract ;
begin
  Result := nil ;

  if not allAggregators().TryGetValue( _name, tp ) then
    exit ;

  {$IFDEF DCC}
    obj := tp.Create(_layer) ;
  {$ENDIF}
  {$IFDEF CLR}
    obj := TGIS_DynamicAggregatorAbstract(
      Activator.CreateInstance( tp.ActualType, [_layer] )
    );
  {$ENDIF}
  {$IFDEF JAVA}
    var prm := new &Class[1] ;
    prm[0] := typeOf(TGIS_LayerVector);
    obj := TGIS_DynamicAggregatorAbstract(
             tp.ActualType.getConstructor(prm).newInstance( [_layer] )
           ) ;
  {$ENDIF}

  obj.FName := _name ;
  obj.useConfig := False ;
  Result := obj ;
end ;

class function TGIS_DynamicAggregatorFactory.fget_Names : TStringList ;
{$IFDEF DCC}
  var
    elm : TPair< String, TGIS_DynamicAggregatorAbstractClass > ;
{$ENDIF}
begin
  if not assigned( oAggregatorsNames ) then begin
    oAggregatorsNames := TStringList.Create ;
  end;

  allAggregators ;

  try
    oAggregatorsNames.Clear ;
    for elm in oAggregators do
      oAggregatorsNames.Add( elm.Key ) ;
  finally
    oAggregatorsNames.Sorted := True ;
  end ;
  Result := oAggregatorsNames ;
end;

{$ENDREGION 'TGIS_DynamicAggregatorAbstract'}

{$REGION 'TGIS_SelectedShapeList'}

 constructor TGIS_SelectedShapeList.Create ;
 begin
   oDictionary := TDictionary< TGIS_Uid, Boolean >.Create ;
   SetLength( arKeys, 0 ) ;
 end;

 procedure TGIS_SelectedShapeList.doDestroy ;
 begin
   FreeObject( oDictionary ) ;
 end;

 function TGIS_SelectedShapeList.fget_Count
   : Integer ;
 begin
   Result  := oDictionary.Count ;
 end ;

 function TGIS_SelectedShapeList.fget_Item(
   const _index : Integer
 ) : TGIS_Uid ;
 begin
   if length( arKeys ) = 0 then begin
     {$IFDEF DCC}
       arKeys := oDictionary.Keys.ToArray ;
       TArray.Sort<TGIS_Uid>( arKeys ) ;
     {$ELSE}
       var i : Integer := 0 ;
       SetLength( arKeys, length(oDictionary.Keys));
       for  elm in oDictionary.Keys do begin
         arKeys[i] := elm ;
         inc(i) ;
       end ;
       {$IFDEF JAVA}
         java.util.Arrays.sort( arKeys ) ;
       {$ENDIF}
       {$IFDEF CLR}
         TArray<TGIS_Uid>.Sort( arKeys ) ;
       {$ENDIF}
       {$IFDEF ISLAND}
         TArray<TGIS_Uid>.Sort(
           arKeys,
           (a, b : TGIS_Uid)->
           begin
             if a < b then
               Result := -1
             else
             if a > b then
               Result := 1
             else
               Result := 0 ;
           end
          ) ;
       {$ENDIF}
     {$ENDIF}
   end ;

   Result := arKeys[_index] ;
 end ;

 procedure TGIS_SelectedShapeList.Clear ;
 begin
   SetLength( arKeys, 0 ) ;
   oDictionary.Clear ;
 end ;

 function TGIS_SelectedShapeList.ContainsKey(
   const _key   : TGIS_Uid
 ) : Boolean  ;
 begin
   Result := oDictionary.ContainsKey( _key );
 end;

 procedure TGIS_SelectedShapeList.Add(
   const _key   : TGIS_Uid
 ) ;
 begin
   SetLength( arKeys, 0 ) ;
   oDictionary.Add( _key, True ) ;
 end ;

 procedure TGIS_SelectedShapeList.Remove(
   const _key : TGIS_Uid
 ) ;
 begin
   SetLength( arKeys, 0 ) ;
   oDictionary.Remove( _key ) ;
 end ;

{$IFNDEF GENXDK}
  function TGIS_SelectedShapeList.GetEnumerator
    : TEnumerator<TGIS_Uid> ;
  begin
    {$IFDEF JAVA}
      Result := oDictionary.Keys.iterator ;
    {$ELSE}
       Result := oDictionary.Keys.GetEnumerator ;
    {$ENDIF}
  end;
{$ENDIF}

{$ENDREGION 'TGIS_SelectedShapeList'}

{$REGION 'TGIS_LayerVectorMergeHelper'}

constructor TGIS_LayerVectorMergeHelper.Create ;
begin
  inherited ;

  iThreshold := 100 ;
  oLayer     := nil ;
end ;

constructor TGIS_LayerVectorMergeHelper.Create(
  const _layer     : TGIS_LayerVector ;
  const _threshold : Integer
) ;
begin
  inherited Create ;

  assert( assigned( _layer ) ) ;

  iThreshold := _threshold ;
  oLayer     := _layer ;

  Self.ImportStructure( oLayer ) ;
end ;

procedure TGIS_LayerVectorMergeHelper.doDestroy ;
begin
  SaveData ;

  inherited ;
end ;

procedure TGIS_LayerVectorMergeHelper.SaveData ;
begin
  if assigned( oLayer ) then
    oLayer.MergeLayer( Self, GisWholeWorld, TGIS_ShapeType.Unknown, '', False, False ) ;

  Self.RevertShapes ;
end ;

procedure TGIS_LayerVectorMergeHelper.Commit ;
begin
  if Items.Count >= iThreshold then
    SaveData ;
end ;

{$ENDREGION 'TGIS_LayerVectorMergeHelper'}

{$REGION 'TGIS_LayerVectorDirectWriteHelper'}

constructor TGIS_LayerVectorDirectWriteHelper.Create(
  const _layer : TGIS_LayerVector
) ;
begin
  inherited Create ;

  assert( assigned( _layer ) ) ;
  oLayer := _layer ;
end ;

procedure TGIS_LayerVectorDirectWriteHelper.AddShape(
  const _shape : TGIS_Shape
) ;
begin
  oLayer.WriteShapeDirect( _shape ) ;
end ;

procedure TGIS_LayerVectorDirectWriteHelper.Build(
  const _path        : String           ;
  const _extent      : TGIS_Extent      ;
  const _type        : TGIS_ShapeType   ;
  const _dim         : TGIS_DimensionType
) ;
begin
  oLayer.InitializeDirectWrite( _path, _extent, _type, _dim ) ;
end ;

procedure TGIS_LayerVectorDirectWriteHelper.Close ;
begin
  oLayer.FinalizeDirectWrite ;
end ;

{$ENDREGION 'TGIS_LayerVectorDirectWriteHelper'}

{$REGION 'TGIS_Shape'}

constructor TGIS_Shape.Create ;
begin
  Create( nil, nil, False, -1, nil, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_Shape.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Create( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_Shape.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Create ;

  lockMode       := TGIS_Lock.None ;

  indexDist2PartCS := -1 ;

  FIsMapped      := False ;
  FIsEditable    := False ;
  FIsNewShape    := False ;
  FIsModified    := False ;
  FShape3D       := False ;

  FGeometryChanged := False ;

  FParent        := nil ;
  FParts         := nil ;
  FPartTypes     := nil ;
  FPoints        := nil ;
  FPointsZ       := nil ;
  FPointsM       := nil ;
  FPointsZMin    := 0   ;
  FPointsZMax    := 0   ;
  FPointsMMin    := 0   ;
  FPointsMMax    := 0   ;
  FShapeType     := TGIS_ShapeType.Unknown ;
  FDimension     := _dim ;
  Recreate( _source, _ptr, _mapped, _uid, _layer, _dim ) ;
end ;

constructor TGIS_Shape.Create(
  const _dim    : TGIS_DimensionType
) ;
begin
  Create( nil, nil, False, -1, nil, _dim ) ;
end ;

procedure TGIS_Shape.Recreate(
  const _source : TGIS_Shape ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes ;
  {$ELSE}
    const _ptr  : Pointer ;
  {$ENDIF}
  const _mapped : Boolean ;
  const _uid    : TGIS_Uid   ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Recreate( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

procedure TGIS_Shape.Recreate(
  const _source : TGIS_Shape ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes ;
  {$ELSE}
    const _ptr  : Pointer ;
  {$ENDIF}
  const _mapped : Boolean ;
  const _uid    : TGIS_Uid   ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
var
  mapped_tmp   : Boolean ;
  uid_tmp      : TGIS_Uid ;
  layer_tmp    : TGIS_LayerVector ;
begin
  FManageRTree := False ;

  // clear old instance
 {$IFDEF MANAGED}
   if assigned( FParts  ) then begin
     if not IsMapped then
       FParts.Reset ;
     {$IFNDEF JAVA}
       FreeObject( FParts ) ;
     {$ENDIF}
     FParts  := nil ;
   end ;
   if assigned( FPartTypes  ) then begin
     if not IsMapped then
       FPartTypes.Reset ;
     FreeObject( FPartTypes  ) ;
     FPartTypes  := nil ;
   end ;
   if assigned( FPoints ) then begin
     if not IsMapped then
       FPoints.Reset ;
     {$IFNDEF JAVA}
       FreeObject( FPoints ) ;
     {$ENDIF}
     FPoints := nil ;
   end ;
   if assigned( FPointsZ ) then begin
     if not IsMapped then
       FPointsZ.Reset ;
     FreeObject( FPointsZ ) ;
     FPointsZ := nil ;
   end ;
   if assigned( FPointsM ) then begin
     if not IsMapped then
       FPointsM.Reset ;
     FreeObject( FPointsM ) ;
     FPointsM := nil ;
   end ;
 {$ELSE}
   if (FPoints <> nil) and ( not IsMapped) then begin
     if assigned( FParts  ) then FreeMem( FParts  ) ;
     if assigned( FPoints ) then FreeMem( FPoints ) ;
     if assigned( FPartTypes  ) then FreeMem( FParttypes  ) ;
     FParts  := nil ;
     FPoints := nil ;
     FPartTypes  := nil ;
   end ;
   if (FPointsZ <> nil) and ( not IsMapped) then begin
     if assigned( FPointsZ ) then FreeMem( FPointsZ ) ;
     FPointsZ := nil ;
   end ;
   if (FPointsM <> nil) and ( not IsMapped) then begin
     if assigned( FPointsM ) then FreeMem( FPointsM ) ;
     FPointsM := nil ;
   end ;
 {$ENDIF}

 {$IFDEF JAVA}
   FreeObjectNotNilEx( FParams      ) ;
   FreeObjectNotNilEx( mappedFields ) ;
   FParams := nil ;
   mappedFields:= nil ;
 {$ELSE}
   FreeObject( FParams      ) ;
   FreeObject( mappedFields ) ;
 {$ENDIF}

  // prepare data for new instance
  if ( _source <> nil ) and ( not _source.IsEmpty )then begin
    mapped_tmp  := _source.IsMapped    ;
    {$IFDEF MANAGED}
      if assigned( _source.FParts ) then
        FParts  := TGIS_Bytes.Create( _source.FParts.Memory,
                                      _source.FParts.Position
                                      ) ;
    {$ELSE}
      FParts    := _source.FParts      ;
    {$ENDIF}
    {$IFDEF MANAGED}
      if assigned( _source.FPartTypes ) then
        FPartTypes := TGIS_Bytes.Create( _source.FPartTypes.Memory,
                                         _source.FPartTypes.Position
                                         ) ;
    {$ELSE}
      FPartTypes := _source.FPartTypes  ;
    {$ENDIF}
    {$IFDEF MANAGED}
      if assigned( _source.FPoints ) then
        FPoints := TGIS_Bytes.Create( _source.FPoints.Memory,
                                      _source.FPoints.Position
                                      ) ;
      if assigned( _source.FPointsZ ) then
        FPointsZ := TGIS_Bytes.Create( _source.FPointsZ.Memory,
                                       _source.FPointsZ.Position
                                       ) ;
      if assigned( _source.FPointsM ) then
        FPointsM := TGIS_Bytes.Create( _source.FPointsM.Memory,
                                       _source.FPointsM.Position
                                       ) ;
    {$ELSE}
      FPoints    := _source.FPoints     ;
      FPointsZ   := _source.FPointsZ    ;
      FPointsM   := _source.FPointsM    ;
    {$ENDIF}
    FPointsZMin  := _source.FPointsZMin ;
    FPointsZMax  := _source.FPointsZMax ;
    FPointsMMin  := _source.FPointsMMin ;
    FPointsMMax  := _source.FPointsMMax ;

    FShapeType   := _source.ShapeType   ;
    FDimension   := _source.Dimension   ;
    FIsReverted  := _source.FIsReverted ;
    FIsDeleted   := _source.FIsDeleted  ;
    FIsFixed     := _source.FIsFixed    ;
    FIsHidden    := _source.FIsHidden   ;
    FParent      := _source.FParent     ;
    Tag          := _source.Tag         ;
    TagPointer   := _source.TagPointer  ;

    if _uid = 0     then uid_tmp   := _source.FUid
                    else uid_tmp   := _uid ;
    if _layer = nil then layer_tmp := _source.FLayer
                    else layer_tmp := _layer  ;
  end
  else begin
    mapped_tmp   := _mapped ;
    uid_tmp      := _uid    ;
    layer_tmp    := _layer  ;
    FDimension   := _dim    ;
    FIsReverted  := False   ;
    FIsDeleted   := False   ;
    FIsFixed     := False   ;
    FIsHidden    := False   ;
    Tag          := 0       ;
  end ;

 FShape3D := FDimension in [ TGIS_DimensionType.XYZ..TGIS_DimensionType.XYZM ] ;

  // override defaults
  if _uid <> 0 then
    uid_tmp     := _uid    ;
  if _layer <> nil then
    layer_tmp   := _layer  ;

  // set main data
  if _ptr <> nil then
    prepareGeometry( _ptr ) ;
  FIsMapped  := mapped_tmp ;
  FUid       := uid_tmp    ;
  FLayer     := layer_tmp  ;

  // set Geometry
  FIsEmpty := checkIsEmpty ;
  if (not IsEmpty ) and (not IsMapped) then
    duplicateGeometry ;

  // set additional data
  if _source <> nil then begin
    if _source.FParams <> nil then begin
      FParams := TGIS_ParamsSectionVector.Create ;
      FParams.Assign( _source.FParams ) ;
    end ;
  end ;

  // copy mapped fields
  if assigned( _source ) then
    if assigned( _source.mappedFields ) then begin
      mappedFields := TGIS_FieldList.Create ;
      _source.mappedFields.CopyTo( mappedFields ) ;
    end ;

  TagInternal := 0 ;
end ;

{$IFNDEF MANAGED}

  destructor TGIS_Shape.Destroy;
  begin
    FreeObject( mappedFields  ) ;

    {$IFDEF CLR}
      if FParts <> nil then begin
        if not IsMapped then
          FParts.Reset ;
        FreeObject( FParts ) ;
      end ;
      if FPartTypes <> nil then begin
        if not IsMapped then
          FPartTypes.Reset ;
        FreeObject( FPartTypes ) ;
      end ;
      if FPoints <> nil then begin
        if not IsMapped then
          FPoints.Reset ;
        FreeObject( FPoints ) ;
      end ;
      if FPointsZ <> nil then begin
        if not IsMapped then
          FPointsZ.Reset ;
        FreeObject( FPointsZ ) ;
      end ;
      if FPointsM <> nil then begin
        if not IsMapped then
          FPointsM.Reset ;
        FreeObject( FPointsM ) ;
      end ;
    {$ELSE}
      if not IsMapped then begin
        if FParts <> nil then
          FreeMem( FParts ) ;
        if FPartTypes <> nil then
          FreeMem( FPartTypes ) ;
        if FPoints <> nil then
          FreeMem( FPoints ) ;
        if FPointsZ <> nil then
          FreeMem( FPointsZ ) ;
        if FPointsM <> nil then
          FreeMem( FPointsM ) ;
      end ;
    {$ENDIF}

    FreeObject( FParams ) ;

    inherited ;
  end ;
{$ENDIF}

function TGIS_Shape.fget_Uid
  : TGIS_Uid ;
begin
  Result := FUid ;
end ;

procedure TGIS_Shape.fset_Tag(
  const _value : NativeInt
) ;
begin
  FTag := _value ;
end ;

function TGIS_Shape.fget_Tag
  : NativeInt ;
begin
  Result := FTag ;
end ;

{$IFDEF MANAGED}
  procedure TGIS_Shape.fset_TagPointer(
    const _value : Object
  ) ;
{$ELSE}
  procedure TGIS_Shape.fset_TagPointer(
    const _value : Pointer
  ) ;
{$ENDIF}
begin
  FTagPointer := _value ;
end ;

{$IFDEF MANAGED}
  function TGIS_Shape.fget_TagPointer
    : Object ;
{$ELSE}
  function TGIS_Shape.fget_TagPointer
    : Pointer ;
{$ENDIF}
begin
  Result := FTagPointer ;
end ;

procedure TGIS_Shape.fset_TagInternal(
  const _value : NativeInt
) ;
begin
  FTagInternal := _value ;
end ;

function TGIS_Shape.fget_TagInternal
  : NativeInt ;
begin
  Result := FTagInternal ;
end ;

function TGIS_Shape.fget_Viewer
  : TGIS_ViewerRef ;
begin
  if assigned( Layer ) then
    Result := Layer.Viewer
  else
    Result := nil ;
end ;

procedure TGIS_Shape.fset_Layer(
  const _layer : TGIS_LayerVector
) ;
begin
  FLayer := _layer ;
end;

{$IFDEF MANAGED}
  function  TGIS_Shape.fget_Parts
    : TBytes ;
  var
    len : Integer ;
  begin
    len := PartsSize ;
    if len > 0 then begin
      SetLength( Result, PartsSize ) ;
      FParts.CopyTo( Result, 0, 0, PartsSize ) ;
    end
    else
      Result := nil ;
  end ;

  function  TGIS_Shape.fget_PartTypes
    : TBytes ;
  var
    len : Integer ;
  begin
    len := PartsSize ;
    if len > 0 then begin
      SetLength( Result, PartsSize ) ;
      if assigned( FPartTypes ) then
        FPartTypes.CopyTo( Result, 0, 0, PartsSize ) ;
    end
    else
      Result := nil ;
  end ;
{$ENDIF}

function TGIS_Shape.fget_PartsSize
  : Integer ;
begin
  if not IsEmpty then begin

    case self.ShapeType of
      TGIS_ShapeType.Polygon,
      TGIS_ShapeType.Arc,
      TGIS_ShapeType.MultiPatch :
         Result := OFFSET_NUM_POINTS +sizeOf(DWORD)*(GetNumParts +1) ;
      TGIS_ShapeType.Point :
         Result := 0 ;
      TGIS_ShapeType.MultiPoint :
         Result := OFFSET_NUM_POINTS ;
      else begin
           assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
           Result := 0 ;
         end ;
    end ;

  end
  else
    Result := 0;
end ;

{$IFDEF MANAGED}
  function  TGIS_Shape.fget_Points
    : TBytes ;
  begin
    SetLength( Result, PointsSize ) ;
    FPoints.CopyTo( Result, 0, 0, PointsSize ) ;
  end ;

  function  TGIS_Shape.fget_PointsZ
    : TBytes ;
  begin
    SetLength( Result, PointsZSize ) ;
    if assigned( FPointsZ ) then
      FPointsZ.CopyTo( Result, 0, 0, PointsZSize ) ;
  end ;

  function  TGIS_Shape.fget_PointsM
    : TBytes ;
  begin
    SetLength( Result, PointsMSize ) ;
    if assigned( FPointsM ) then
      FPointsM.CopyTo( Result, 0, 0, PointsMSize ) ;
  end ;
{$ENDIF}

function TGIS_Shape.fget_PointsSize
  : Integer ;
var
  sizeMax : Integer ;
begin
  if not IsEmpty then begin
    sizeMax := SIZEOF_TGIS_POINT ;

    Result := GetNumPoints * sizeMax;
  end
  else
    Result := 0;
end ;

function TGIS_Shape.fget_PointsZSize
  : Integer ;
begin
  if not IsEmpty then begin
    Result := GetNumPoints * sizeOf( Double );
  end
  else
    Result := 0;
end ;

function TGIS_Shape.fget_PointsMSize
  : Integer ;
begin
  if not IsEmpty then begin
    Result := GetNumPoints * sizeOf( Double );
  end
  else
    Result := 0;
end ;

function TGIS_Shape.fget_PointsZMin
  : Double ;
begin
  Result := FPointsZMin ;
end ;

function TGIS_Shape.fget_PointsZMax
  : Double ;
begin
  Result := FPointsZMax ;
end ;

function TGIS_Shape.fget_PointsMMin
  : Double ;
begin
  Result := FPointsMMin ;
end ;

function TGIS_Shape.fget_PointsMMax
  : Double ;
begin
  Result := FPointsMMax ;
end ;

function TGIS_Shape.fget_PartTypesSize
  : Integer ;
begin
  if not IsEmpty then begin

    case self.ShapeType of
      TGIS_ShapeType.Polygon,
      TGIS_ShapeType.Arc :
         Result := 0 ;
      TGIS_ShapeType.Point :
         Result := 0 ;
      TGIS_ShapeType.MultiPoint :
         Result := 0 ;
      TGIS_ShapeType.MultiPatch :
         Result := sizeOf(DWORD)*(GetNumParts) ;
      else begin
           assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
           Result := 0 ;
         end ;
    end ;
  end
  else
    Result := 0;
end ;

function TGIS_Shape.fget_GeometrySize
  : Integer ;
begin
  Result := PartsSize + PartTypesSize + PointsSize ;
end ;

function TGIS_Shape.fget_IsEditable
  : Boolean ;
begin
  Result := ( FIsEditable           )  or
            ( Uid = 0               )  or
            ( not assigned( Layer ) ) ;
end ;

function TGIS_Shape.checkIsEmpty
  : Boolean ;
begin
  Result := not assigned( FPoints ) ;
  if not Result then
    Result := ( GetNumParts = 0 ) or (GetNumPoints = 0);
end ;

function TGIS_Shape.fget_Params
  : TGIS_ParamsSectionVector ;
begin
  Result := FParams ;

  if not assigned( Result ) then begin
    if assigned( Layer ) then
      Result := TGIS_ParamsSectionVector( Layer.Params )
    else begin
      Result  := TGIS_ParamsSectionVector.Create ;
      FParams := Result ;
    end ;
  end
  else if assigned( Layer ) and Layer.bIgnoreShapeParams then
    Result  := TGIS_ParamsSectionVector( Layer.Params ) ;

  Result.Shape := self ;
end ;

procedure TGIS_Shape.fset_Params(
  const _value : TGIS_ParamsSectionVector
) ;
begin
  FreeObject( FParams ) ;
  FParams := TGIS_ParamsSectionVector.Create ;
  FParams.Assign( _value ) ;
end ;

function TGIS_Shape.fget_LocalParams
  : Boolean ;
begin
  Result := assigned( FParams ) ;
end ;

procedure TGIS_Shape.fset_LocalParams(
  const _value : Boolean
) ;
begin
  if _value then begin
    if ( not assigned( FParams ) ) then begin
      // allocate params
      FParams := TGIS_ParamsSectionVector.Create ;
      if assigned( Layer ) then
        FParams.Assign( Layer.Params ) ;
    end;
  end
  else begin
    // deallocate params
    FreeObject( FParams );
  end ;
end ;

function TGIS_Shape.fget_GeometryChanged
  : Boolean ;
begin
  Result := FIsEditable and FGeometryChanged ;
end ;

function TGIS_Shape.fget_FieldChanged
  : Boolean ;
begin
  Result := FIsEditable and
            ( assigned( mappedFields ) and ( mappedFields.Count > 0 ) ) ;
end ;

function TGIS_Shape.fget_IsSelected
  : Boolean ;
begin
  if assigned( Layer ) and ( Layer.SelectedList.Count > 0 ) then begin
    if ( Uid > 0 ) then
      Result := Layer.SelectedList.ContainsKey( Uid )
    else if assigned( FParent ) then
      Result := Layer.SelectedList.ContainsKey( FParent.Uid )
    else
      Result := False ;
  end
  else
    Result := False ;
end ;

procedure TGIS_Shape.fset_IsSelected(
  const _value : Boolean
) ;
begin
  if assigned( Layer ) then begin
    if not Layer.IsSupported( TGIS_OperationType.Select ) then exit ;

    if _value then begin
      if not Layer.SelectedList.ContainsKey( Uid ) then
        Layer.SelectedList.Add( Uid )
    end
    else
      Layer.SelectedList.Remove( Uid );

    Layer.InvalidateSelection ;
  end ;
end ;

function TGIS_Shape.fget_ManageRTree
  : Boolean ;
begin
  Result := assigned( Layer ) and
            Layer.UseRTree and
            ( IsMapped or FManageRTree ) ;
end ;

function TGIS_Shape.fget_Extent
  : TGIS_Extent ;
begin
  if IsEmpty then begin
    Result := GisNoWorld ;
    exit ;
  end
  else begin
    // this implementation is not valid for TGIS_Point
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Extent ;
      {$ENDIF}
      Result.XMin := FParts.ReadDouble( 0 * sizeOf( Double ) ) ;
      Result.YMin := FParts.ReadDouble( 1 * sizeOf( Double ) ) ;
      Result.XMax := FParts.ReadDouble( 2 * sizeOf( Double ) ) ;
      Result.YMax := FParts.ReadDouble( 3 * sizeOf( Double ) ) ;
    {$ELSE}
      Result.XMin := PDouble( NativeInt(FParts) + 0 * sizeOf( Double ) )^ ;
      Result.YMin := PDouble( NativeInt(FParts) + 1 * sizeOf( Double ) )^ ;
      Result.XMax := PDouble( NativeInt(FParts) + 2 * sizeOf( Double ) )^ ;
      Result.YMax := PDouble( NativeInt(FParts) + 3 * sizeOf( Double ) )^ ;
    {$ENDIF}

    if IsNan( Result.XMin ) then begin
      Result := GisNoWorld ;
    end ;
  end ;
end ;

function TGIS_Shape.fget_Extent3D
  : TGIS_Extent3D ;
begin
  Result := GisExtent3DFrom2D( Extent ) ;
  Result.ZMin := FPointsZMin ;
  Result.ZMax := FPointsZMax ;
  Result.MMin := FPointsMMin ;
  Result.MMax := FPointsMMax ;
end ;

function TGIS_Shape.fget_ProjectedExtent
  : TGIS_Extent ;
var
  ptg1, ptg2, ptg3, ptg4 : TGIS_Point ;
begin
  if assigned( Layer ) and ( Layer.MustReproject > 0 ) then begin
    if self.GetNumPoints = 0 then
      Result := GisNoWorld
    else begin
      ptg1 := Layer.Project( GisPoint( Extent.XMin, Extent.YMin ) ) ;
      ptg2 := Layer.Project( GisPoint( Extent.XMin, Extent.YMax ) ) ;
      ptg3 := Layer.Project( GisPoint( Extent.XMax, Extent.YMax ) ) ;
      ptg4 := Layer.Project( GisPoint( Extent.XMax, Extent.YMin ) ) ;
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Extent ;
      {$ENDIF}
      Result.XMin := Min( Min( Min( ptg1.X, ptg2.X ), ptg3.X ), ptg4.X ) ;
      Result.YMin := Min( Min( Min( ptg1.Y, ptg2.Y ), ptg3.Y ), ptg4.Y ) ;
      Result.XMax := Max( Max( Max( ptg1.X, ptg2.X ), ptg3.X ), ptg4.X ) ;
      Result.YMax := Max( Max( Max( ptg1.Y, ptg2.Y ), ptg3.Y ), ptg4.Y ) ;
    end ;
  end
  else
    Result := Extent ;
end ;

function TGIS_Shape.getPartOffset(
  _part : Integer
) : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  assert( GetNumParts > 0 ) ;
  {$IFDEF MANAGED}
    Result := FParts.ReadInt32( OFFSET_PARTS + _part * sizeOf( DWORD ) ) ;
  {$ELSE}
    Result := PInteger( NativeInt(FParts) + OFFSET_PARTS +
                        _part * sizeOf( DWORD ) )^
  {$ENDIF}
end ;

procedure TGIS_Shape.setPoint(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point
) ;
var
  ipos     : Integer ;
  partsize : Integer ;
  partoff  : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  partsize := GetPartSize(_part) ;
  if _pos < 0 then ipos := partsize
              else ipos := _pos ;

  reallocGeometry ;

  if lockMode = TGIS_Lock.None then
    setExtentByPoint( _ptg ) ;

  {$IFDEF MANAGED}
    partoff := getPartOffset( _part ) ;
  {$ELSE}
    partoff := PInteger( NativeInt(FParts) + OFFSET_PARTS +
                         _part * sizeOf( DWORD ) )^ ;
  {$ENDIF}

  {$IFDEF MANAGED}
    FPoints.WriteDouble( (partoff + ipos) * SIZEOF_TGIS_POINT,
                         _ptg.X
                       ) ;
    FPoints.WriteDouble( (partoff + ipos) * SIZEOF_TGIS_POINT +
                         sizeOf( Double ),
                         _ptg.Y
                       ) ;
  {$ELSE}
    PGIS_Point( NativeInt(FPoints) +
                ( (partoff + ipos) * SIZEOF_TGIS_POINT )
              ) ^  := _ptg;
  {$ENDIF}

  if ( _pos < 0 ) or (_pos >= partsize-1 ) then
    {$IFDEF MANAGED}
      FParts.Inc( OFFSET_NUM_POINTS ) ;
    {$ELSE}
      inc( PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
    {$ENDIF}

  FIsEmpty := False ;
end ;

procedure TGIS_Shape.setPoint3D(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point3D
) ;
var
  ipos     : Integer ;
  partsize : Integer ;
  partoff  : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  partsize := GetPartSize(_part) ;
  if _pos < 0 then ipos := partsize
              else ipos := _pos ;

  reallocGeometry ;

  if lockMode = TGIS_Lock.None then
    setExtentByPoint3D( _ptg ) ;

  {$IFDEF MANAGED}
    partoff := getPartOffset( _part ) ;
  {$ELSE}
    partoff := PInteger( NativeInt(FParts) + OFFSET_PARTS +
                         _part * sizeOf( DWORD ) )^ ;
  {$ENDIF}

  {$IFDEF MANAGED}
    FPoints.WriteDouble(
      (partoff + ipos) * SIZEOF_TGIS_POINT,
      _ptg.X
    ) ;
    FPoints.WriteDouble(
      (partoff + ipos) * SIZEOF_TGIS_POINT + sizeOf( Double ),
      _ptg.Y
    ) ;
    if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
      FPointsZ.WriteDouble( (partoff+ipos) * sizeOf(Double), _ptg.Z ) ;

    if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
      FPointsM.WriteDouble( (partoff+ipos) * sizeOf(Double), _ptg.M ) ;
  {$ELSE}
    PDouble(
      NativeInt(FPoints) +
      ( (partoff+ipos) * SIZEOF_TGIS_POINT )
    )^ := _ptg.X;
    PDouble(
      NativeInt(FPoints) +
      ( (partoff+ipos) * SIZEOF_TGIS_POINT ) + sizeOf( Double )
    )^ := _ptg.Y;

    if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
      PDouble(
        NativeInt(FPointsZ) +
        ( (partoff+ipos) * sizeOf(Double) )
      )^ := _ptg.Z;

    if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
      PDouble(
        NativeInt(FPointsM) +
        ( (partoff+ipos) * sizeOf(Double) )
      )^ := _ptg.M;
  {$ENDIF}

  if ( _pos < 0 ) or (_pos >= partsize-1 ) then
    {$IFDEF MANAGED}
      FParts.Inc( OFFSET_NUM_POINTS ) ;
    {$ELSE}
      inc( PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
    {$ENDIF}

  FIsEmpty := False ;
end ;

procedure TGIS_Shape.insertPoint(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point
) ;
var
  ipos     : Integer ;
  partsize : Integer ;
  partoff  : Integer ;
  maxpart  : Integer ;
  numpoints : Integer ;
  procedure move_points_up ; //to make place for inserted point
  var
    i : Integer ;
    {$IFDEF MANAGED}
      pt : TGIS_Point {$IFDEF GIS_NORECORDS} := new TGIS_Point {$ENDIF} ;
      po : Integer ;
    {$ENDIF}
  begin
    numpoints := GetNumPoints ;
    for i := numpoints downto partoff + ipos +1 do begin
    {$IFDEF MANAGED}
      po := (i -1) * SIZEOF_TGIS_POINT ;
      pt.X := FPoints.ReadDouble(po ) ;
      inc( po, sizeOf( Double ) ) ;
      pt.Y := FPoints.ReadDouble( po ) ;

      inc( po, sizeOf( Double ) ) ;
      FPoints.WriteDouble( po, pt.X ) ;
      inc( po, sizeOf( Double ) ) ;
      FPoints.WriteDouble( po , pt.Y ) ;
    {$ELSE}
      PGIS_Point( NativeInt(FPoints) +(i * SIZEOF_TGIS_POINT )) ^  :=
        PGIS_Point( NativeInt(FPoints) +((i -1) * SIZEOF_TGIS_POINT )) ^ ;
    {$ENDIF}
    end;
    for i := _part +1 to maxpart do begin //parts offsets correction
    {$IFDEF MANAGED}
      FParts.Inc(  OFFSET_PARTS + i * sizeOf( DWORD ) ) ;
    {$ELSE}
      inc( PInteger( NativeInt(FParts) + OFFSET_PARTS + i * sizeOf( DWORD ) )^ ) ;
    {$ENDIF}
    end;
  end;
begin

  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  partsize := GetPartSize(_part) ;
  if _pos < 0 then ipos := partsize
              else ipos := _pos ;

  reallocGeometry ;

  maxpart := GetNumParts -1 ;

  if lockMode = TGIS_Lock.None then
    setExtentByPoint( _ptg ) ;

  {$IFDEF MANAGED}
    partoff := getPartOffset( _part ) ;
  {$ELSE}
    partoff := PInteger( NativeInt(FParts) + OFFSET_PARTS +
                         _part * sizeOf( DWORD ) )^ ;
  {$ENDIF}

  if ( _part <> maxpart ) or ( ipos <> partsize ) then
    move_points_up ;

  {$IFDEF MANAGED}
    FPoints.WriteDouble( (partoff + ipos) * SIZEOF_TGIS_POINT,
                         _ptg.X
                       ) ;
    FPoints.WriteDouble( (partoff + ipos) * SIZEOF_TGIS_POINT +
                         sizeOf( Double ),
                         _ptg.Y
                       ) ;
  {$ELSE}
    PGIS_Point( NativeInt(FPoints) +
                ( (partoff + ipos) * SIZEOF_TGIS_POINT )
              ) ^  := _ptg;
  {$ENDIF}

  if ( _pos < 0 ) or (_pos >= partsize-1 ) then
    {$IFDEF MANAGED}
      FParts.Inc( OFFSET_NUM_POINTS ) ;
    {$ELSE}
      inc( PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
    {$ENDIF}

  FIsEmpty := False ;

end ;

procedure TGIS_Shape.insertPoint3D(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point3D
) ;
var
  ipos     : Integer ;
  partsize : Integer ;
  partoff  : Integer ;
  maxpart  : Integer ;
  numpoints : Integer ;
  procedure move_points_up ; //to make place for insetrted point
  var
    i : Integer ;
    {$IFDEF MANAGED}
      pt : TGIS_Point {$IFDEF GIS_NORECORDS} := new TGIS_Point {$ENDIF} ;
      po : Integer ;
      z, m : Double ;
    {$ENDIF}
  begin
    numpoints := GetNumPoints ;
    for i := numpoints downto partoff + ipos +1 do begin
    {$IFDEF MANAGED}
      po := (i -1) * SIZEOF_TGIS_POINT ;
      pt.X := FPoints.ReadDouble(po ) ;
      inc( po, sizeOf( Double ) ) ;
      pt.Y := FPoints.ReadDouble( po ) ;

      inc( po, sizeOf( Double ) ) ;
      FPoints.WriteDouble( po, pt.X ) ;
      inc( po, sizeOf( Double ) ) ;
      FPoints.WriteDouble( po , pt.Y ) ;
    {$ELSE}
      PGIS_Point( NativeInt(FPoints) +(i * SIZEOF_TGIS_POINT )) ^  :=
        PGIS_Point( NativeInt(FPoints) +((i -1) * SIZEOF_TGIS_POINT )) ^ ;
    {$ENDIF}
    end;

    if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
      for i := numpoints downto partoff + ipos +1 do begin
      {$IFDEF MANAGED}
        po := (i -1) * sizeOf(Double ) ;
        z := FPointsZ.ReadDouble(po ) ;
        inc( po, sizeOf( Double ) ) ;
        FPointsZ.WriteDouble( po, z ) ;
      {$ELSE}
        PDouble( NativeInt(FPointsZ) +(i * sizeOf(Double) )) ^  :=
          PDouble( NativeInt(FPointsZ) +((i -1) * sizeOf(Double) )) ^ ;
      {$ENDIF}
      end;
    end;

    if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
      for i := numpoints downto partoff + ipos +1 do begin
      {$IFDEF MANAGED}
        po := (i -1) * sizeOf(Double ) ;
        m := FPointsM.ReadDouble( po ) ;
        inc( po, sizeOf( Double ) ) ;
        FPointsM.WriteDouble( po, m ) ;
      {$ELSE}
        PDouble( NativeInt(FPointsM) +(i * sizeOf(Double) )) ^  :=
          PDouble( NativeInt(FPointsM) +((i -1) * sizeOf(Double) )) ^ ;
      {$ENDIF}
      end;
    end ;

    for i := _part +1 to maxpart do begin //parts offsets corection
    {$IFDEF MANAGED}
      FParts.Inc(  OFFSET_PARTS + i * sizeOf( DWORD ) ) ;
    {$ELSE}
      inc( PInteger( NativeInt(FParts) + OFFSET_PARTS + i * sizeOf( DWORD ) )^ ) ;
    {$ENDIF}
    end;
  end;
begin

  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  partsize := GetPartSize(_part) ;
  if _pos < 0 then ipos := partsize
              else ipos := _pos ;

  reallocGeometry ;

  maxpart := GetNumParts -1 ;

  if lockMode = TGIS_Lock.None then
    setExtentByPoint3D( _ptg ) ;

  {$IFDEF MANAGED}
    partoff := getPartOffset( _part ) ;
  {$ELSE}
    partoff := PInteger( NativeInt(FParts) + OFFSET_PARTS +
                         _part * sizeOf( DWORD ) )^ ;
  {$ENDIF}

  if ( _part <> maxpart ) or ( ipos <> partsize ) then
    move_points_up ;

  {$IFDEF MANAGED}
    FPoints.WriteDouble( (partoff + ipos) * SIZEOF_TGIS_POINT,
                         _ptg.X
                       ) ;
    FPoints.WriteDouble( (partoff + ipos) * SIZEOF_TGIS_POINT +
                         sizeOf( Double ),
                         _ptg.Y
                       ) ;
    if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
      FPointsZ.WriteDouble( (partoff+ipos) * sizeOf(Double), _ptg.Z ) ;

    if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
      FPointsM.WriteDouble( (partoff+ipos) * sizeOf(Double), _ptg.M ) ;
  {$ELSE}
    PDouble(
      NativeInt(FPoints) +
      ( (partoff+ipos) * SIZEOF_TGIS_POINT )
    )^ := _ptg.X;
    PDouble(
      NativeInt(FPoints) +
      ( (partoff+ipos) * SIZEOF_TGIS_POINT ) + sizeOf( Double )
    )^ := _ptg.Y;

    if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
      PDouble(
        NativeInt(FPointsZ) +
        ( (partoff+ipos) * sizeOf(Double) )
      )^ := _ptg.Z;

    if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
      PDouble(
        NativeInt(FPointsM) +
        ( (partoff+ipos) * sizeOf(Double) )
      )^ := _ptg.M;

  {$ENDIF}

  if ( _pos < 0 ) or (_pos >= partsize-1 ) then
    {$IFDEF MANAGED}
      FParts.Inc( OFFSET_NUM_POINTS ) ;
    {$ELSE}
      inc( PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
    {$ENDIF}

  FIsEmpty := False ;

end ;

procedure TGIS_Shape.deletePoint(
  const _part : Integer;
  const _pos  : Integer
) ;
var
  ipos     : Integer ;
  partsize : Integer ;
  partoff  : Integer ;
  maxpart  : Integer ;
  numpoints : Integer ;
  procedure move_points_down ; //to make place for insetrted point
  var
    i : Integer ;
    {$IFDEF MANAGED}
      pt : TGIS_Point {$IFDEF GIS_NORECORDS} := new TGIS_Point {$ENDIF} ;
      pi : Integer ;
      po : Integer ;
    {$ENDIF}
  begin
    numpoints := GetNumPoints ;
    for i := partoff + ipos + 1 to  numpoints -1  do begin
    {$IFDEF MANAGED}
      pi := i * SIZEOF_TGIS_POINT ;
      po := pi - SIZEOF_TGIS_POINT ;
      pt.X := FPoints.ReadDouble(po ) ;
      inc( po, sizeOf( Double ) ) ;
      pt.Y := FPoints.ReadDouble( po ) ;

      FPoints.WriteDouble( pi, pt.X ) ;
      inc( pi, sizeOf( Double ) ) ;
      FPoints.WriteDouble( pi , pt.Y ) ;
    {$ELSE}
      PGIS_Point( NativeInt(FPoints) +((i -1) * SIZEOF_TGIS_POINT )) ^  :=
        PGIS_Point( NativeInt(FPoints) +(i * SIZEOF_TGIS_POINT )) ^ ;
    {$ENDIF}
    end;
    for i := _part +1 to maxpart do begin //parts offsets corection
    {$IFDEF MANAGED}
      FParts.Dec(  OFFSET_PARTS + i * sizeOf( DWORD ) ) ;
    {$ELSE}
      dec( PInteger( NativeInt(FParts) + OFFSET_PARTS + i * sizeOf( DWORD ) )^ ) ;
    {$ENDIF}
    end;
  end;
begin
  if FIsEmpty then
    exit ;

  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  partsize := GetPartSize(_part) ;
  if _pos < 0 then ipos := partsize -1
              else ipos := _pos ;

  maxpart := GetNumParts -1 ;

  {$IFDEF MANAGED}
    partoff := getPartOffset( _part ) ;
  {$ELSE}
    partoff := PInteger( NativeInt(FParts) + OFFSET_PARTS +
                         _part * sizeOf( DWORD ) )^ ;
  {$ENDIF}

  if ( _part <> maxpart ) or ( ipos <> (partsize -1)) then
    move_points_down ;

  if ( _pos < 0 ) or (_pos <= partsize-1 ) then begin
    {$IFDEF MANAGED}
      FParts.Dec( OFFSET_NUM_POINTS ) ;
      if FParts.ReadInt32( OFFSET_NUM_POINTS ) = 0 then
        FIsEmpty := True ;

    {$ELSE}
      dec( PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
      if PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ = 0 then
        FIsEmpty := True ;
    {$ENDIF}
  end ;
end ;

procedure TGIS_Shape.deletePoint3D(
  const _part : Integer;
  const _pos  : Integer
) ;
var
  ipos     : Integer ;
  partsize : Integer ;
  partoff  : Integer ;
  maxpart  : Integer ;
  numpoints : Integer ;
  procedure move_points_down ; //to make place for insetrted point
  var
    i : Integer ;
    {$IFDEF MANAGED}
      pt : TGIS_Point {$IFDEF GIS_NORECORDS} := new TGIS_Point {$ENDIF} ;
      pi : Integer ;
      po : Integer ;
      z, m : Double ;
    {$ENDIF}
  begin
    numpoints := GetNumPoints ;
    for i := partoff + ipos + 1 to  numpoints -1  do begin
    {$IFDEF MANAGED}
      pi := i * SIZEOF_TGIS_POINT ;
      po := pi - SIZEOF_TGIS_POINT ;
      pt.X := FPoints.ReadDouble(po ) ;
      inc( po, sizeOf( Double ) ) ;
      pt.Y := FPoints.ReadDouble( po ) ;

      FPoints.WriteDouble( pi, pt.X ) ;
      inc( pi, sizeOf( Double ) ) ;
      FPoints.WriteDouble( pi , pt.Y ) ;
    {$ELSE}
      PGIS_Point( NativeInt(FPoints) +((i -1) * SIZEOF_TGIS_POINT )) ^  :=
        PGIS_Point( NativeInt(FPoints) +(i * SIZEOF_TGIS_POINT )) ^ ;
    {$ENDIF}
    end;

    if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
      for i := partoff + ipos + 1 to  numpoints -1  do begin
      {$IFDEF MANAGED}
        po := i  * sizeOf(Double ) ;
        z := FPointsZ.ReadDouble(po ) ;
        dec( po, sizeOf( Double ) ) ;
        FPointsZ.WriteDouble( po, z ) ;
      {$ELSE}
        PDouble( NativeInt(FPointsZ) +((i -1) * sizeOf(Double) )) ^  :=
          PDouble( NativeInt(FPointsZ) +(i * sizeOf(Double) )) ^ ;
      {$ENDIF}
      end;
    end;

    if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
      for i := partoff + ipos + 1 to  numpoints -1  do begin
      {$IFDEF MANAGED}
        po := i * sizeOf(Double ) ;
        m := FPointsM.ReadDouble(po ) ;
        dec( po, sizeOf( Double ) ) ;
        FPointsM.WriteDouble( po, m ) ;
      {$ELSE}
        PDouble( NativeInt(FPointsM) +((i -1)* sizeOf(Double) )) ^  :=
          PDouble( NativeInt(FPointsM) +(i * sizeOf(Double) )) ^ ;
      {$ENDIF}
      end;
    end ;

    for i := _part +1 to maxpart do begin //parts offsets corection
    {$IFDEF MANAGED}
      FParts.Dec(  OFFSET_PARTS + i * sizeOf( DWORD ) ) ;
    {$ELSE}
      dec( PInteger( NativeInt(FParts) + OFFSET_PARTS + i * sizeOf( DWORD ) )^ ) ;
    {$ENDIF}
    end;
  end;
begin
  if FIsEmpty then
    exit ;

  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  partsize := GetPartSize(_part) ;
  if _pos < 0 then ipos := partsize -1
              else ipos := _pos ;

  maxpart := GetNumParts -1 ;

  {$IFDEF MANAGED}
    partoff := getPartOffset( _part ) ;
  {$ELSE}
    partoff := PInteger( NativeInt(FParts) + OFFSET_PARTS +
                         _part * sizeOf( DWORD ) )^ ;
  {$ENDIF}

  if ( _part <> maxpart ) or ( ipos <> (partsize -1)) then
    move_points_down ;

  if ( _pos < 0 ) or (_pos <= partsize-1 ) then begin
    {$IFDEF MANAGED}
      FParts.Dec( OFFSET_NUM_POINTS ) ;
      if FParts.ReadInt32( OFFSET_NUM_POINTS ) = 0 then
        FIsEmpty := True ;

    {$ELSE}
      dec( PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
      if PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS)^ = 0 then
        FIsEmpty := True ;
    {$ENDIF}
  end ;
end ;

function TGIS_Shape.syncJoin
  : Boolean ;
begin
  Result := syncJoin( 0 ) ;
end ;

function TGIS_Shape.syncJoin(
  const _cursor : Integer
) : Boolean ;
var
  p_uid       : Variant    ;
  f_uid       : Variant    ;
  wasjoin     : Boolean    ;
  tmp         : TGIS_Uid    ;
  beof        : Boolean    ;
  reset_count : Integer    ;

    {$IFDEF CLR}
      dr        : IDataReader ;
      dt        : DataTable   ;
      i         : Integer     ;
    {$ENDIF}


  function vcmp(
    const _a, _b : Variant
  ) : Integer ; {$IFDEF GIS_INLINE} inline; {$ENDIF}
  begin
    {$IFDEF OXYGENE}
      if      VarIsEmpty( _a ) or VarIsNull( _a ) then
              begin
                if VarIsEmpty( _b ) or VarIsNull( _b ) then
                  Result :=  0
                else
                  Result := -1 ;
              end
      else if VarIsEmpty( _b ) or VarIsNull( _b ) then
              begin
                if VarIsEmpty( _a ) or VarIsNull( _a ) then
                  Result :=  0
                else
                  Result :=  1 ;
              end
      else    Result := VarCompareInt( _a, _b ) ;
    {$ELSE}
      if      _a < _b then Result := -1
      else if _a > _b then Result :=  1
      else                 Result :=  0
    {$ENDIF}
  end ;

  {$IFNDEF GIS_NODB}
    function resetjoin_db(
      const _full : Boolean
    ) : Boolean ;
    begin
      Result := False ;

      if reset_count > 0 then exit ;
      inc( reset_count ) ;

      Result := True ;

        with Layer do begin
          rJoin.Reset := True ;

          if _full then begin
            // basic optimization goes here
            // we are moving to the first record only when its really
            // important
            rJoin.ForeignDB := JoinDB.FieldByName( JoinForeign ) ;
            if not JoinDB.EOF then begin
               beof := False ;
               f_uid := ConvertDBFieldCP( rJoin.ForeignDB,
                                          JoinCodePage
                                        ) ;
               if vcmp( f_uid, p_uid ) <= 0 then rJoin.Reset := False ;
            end ;
          end ;

          if rJoin.Reset then begin
            JoinDB.First ;
            // rebind - few drivers are losing binging on MoveFirst
            rJoin.ForeignDB := JoinDB.FieldByName( JoinForeign ) ;

            rJoin.Reset := False      ;
            rJoin.Prev  := Unassigned ;
          end ;
        end ;
      end ;
    {$ENDIF}


      {$IFDEF CLR}
        function resetjoin_net(
          const _full : Boolean
        ) : Boolean ;
        var
          i1 : Integer ;
        begin
          Result := False ;

          if reset_count > 0 then exit ;
          inc( reset_count ) ;

          Result := True ;

          with Layer do begin
            rJoin.Reset := True ;

            if _full then begin
              // basic optimization goes here
              // we are moving to the first record only when its really
              // important
              if JoinNet is IDataReader then begin
                dr := JoinNET as IDataReader ;
                rJoin.ForeignRowNET := nil ;
                for i1 := 0 to dr.GetSchemaTable.Rows.Count do begin
                  if dr.GetSchemaTable.Rows[i1]['ColumnName'].ToString =
                     JoinForeign then
                  begin
                    rJoin.ForeignRowNET := dr.GetSchemaTable.Rows[i1] ;
                    break;
                  end ;
                end ;
                assert( assigned(rJoin.ForeignRowNET) ) ;
                if not dr.NextResult then begin
                   beof := False ;
                   f_uid := ConvertNETFieldCP( dr, rJoin.ForeignRowNET,
                                               JoinCodePage
                                             ) ;

                   if vcmp( f_uid, p_uid ) <= 0 then rJoin.Reset := False ;
                end ;
              end else if JoinNet is DataTable then begin
                dt := JoinNET as DataTable ;
                rJoin.ForeignColNET := dt.Columns[ JoinForeign ] ;
                if not ( rJoin.RowNET = dt.Rows.Count ) then begin
                   beof := False ;
                   f_uid := ConvertNETFieldCP( dt.Rows[rJoin.RowNET],
                                               rJoin.ForeignColNET,
                                               JoinCodePage
                                             ) ;

                   if vcmp( f_uid, p_uid ) <= 0 then rJoin.Reset := False ;
                end
              end ;
            end ;

            if rJoin.Reset then begin
              if JoinNet is IDataReader then begin
                dr := JoinNET as IDataReader ;
                dr.Read ;
                // rebind - few drivers are losing binging on MoveFirst
                for i1 := 0 to dr.GetSchemaTable.Rows.Count do begin
                  if dr.GetSchemaTable.Rows[i1]['ColumnName'].ToString =
                     JoinForeign
                  then
                    rJoin.ForeignRowNET := dr.GetSchemaTable.Rows[i1] ;
                end ;
              end else if JoinNET is DataTable then begin
                dt := JoinNET as DataTable ;
                rJoin.RowNET := 0 ;
                // rebind - few drivers are losing binging on MoveFirst
                rJoin.ForeignColNET := dt.Columns[ JoinForeign ] ;
              end ;
              rJoin.Reset := False      ;
              rJoin.Prev  := Unassigned ;
            end ;
          end ;
        end ;
      {$ENDIF}


    {$IFNDEF GIS_NOADO_JOIN}
      function resetjoin_ado(
        const _full : Boolean
      ) : Boolean ;
      begin
        Result := False ;

        if reset_count > 0 then exit ;
        inc( reset_count ) ;

        Result := True ;

        with Layer do begin
          rJoin.Reset := True ;

          if _full then begin
            // basic optimization goes here
            // we are moving to the first record only when its really
            // important
            rJoin.ForeignADO := _Recordset(Layer.JoinADO).Fields.Item[ JoinForeign ] ;
            if not _Recordset(Layer.JoinADO).EOF then begin
               beof := False ;
               f_uid := ConvertADOFieldCP( rJoin.ForeignADO,
                                           JoinCodePage
                                         ) ;

               if vcmp( f_uid, p_uid ) <= 0 then rJoin.Reset := False ;
            end ;
          end ;

          if rJoin.Reset then begin
            _Recordset(Layer.JoinADO).MoveFirst ;
            // rebind - few drivers are losing binging on MoveFirst
            rJoin.ForeignADO := _Recordset(Layer.JoinADO).Fields.Item[ JoinForeign ] ;
            rJoin.Reset := False      ;
            rJoin.Prev  := Unassigned ;
          end ;
        end ;
      end ;

      function synchronize_ado (
        _res : Boolean
      ) : Boolean ;
      begin
        Result := _res ;
        with Layer do begin
        try
          if not assigned( rJoin.ForeignADO ) then
            rJoin.ForeignADO := _Recordset(Layer.JoinADO).Fields.Item[ JoinForeign ] ;
          if rJoin.Primary < 0 then
            rJoin.Primary := bindField( JoinPrimary, _cursor ) ;
          p_uid := getBindedField( self, rJoin.Primary, _cursor ) ;

          if rJoin.Reset then
            resetjoin_ado( True ) ;

          // unordered layer? unsure that whole join will be done
          if vcmp( rJoin.Prev, p_uid ) > 0 then
            resetjoin_ado( False ) ;

          while not _Recordset(Layer.JoinADO).EOF do begin
            beof := False ;

            f_uid := ConvertADOFieldCP(
                       rJoin.ForeignADO,
                       JoinCodePage
                     ) ;

            // foreign synchronized?
            if vcmp( f_uid, p_uid ) >= 0 then
              break ;

            _Recordset(Layer.JoinADO).MoveNext ;

            beof := True ;
          end ;

          rJoin.Prev := p_uid ;

          // not found!
          if beof or ( vcmp( f_uid, p_uid ) <> 0 ) then begin
            Result        := False ;
            rJoin.LastUid := -1    ;
            exit ;
          end ;

        except
          Result := False ;
          rJoin.Active := False ;
        end ;
        end ;
      end;
    {$ENDIF}

    {$IFNDEF GIS_NOJDBC}
      function resetjoin_JDBC(
        const _full : Boolean
      ) : Boolean ;
      begin
        Result := False ;

        if reset_count > 0 then exit ;
        inc( reset_count ) ;

        Result := True ;

        with Layer do begin
          rJoin.Reset := True ;

          if _full then begin
            // basic optimization goes here
            // we are moving to the first record only when its really
            // important
            rJoin.ForeignJDBC := java.sql.ResultSet(Layer.JoinJDBC).getString(JoinForeign) ;
            if not (java.sql.ResultSet(Layer.JoinJDBC).isAfterLast) then begin
               beof := False ;
               f_uid := ConvertJDBCFieldCP( rJoin.ForeignJDBC,
                                           JoinCodePage
                                         ) ;

               if vcmp( f_uid, p_uid ) <= 0 then rJoin.Reset := False ;
            end ;
          end ;

          if rJoin.Reset then begin
        //?    if java.sql.ResultSet(Layer.JoinJDBC).Type = java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE then
        //?      while java.sql.ResultSet(Layer.JoinJDBC).previous do begin
        //?        // do nothing
        //?      end
        //?    else
            Layer.JoinJDBC := java.sql.ResultSet(Layer.JoinJDBC).Statement.executeQuery(Layer.JoinJDBCQuery);
            // rebind - few drivers are losing binging on MoveFirst
            java.sql.ResultSet(Layer.JoinJDBC).next;
            rJoin.ForeignJDBC := java.sql.ResultSet(Layer.JoinJDBC).getString(JoinForeign)  ;

            rJoin.Reset := False      ;
            rJoin.Prev  := Unassigned ;
          end ;
        end ;
      end ;

      function synchronize_JDBC (
        _res : Boolean
      ) : Boolean ;
      var
        i : Integer;
      begin
        Result := _res ;
        with Layer do begin
        try
          if not assigned( rJoin.ForeignJDBC ) then begin
            rJoin.ForeignJDBC := java.sql.ResultSet(Layer.JoinJDBC).getString(JoinForeign) ;
          end;
          if rJoin.Primary < 0 then
            rJoin.Primary := bindField( JoinPrimary, _cursor ) ;
          p_uid := getBindedField( self, rJoin.Primary, _cursor ) ;

          if rJoin.Reset then
            resetjoin_JDBC( True ) ;

          // unordered layer? unsure that whole join will be done
          if vcmp( rJoin.Prev, p_uid ) > 0 then
            resetjoin_JDBC( False ) ;
          while not java.sql.ResultSet(Layer.JoinJDBC).isAfterLast do begin
            beof := False ;

            f_uid := ConvertJDBCFieldCP(
                       rJoin.ForeignJDBC,
                       JoinCodePage
                     ) ;

            // foreign synchronized?
            if vcmp( f_uid, p_uid ) >= 0 then
              break ;

            java.sql.ResultSet(Layer.JoinJDBC).next;
            rJoin.ForeignJDBC := java.sql.ResultSet(Layer.JoinJDBC).getString(JoinForeign) ;

            beof := True ;
          end ;
          // synch fields, we don't have pointers like in delphi
          for i := 1 to rJoin.Columns.length - 1 do begin
            if not (rJoin.Columns[i] = 0) then begin
              rJoin.FieldsJDBC[ i ] := java.sql.ResultSet(Layer.JoinJDBC).getString(rJoin.Columns[i]) ;
            end;
          end;
          rJoin.Prev := p_uid ;


          // not found!
          if beof or ( vcmp( f_uid, p_uid ) <> 0 ) then begin
            Result        := False ;
            rJoin.LastUid := -1    ;
            exit ;
          end ;

        except
          Result := False ;
          rJoin.Active := False ;
        end ;
        end ;
      end;
  {$ENDIF}
  begin
    Result := True ;
    beof   := True ;
    f_uid  := Unassigned ;
    p_uid  := Unassigned ;

    reset_count := 0 ;


    with Layer do begin

      tmp := Uid ;
      if tmp = rJoin.LastUid then exit // don't synchronize already synchronized
                             else rJoin.LastUid := tmp ;

      if not rJoin.Active then begin
        Result        := False ;
        rJoin.LastUid := -1    ;
        exit ;
      end ;

      wasjoin := False ;


      {$IFNDEF GIS_NODB}
        if ( not wasjoin ) and assigned( Layer.JoinDB ) then begin
          wasjoin := True ;
          try
            if not assigned( rJoin.ForeignDB ) then
              rJoin.ForeignDB := JoinDB.FieldByName( JoinForeign ) ;

            if rJoin.Primary < 0 then
               rJoin.Primary := bindField( JoinPrimary, _cursor ) ;
            p_uid := getBindedField( self, rJoin.Primary, _cursor ) ;

            if rJoin.Reset then
              resetjoin_db( True ) ;

            // unordered layer? unsure that whole join will be done
            if vcmp( rJoin.Prev, p_uid ) > 0 then
              resetjoin_db( False ) ;

            while not JoinDB.EOF do begin
              beof := False ;

              f_uid := ConvertDBFieldCP( rJoin.ForeignDB,
                                         JoinCodePage
                                       ) ;

              // foreign synchronized?
              if vcmp( f_uid, p_uid ) >= 0 then
                break ;

              Layer.JoinDB.Next ;

              beof := True ;
            end ;

            rJoin.Prev := p_uid ;

            // not found?
            if beof or ( vcmp( f_uid, p_uid ) <> 0 ) then begin
              Result        := False ;
              rJoin.LastUid := -1    ;
              exit ;
            end ;
          except
            Result       := False ;
            rJoin.Active := False ;
          end ;
        end ;
      {$ENDIF}


        {$IFDEF CLR}
          if ( not wasjoin ) and assigned ( JoinNET ) then begin
            wasjoin := True ;
            if JoinNET is IDataReader then begin
              dr := JoinNET as IDataReader ;
              try
                if not assigned( rJoin.ForeignRowNET ) then
                  for i := 0 to dr.GetSchemaTable.Rows.Count do begin
                    if dr.GetSchemaTable.Rows[i]['ColumnName'].ToString =
                       JoinForeign
                    then begin
                      rJoin.ForeignRowNET := dr.GetSchemaTable.Rows[i] ;
                      break ;
                    end ;
                  end ;
                assert( assigned( rJoin.ForeignRowNET ) ) ;

                if rJoin.Primary < 0 then
                  rJoin.Primary := bindField( JoinPrimary, _cursor ) ;
                p_uid := getBindedField( self, rJoin.Primary, _cursor ) ;

                if rJoin.Reset then
                  resetjoin_net( True ) ;

                // unordered layer? unsure that whole join will be done
                if vcmp( rJoin.Prev, p_uid ) > 0 then
                  resetjoin_net( False ) ;

                while dr.NextResult do begin
                  beof := False ;

                  f_uid := ConvertNETFieldCP(
                             dr, rJoin.ForeignRowNET,
                             JoinCodePage
                           ) ;

                  // foreign synchronized?
                  if vcmp( f_uid, p_uid ) >= 0 then
                    break ;

                  dr.Read ;

                  beof := True ;
                end ;

                rJoin.Prev := p_uid ;

                // not found?
                if beof or ( vcmp( f_uid, p_uid ) <> 0 ) then begin
                  Result        := False ;
                  rJoin.LastUid := -1    ;
                  exit ;
                end ;

              except
                Result := False ;
                rJoin.Active := False ;
              end ;
            end
            else if JoinNET is DataTable then begin
              dt := JoinNET as DataTable ;
              try
                if not assigned( rJoin.ForeignColNET ) then
                  rJoin.ForeignColNET := dt.Columns[ JoinForeign ] ;

                if rJoin.Primary < 0 then
                  rJoin.Primary := bindField( JoinPrimary, _cursor ) ;
                p_uid := getBindedField( self, rJoin.Primary, _cursor ) ;

                if rJoin.Reset then
                  resetjoin_net( True ) ;

                // unordered layer? unsure that whole join will be done
                if vcmp( rJoin.Prev, p_uid ) > 0 then
                  resetjoin_net( False ) ;

                while not ( rJoin.RowNET = dt.Rows.Count ) do begin
                  beof := False ;

                  f_uid := ConvertNETFieldCP(
                             dt.Rows[rJoin.RowNET],
                             rJoin.ForeignColNET,
                             JoinCodePage
                           ) ;

                  // foreign synchronized?
                  if vcmp( f_uid, p_uid ) >= 0 then
                    break ;

                  inc( rJoin.RowNET ) ;

                  beof := True ;
                end ;

                rJoin.Prev := p_uid ;

                // not found?
                if beof or ( vcmp( f_uid, p_uid ) <> 0 ) then begin
                  Result        := False ;
                  rJoin.LastUid := -1    ;
                  exit ;
                end ;

              except
                Result := False ;
                rJoin.Active := False ;
              end ;
            end ;
          end;
        {$ENDIF}


      {$IFNDEF GIS_NOADO_JOIN}
        if ( not wasjoin ) and assigned( JoinADO )  then begin
          wasjoin := True ;
          Result := synchronize_ado ( Result ) ;
        end ;
      {$ENDIF }
      {$IFNDEF GIS_NOJDBC}
        if ( not wasjoin ) and assigned( JoinJDBC )  then begin
          wasjoin := True ;
          Result := synchronize_JDBC ( Result ) ;
        end ;
      {$ENDIF}

      if not wasjoin then begin
        Result        := False ;
        rJoin.LastUid := -1    ;
        rJoin.Active  := False ;
        {$IFNDEF GIS_NOADO}
          {$IFDEF CLR}
            rJoin.RowNET  := 0 ;
          {$ENDIF}
        {$ENDIF}
        exit ;
      end ;
    end ;
end ;

{$IFDEF MANAGED}
  procedure TGIS_Shape.prepareGeometry(
    const _ptr : TGIS_Bytes
  ) ;
{$ELSE}
  procedure TGIS_Shape.prepareGeometry(
    const _ptr : Pointer
  )  ;
{$ENDIF}
var
  offZ  : Integer ;
  ptoff : Integer ;
begin
  case self.ShapeType of
    TGIS_ShapeType.MultiPatch,
    TGIS_ShapeType.Polygon,
    TGIS_ShapeType.Arc        :
      begin
        {$IFDEF MANAGED}
          FParts  := TGIS_Bytes.Create(
                       _ptr.Memory,
                       _ptr.Position
                     ) ;
        {$ELSE}
          FParts  := _ptr ;
        {$ENDIF}
        {$IFDEF MANAGED}
          if self.ShapeType = TGIS_ShapeType.MultiPatch then begin
            ptoff := sizeOf(DWORD)*(FParts.ReadInt32(OFFSET_NUM_PARTS)) ;
            FPartTypes := TGIS_Bytes.Create(
                               _ptr.Memory,
                               _ptr.Position + OFFSET_NUM_POINTS +
                               sizeOf(DWORD)*( FParts.ReadInt32(OFFSET_NUM_PARTS) + 1 )
                             ) ;
          end
          else begin
            ptoff := 0 ;
            FPartTypes := nil ;
          end ;

          FPoints := TGIS_Bytes.Create(
                       _ptr.Memory,
                       _ptr.Position +
                       OFFSET_NUM_POINTS +
                       sizeOf(DWORD) *
                       ( FParts.ReadInt32(OFFSET_NUM_PARTS) + 1 ) + ptoff
                      ) ;

          if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
            FPointsZ    := TGIS_Bytes.Create(
                             _ptr.Memory,
                             _ptr.Position +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               FParts.ReadInt32(OFFSET_NUM_PARTS) + 1
                             ) + ptoff+
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 )
                           ) ;
            FPointsZMin := _ptr.ReadDouble(
                             _ptr.Position +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               FParts.ReadInt32(OFFSET_NUM_PARTS) + 1
                             ) + ptoff+
                             SIZEOF_TGIS_POINT*( GetNumPoints )
                           ) ;
            FPointsZMax := _ptr.ReadDouble(
                             _ptr.Position +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               FParts.ReadInt32(OFFSET_NUM_PARTS) + 1
                             ) + ptoff+
                             SIZEOF_TGIS_POINT*( GetNumPoints )+
                             sizeOf( Double )
                           ) ;
            offZ := sizeOf( Double )*( GetNumPoints + 1 ) + sizeOf( Double ) ;
          end
          else begin
            FPointsZ := nil ;
            offZ     := 0 ;
          end ;

          if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
            FPointsM    := TGIS_Bytes.Create(
                             _ptr.Memory,
                             _ptr.Position +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               FParts.ReadInt32(OFFSET_NUM_PARTS) + 1
                             ) + ptoff+
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 )+
                             offZ
                           ) ;
            FPointsMMin := _ptr.ReadDouble(
                             _ptr.Position +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               FParts.ReadInt32(OFFSET_NUM_PARTS) + 1
                             ) + ptoff+
                             SIZEOF_TGIS_POINT*( GetNumPoints )+
                             offZ
                           ) ;
            FPointsMMax := _ptr.ReadDouble(
                             _ptr.Position +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               FParts.ReadInt32(OFFSET_NUM_PARTS) + 1
                             ) + ptoff+
                             SIZEOF_TGIS_POINT*( GetNumPoints )+
                             offZ +  sizeOf( Double )
                           ) ;
          end
          else
            FPointsM := nil ;
        {$ELSE}
          if self.ShapeType = TGIS_ShapeType.MultiPatch then begin
            ptoff := sizeOf(DWORD)*(PInteger(NativeInt(FParts)+OFFSET_NUM_PARTS)^) ;
            FPartTypes := Pointer(
                             NativeInt( _ptr ) +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD)*(
                               PInteger(
                                 NativeInt(FParts) + OFFSET_NUM_PARTS
                               )^ +1
                             )
                           ) ;
          end
          else begin
            ptoff := 0 ;
            FPartTypes := nil ;
          end ;

          FPoints := Pointer(
                       NativeInt( _ptr ) +
                       OFFSET_NUM_POINTS +
                       sizeOf(DWORD)*(
                         PInteger(
                           NativeInt(FParts) + OFFSET_NUM_PARTS
                         )^ +1
                       ) + ptoff
                     ) ;

          if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
          begin
            FPointsZ    := Pointer(
                             NativeInt( _ptr ) +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               PInteger(
                                 NativeInt(FParts) + OFFSET_NUM_PARTS
                               )^ + 1
                             ) + ptoff +
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 )
                           ) ;
            FPointsZMin := PDouble( NativeInt( _ptr ) +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               PInteger(
                                 NativeInt(FParts) + OFFSET_NUM_PARTS
                               )^ + 1
                             ) + ptoff +
                             SIZEOF_TGIS_POINT*( GetNumPoints )
                           )^ ;
            FPointsZMax := PDouble( NativeInt( _ptr ) +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               PInteger(
                                 NativeInt(FParts) + OFFSET_NUM_PARTS
                               )^ +1
                             ) + ptoff +
                             SIZEOF_TGIS_POINT*( GetNumPoints ) +
                             sizeOf( Double )
                           )^ ;
            offZ := sizeOf( Double )*( GetNumPoints + 1 ) + sizeOf( Double );
          end
          else begin
            FPointsZ := nil ;
            offZ     := 0 ;
          end ;

          if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
          begin
            FPointsM    := Pointer(
                             NativeInt( _ptr ) +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               PInteger(
                                 NativeInt(FParts) +
                                 OFFSET_NUM_PARTS
                               )^ + 1
                             ) + ptoff +
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 ) +
                             offZ
                           ) ;
            FPointsMMin := PDouble( NativeInt( _ptr ) +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               PInteger(
                                 NativeInt(FParts) +
                                 OFFSET_NUM_PARTS
                               )^ + 1
                             ) + ptoff +
                             SIZEOF_TGIS_POINT*( GetNumPoints ) +
                            offZ
                           )^ ;
            FPointsMMax := PDouble( NativeInt( _ptr ) +
                             OFFSET_NUM_POINTS +
                             sizeOf(DWORD) * (
                               PInteger(
                                 NativeInt(FParts) +
                                 OFFSET_NUM_PARTS
                               )^ +1
                             ) + ptoff +
                             SIZEOF_TGIS_POINT*( GetNumPoints ) +
                             offZ +  sizeOf( Double )
                           )^ ;
          end
          else
            FPointsM := nil ;
        {$ENDIF}
      end ;
    TGIS_ShapeType.Point      :
      begin
        FParts  := nil ;
        {$IFDEF MANAGED}
          FPoints := TGIS_Bytes.Create( _ptr.Memory,
                                        _ptr.Position
                                       ) ;
        {$ELSE}
          FPoints := _ptr ;
        {$ENDIF}
      end ;
    TGIS_ShapeType.MultiPoint :
      begin
        {$IFDEF MANAGED}
          FParts  := TGIS_Bytes.Create( _ptr.Memory,
                                        _ptr.Position
                                       ) ;
        {$ELSE}
          FParts  := _ptr ;
        {$ENDIF}
        {$IFDEF MANAGED}
          FPoints := TGIS_Bytes.Create( _ptr.Memory,
                                        _ptr.Position + OFFSET_NUM_POINTS
                                       ) ;

          if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
            FPointsZ    := TGIS_Bytes.Create(
                             _ptr.Memory,
                             _ptr.Position + OFFSET_NUM_POINTS+
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 )
                           ) ;
            FPointsZMin := _ptr.ReadDouble(
                              _ptr.Position + OFFSET_NUM_POINTS+
                              SIZEOF_TGIS_POINT*( GetNumPoints )
                           ) ;
            FPointsZMax := _ptr.ReadDouble(
                             _ptr.Position + OFFSET_NUM_POINTS+
                             SIZEOF_TGIS_POINT*( GetNumPoints )+
                             sizeOf( Double )
                           ) ;
            offZ := sizeOf( Double )*( GetNumPoints + 1 ) +  sizeOf( Double );
          end
          else begin
            FPointsZ := nil ;
            offZ     := 0 ;
          end ;

          if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
            FPointsM    := TGIS_Bytes.Create(
                             _ptr.Memory,
                             _ptr.Position + OFFSET_NUM_POINTS+
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 ) +
                             offZ
                           ) ;
            FPointsMMin := _ptr.ReadDouble(
                              _ptr.Position + OFFSET_NUM_POINTS+
                              SIZEOF_TGIS_POINT*( GetNumPoints ) +
                              offZ
                            );
            FPointsMMax := _ptr.ReadDouble(
                             _ptr.Position + OFFSET_NUM_POINTS+
                             SIZEOF_TGIS_POINT*( GetNumPoints ) +
                             offZ + sizeOf( Double )
                           );
          end
          else
            FPointsM := nil ;
        {$ELSE}
          FPoints := Pointer( NativeInt( _ptr ) + OFFSET_NUM_POINTS ) ;

          if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
          begin
            FPointsZ    := Pointer(
                             NativeInt( _ptr ) + OFFSET_NUM_POINTS +
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 )
                           ) ;
            FPointsZMin := PDouble(
                             NativeInt( _ptr ) + OFFSET_NUM_POINTS +
                             SIZEOF_TGIS_POINT*( GetNumPoints )
                           )^;
            FPointsZMax := PDouble(
                             NativeInt( _ptr ) + OFFSET_NUM_POINTS +
                             SIZEOF_TGIS_POINT*( GetNumPoints ) +
                             sizeOf( Double )
                           )^;
            offZ := sizeOf( Double )*( GetNumPoints + 1 ) +  sizeOf( Double );
          end
          else begin
            FPointsZ := nil ;
            offZ     := 0 ;
          end ;

          if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
          begin
            FPointsM    := Pointer(
                             NativeInt( _ptr ) + OFFSET_NUM_POINTS +
                             SIZEOF_TGIS_POINT*( GetNumPoints + 1 ) +
                             offZ
                           ) ;
            FPointsMMin := PDouble(
                             NativeInt( _ptr ) + OFFSET_NUM_POINTS +
                             SIZEOF_TGIS_POINT*( GetNumPoints ) +
                             offZ
                           )^ ;
            FPointsMMax := PDouble(
                             NativeInt( _ptr ) + OFFSET_NUM_POINTS +
                             SIZEOF_TGIS_POINT*( GetNumPoints ) +
                             offZ + sizeOf( Double )
                           )^ ;
          end
          else
            FPointsM := nil ;
        {$ENDIF}
      end ;
    else
      assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
  end ;
end ;

function TGIS_Shape.CreateCopy
  : TGIS_Shape ;
begin
  {$IFDEF DCC}
     Result := TGIS_ShapeClass( self.ClassType ).Create(
                self, nil, False, 0, nil, FDimension
              ) ;
  {$ENDIF}
  {$IFDEF OXYGENE}
    Result := TGIS_ShapeClass( self.GetMetaClass ).Create(
                self, nil, False, 0, nil, FDimension
              ) ;
  {$ENDIF}

  Result.unmapGeometry ;
end;

function TGIS_Shape.CreateCopyCS(
  const _cs   : TGIS_CSCoordinateSystem
) : TGIS_Shape ;
begin
  if not assigned( Layer ) then
    Result := self.CreateCopy
  else
    Result := TGIS_GeometryFactory.GisCreateReprojectedShape( self, Layer.CS, _cs ) ;
end;

function TGIS_Shape.PrepareExportShape(
  const _cs        : TGIS_CSCoordinateSystem ;
  const _extent    : TGIS_Extent             ;
  const _truncate  : Boolean                 ;
  const _copyfield : Boolean
 ) : TGIS_Shape ;
var
  shp_tmp  : TGIS_Shape ;
  shp_tmp2 : TGIS_Shape ;
begin
  if _truncate then
    shp_tmp := Self.GetIntersection( _extent )
  else
    shp_tmp := Self ;

  if assigned( Layer )                    and
     assigned( shp_tmp )                  and
     ( self.Layer.CS.CanConvert( _cs )    or
       ( assigned( self.Layer.Transform ) and
         self.Layer.Transform.Active
       )
     )
  then begin
    shp_tmp2 := shp_tmp.CreateCopyCS( _cs ) ;
    if shp_tmp <> Self then begin
      FreeObject( shp_tmp ) ;
    end;
  end
  else
    shp_tmp2 := shp_tmp ;

  if _copyfield and assigned( shp_tmp2 ) and ( shp_tmp2 <> Self ) then begin
    shp_tmp2.Layer := Layer ;
    shp_tmp2.CopyFields( Self ) ;
  end;

  Result := shp_tmp2 ;
end;

procedure TGIS_Shape.duplicateGeometry ;
var
  size       : Integer ;
  fullsize   : Integer ;
  {$IFDEF MANAGED}
  {$ELSE}
    ptr_tmp  : Pointer ;
  {$ENDIF}
begin
  if IsEmpty then exit ;

  if assigned( FParts ) then begin
    size := PartsSize ;
    fullsize := ( (size div PARTS_CHUNK_SIZE) + 1 ) * PARTS_CHUNK_SIZE ;
    if (fullsize - size) <= sizeOf( DWORD ) then
      fullsize := fullsize + PARTS_CHUNK_SIZE ;
    {$IFDEF MANAGED}
      FParts.Recreate( 0, size, fullsize ) ;
    {$ELSE}
      GetMem( ptr_tmp, fullsize) ;
      System.Move( FParts^, ptr_tmp^, size) ;
      FParts := ptr_tmp ;
    {$ENDIF}
  end ;

  if assigned( FPartTypes ) then begin
    size := PartTypesSize ;
    fullsize := ( (size div PARTS_CHUNK_SIZE) + 1 ) * PARTS_CHUNK_SIZE ;
    if (fullsize - size) <= sizeOf( DWORD ) then
      fullsize := fullsize + PARTS_CHUNK_SIZE ;
    {$IFDEF MANAGED}
      FPartTypes.Recreate( 0, size, fullsize ) ;
    {$ELSE}
      GetMem( ptr_tmp, fullsize) ;
      System.Move( FPartTypes^, ptr_tmp^, size) ;
      FPartTypes := ptr_tmp ;
    {$ENDIF}
  end ;

  size := PointsSize ;
  if size <> 0 then begin
    if ( self is TGIS_ShapePoint ) then begin
      if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        inc( size, PointsZSize ) ;
      if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        inc( size, PointsMSize ) ;
    end;
    fullsize := ( (size div POINTS_CHUNK_SIZE) + 1 ) * POINTS_CHUNK_SIZE ;

    if (fullsize - size) <= SIZEOF_TGIS_POINT3D then
       fullsize := fullsize + POINTS_CHUNK_SIZE ;

    {$IFDEF MANAGED}
      FPoints.Recreate( 0, size, fullsize );
    {$ELSE}
      GetMem( ptr_tmp, fullsize) ;
      System.Move( FPoints^, ptr_tmp^, size) ;
      FPoints := ptr_tmp ;
    {$ENDIF}
  end ;

  if assigned( FPointsZ ) and
     ( FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] ) then begin

    size := PointsZSize ;
    if size <> 0 then begin
      fullsize := ( (size div POINTS_CHUNK_SIZE) + 1 ) * POINTS_CHUNK_SIZE ;
      if (fullsize - size) <= sizeOf(Double) then
         fullsize := fullsize + POINTS_CHUNK_SIZE ;

      {$IFDEF MANAGED}
        FPointsZ.Recreate( 0, size, fullsize );
      {$ELSE}
        GetMem( ptr_tmp, fullsize) ;
        System.Move( FPointsZ^, ptr_tmp^, size) ;
        FPointsZ := ptr_tmp ;
      {$ENDIF}
    end ;
  end;

  if assigned( FPointsM ) and
     ( FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] ) then begin

    size := PointsMSize ;
    if size <> 0 then begin
      fullsize := ( (size div POINTS_CHUNK_SIZE) + 1 ) * POINTS_CHUNK_SIZE ;
      if (fullsize - size) <= sizeOf(Double) then
         fullsize := fullsize + POINTS_CHUNK_SIZE ;

      {$IFDEF MANAGED}
        FPointsM.Recreate( 0, size, fullsize );
      {$ELSE}
        GetMem( ptr_tmp, fullsize) ;
        System.Move( FPointsM^, ptr_tmp^, size) ;
        FPointsM := ptr_tmp ;
      {$ENDIF}
    end ;
  end;

end ;

procedure TGIS_Shape.unmapGeometry ;
begin
  if IsMapped and (not IsEmpty) then begin
    duplicateGeometry ;
    FIsMapped := False ;
  end ;
end ;

procedure TGIS_Shape.reallocGeometry ;
var
  size, fullsize, sizeMax : Integer ;
begin
  if assigned( FParts ) then begin
    size := PartsSize ;
    {$IFDEF MANAGED}
      fullsize := high( FParts.Memory ) ;
      if fullsize > 0 then begin
        if fullsize - size <= sizeOf(DWORD) then begin
          FParts.ReallocMem( Max( PARTS_CHUNK_SIZE, fullsize * 3 div 2 ) ) ;
        end ;
      end
      else begin
        FParts := TGIS_Bytes.Create( PARTS_CHUNK_SIZE ) ;
      end ;
    {$ELSE}
      fullsize := ( (size div PARTS_CHUNK_SIZE) + 1 ) * PARTS_CHUNK_SIZE ;
      if (fullsize - size) <= sizeOf(DWORD) then begin
        fullsize := fullsize + PARTS_CHUNK_SIZE ;
        ReallocMem( FParts, fullsize ) ;
      end ;
    {$ENDIF}
  end
  else begin
    {$IFDEF MANAGED}
      begin
        FParts := TGIS_Bytes.Create( PARTS_CHUNK_SIZE ) ;
      end ;
    {$ELSE}
      ReallocMem( FParts, PARTS_CHUNK_SIZE ) ;
    {$ENDIF}
  end ;

  if ShapeType = TGIS_ShapeType.MultiPatch then begin

    if assigned( FPartTypes ) then begin
      size := PartTypesSize ;
      {$IFDEF MANAGED}
        fullsize := high( FPartTypes.Memory ) ;
        if fullsize > 0 then begin
          if fullsize - size <= sizeOf(DWORD) then begin
            FPartTypes.ReallocMem( Max( PARTS_CHUNK_SIZE, fullsize * 3 div 2 ) ) ;
          end ;
        end
        else begin
          FPartTypes := TGIS_Bytes.Create( PARTS_CHUNK_SIZE ) ;
        end ;
      {$ELSE}
        fullsize := ( (size div PARTS_CHUNK_SIZE) + 1 ) * PARTS_CHUNK_SIZE ;
        if (fullsize - size) <= sizeOf(DWORD) then begin
          fullsize := fullsize + PARTS_CHUNK_SIZE ;
          ReallocMem( FPartTypes, fullsize ) ;
        end ;
      {$ENDIF}
    end
    else begin
      {$IFDEF MANAGED}
        begin
          FPartTypes := TGIS_Bytes.Create( PARTS_CHUNK_SIZE ) ;
        end ;
      {$ELSE}
        ReallocMem( FPartTypes, PARTS_CHUNK_SIZE ) ;
      {$ENDIF}
    end ;
  end ;

  if assigned( FPoints ) then begin
    size := PointsSize ;
    {$IFDEF MANAGED}
      fullsize := high( FPoints.Memory ) ;
      if fullsize > 0 then begin

        sizeMax  := SIZEOF_TGIS_POINT ;

        if ShapeType = TGIS_ShapeType.Point then begin
          if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
            inc( sizeMax, sizeOf( Double ) ) ;
          if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
            inc( sizeMax, sizeOf( Double ) ) ;
        end;

        if fullsize - size <= sizeMax then begin
          FPoints.ReallocMem( Max( POINTS_CHUNK_SIZE, fullsize * 3 div 2 ) ) ;
        end ;
      end
      else begin
        FPoints := TGIS_Bytes.Create( POINTS_CHUNK_SIZE ) ;
      end ;
    {$ELSE}
      fullsize := ( (size div POINTS_CHUNK_SIZE) + 1 ) * POINTS_CHUNK_SIZE ;

      sizeMax  := SIZEOF_TGIS_POINT ;

      if ShapeType = TGIS_ShapeType.Point then begin
        if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
          inc( sizeMax, sizeOf( Double ) ) ;
        if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
          inc( sizeMax, sizeOf( Double ) ) ;
      end;

      if (fullsize - size) <= sizeMax then begin
        fullsize := fullsize + POINTS_CHUNK_SIZE ;
        ReallocMem( FPoints, fullsize ) ;
      end ;
    {$ENDIF}
  end
  else begin
    {$IFDEF MANAGED}
      begin
        FPoints := TGIS_Bytes.Create( POINTS_CHUNK_SIZE ) ;
      end ;
    {$ELSE}
      ReallocMem( FPoints, POINTS_CHUNK_SIZE ) ;
    {$ENDIF}
  end ;

  if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
    if assigned( FPointsZ ) then begin
      size := PointsZSize ;
      {$IFDEF MANAGED}
        fullsize := high( FPointsZ.Memory ) ;
        if fullsize > 0 then begin
          if fullsize - size <= sizeOf(Double) then begin
            FPointsZ.ReallocMem(
              Max( POINTS_CHUNK_SIZE, fullsize * 3 div 2 )
            ) ;
          end ;
        end
        else begin
          FPointsZ := TGIS_Bytes.Create( POINTS_CHUNK_SIZE ) ;
        end ;
      {$ELSE}
        fullsize := ( (size div POINTS_CHUNK_SIZE) + 1 ) * POINTS_CHUNK_SIZE ;
        if (fullsize - size) <= sizeOf(Double) then begin
          fullsize := fullsize + POINTS_CHUNK_SIZE ;
          ReallocMem( FPointsZ, fullsize ) ;
        end ;
      {$ENDIF}
    end
    else begin
      {$IFDEF MANAGED}
        begin
          FPointsZ := TGIS_Bytes.Create( POINTS_CHUNK_SIZE ) ;
        end ;
      {$ELSE}
        ReallocMem( FPointsZ, POINTS_CHUNK_SIZE ) ;
      {$ENDIF}
    end ;
  end;

  if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
    if assigned( FPointsM ) then begin
      size := PointsMSize ;
      {$IFDEF MANAGED}
        fullsize := high( FPointsM.Memory ) ;
        if fullsize > 0 then begin
          if fullsize - size <= sizeOf(Double) then begin
            FPointsM.ReallocMem(
              Max( POINTS_CHUNK_SIZE, fullsize * 3 div 2 )
            ) ;
          end ;
        end
        else begin
          FPointsM := TGIS_Bytes.Create( POINTS_CHUNK_SIZE ) ;
        end ;
      {$ELSE}
        fullsize := ( (size div POINTS_CHUNK_SIZE) + 1 ) * POINTS_CHUNK_SIZE ;
        if (fullsize - size) <= sizeOf(Double) then begin
          fullsize := fullsize + POINTS_CHUNK_SIZE ;
          ReallocMem( FPointsM, fullsize ) ;
        end ;
      {$ENDIF}
    end
    else begin
      {$IFDEF MANAGED}
        begin
          FPointsM := TGIS_Bytes.Create( POINTS_CHUNK_SIZE ) ;
        end ;
      {$ELSE}
        ReallocMem( FPointsM, POINTS_CHUNK_SIZE ) ;
      {$ENDIF}
    end ;
  end;

end ;

procedure TGIS_Shape.layerModified(
  const _geometry : Boolean
) ;
begin
  FIsModified  := True ;
  lockModified := True ;

  if _geometry then
    FGeometryChanged := True ;

  if assigned( Layer )              and
     GisLockLessThan( lockMode, TGIS_Lock.Internal ) and
     FIsEditable                    then
  begin
    Layer.FIsModified := True ;

    {$IFDEF OXYGENE}
      if _geometry and assigned( Layer.FOnShapeGeometryChange ) then
        Layer.FOnShapeGeometryChange( Layer, TGIS_ShapeEventArgs.Create(self) ) ;
    {$ELSE}
      if _geometry and assigned( Layer.ShapeGeometryChangeEvent ) then
        Layer.ShapeGeometryChangeEvent( Layer, self ) ;
    {$ENDIF}
  end ;
end ;

procedure TGIS_Shape.setExtentByPoint(
  const _ptg : TGIS_Point
) ;
var
  {$IFDEF MANAGED}
    ext  : TGIS_Extent ;
  {$ELSE}
    pext : PGIS_Extent ;
  {$ENDIF}
begin
  {$IFNDEF MANAGED}
    pext := PGIS_Extent( FParts ) ;
  {$ENDIF}

  {$IFDEF GIS_NORECORDS}
    ext := new TGIS_Extent ;
  {$ENDIF}
  if GetNumPoints = 0 then begin
    {$IFDEF MANAGED}
      ext.XMin := _ptg.X ;
      ext.YMin := _ptg.Y ;
      ext.XMax := _ptg.X ;
      ext.YMax := _ptg.Y ;
      FParts.WriteDouble( 0 * sizeOf( Double ), ext.XMin );
      FParts.WriteDouble( 1 * sizeOf( Double ), ext.YMin );
      FParts.WriteDouble( 2 * sizeOf( Double ), ext.XMax );
      FParts.WriteDouble( 3 * sizeOf( Double ), ext.YMax );
    {$ELSE}
      pext^.XMin := _ptg.X ;
      pext^.XMax := _ptg.X ;
      pext^.YMin := _ptg.Y ;
      pext^.YMax := _ptg.Y ;
    {$ENDIF}
  end
  else begin
    {$IFDEF MANAGED}
      ext.XMin := FParts.ReadDouble( 0 * sizeOf(Double) ) ;
      ext.YMin := FParts.ReadDouble( 1 * sizeOf(Double) ) ;
      ext.XMax := FParts.ReadDouble( 2 * sizeOf(Double) ) ;
      ext.YMax := FParts.ReadDouble( 3 * sizeOf(Double) ) ;
      if      _ptg.X < ext.XMin then begin
        ext.XMin := _ptg.X ;
        FParts.WriteDouble( 0 * sizeOf( Double ), ext.XMin );
      end else if _ptg.X > ext.XMax then begin
        ext.XMax := _ptg.X ;
        FParts.WriteDouble( 2 * sizeOf( Double ), ext.XMax );
      end ;
      if      _ptg.Y < ext.YMin then begin
        ext.YMin := _ptg.Y ;
        FParts.WriteDouble( 1 * sizeOf( Double ), ext.YMin );
      end else if _ptg.Y > ext.YMax then begin
        ext.YMax := _ptg.Y ;
        FParts.WriteDouble( 3 * sizeOf( Double ), ext.YMax );
      end ;
    {$ELSE}
      if      _ptg.X < pext^.XMin then pext^.XMin := _ptg.X
      else if _ptg.X > pext^.XMax then pext^.XMax := _ptg.X ;
      if      _ptg.Y < pext^.YMin then pext^.YMin := _ptg.Y
      else if _ptg.Y > pext^.YMax then pext^.YMax := _ptg.Y ;
    {$ENDIF}
  end ;

  if not assigned( Layer ) then exit ;

  {$IFDEF MANAGED}
    Layer.Extent := GisMaxExtent( Layer.Extent, ext ) ;
  {$ELSE}
    Layer.Extent := GisMaxExtent( Layer.Extent, pext^ ) ;
  {$ENDIF}

  UpdateIndex ;
end ;

procedure TGIS_Shape.setExtentByPoint3D(
  const _ptg : TGIS_Point3D
) ;
var
  {$IFDEF MANAGED}
    ext  : TGIS_Extent ;
  {$ELSE}
    pext : PGIS_Extent ;
  {$ENDIF}
  ext3D  : TGIS_Extent3D ;
begin
  {$IFNDEF MANAGED}
    pext := PGIS_Extent( FParts ) ;
  {$ENDIF}
  {$IFDEF GIS_NORECORDS}
    ext := new TGIS_Extent ;
  {$ENDIF}
  if GetNumPoints = 0 then begin
    {$IFDEF MANAGED}
      ext.XMin := _ptg.X ;
      ext.YMin := _ptg.Y ;
      ext.XMax := _ptg.X ;
      ext.YMax := _ptg.Y ;
      FParts.WriteDouble( 0 * sizeOf( Double ), ext.XMin );
      FParts.WriteDouble( 1 * sizeOf( Double ), ext.YMin );
      FParts.WriteDouble( 2 * sizeOf( Double ), ext.XMax );
      FParts.WriteDouble( 3 * sizeOf( Double ), ext.YMax );
    {$ELSE}
      pext^.XMin := _ptg.X ;
      pext^.XMax := _ptg.X ;
      pext^.YMin := _ptg.Y ;
      pext^.YMax := _ptg.Y ;
    {$ENDIF}
      FPointsZMin := _ptg.Z ;
      FPointsZMax := _ptg.Z ;
      if not IsNan( _ptg.M ) then begin
        FPointsMMin := _ptg.M ;
        FPointsMMax := _ptg.M ;
      end
      else begin
        FPointsMMin := 0 ;
        FPointsMMax := 0 ;
      end ;
  end
  else begin
    {$IFDEF MANAGED}
      ext.XMin := FParts.ReadDouble( 0 * sizeOf(Double) ) ;
      ext.YMin := FParts.ReadDouble( 1 * sizeOf(Double) ) ;
      ext.XMax := FParts.ReadDouble( 2 * sizeOf(Double) ) ;
      ext.YMax := FParts.ReadDouble( 3 * sizeOf(Double) ) ;
      if      _ptg.X < ext.XMin then begin
        ext.XMin := _ptg.X ;
        FParts.WriteDouble( 0 * sizeOf( Double ), ext.XMin );
      end else if _ptg.X > ext.XMax then begin
        ext.XMax := _ptg.X ;
        FParts.WriteDouble( 2 * sizeOf( Double ), ext.XMax );
      end ;
      if      _ptg.Y < ext.YMin then begin
        ext.YMin := _ptg.Y ;
        FParts.WriteDouble( 1 * sizeOf( Double ), ext.YMin );
      end else if _ptg.Y > ext.YMax then begin
        ext.YMax := _ptg.Y ;
        FParts.WriteDouble( 3 * sizeOf( Double ), ext.YMax );
      end ;
    {$ELSE}
      if      _ptg.X < pext^.XMin then pext^.XMin := _ptg.X
      else if _ptg.X > pext^.XMax then pext^.XMax := _ptg.X ;
      if      _ptg.Y < pext^.YMin then pext^.YMin := _ptg.Y
      else if _ptg.Y > pext^.YMax then pext^.YMax := _ptg.Y ;
    {$ENDIF}
      if      _ptg.Z < FPointsZMin then FPointsZMin := _ptg.Z
      else if _ptg.Z > FPointsZMax then FPointsZMax := _ptg.Z ;
      if not IsNan( _ptg.M ) then begin
        if      _ptg.M < FPointsMMin then FPointsMMin := _ptg.M
        else if _ptg.M > FPointsMMax then FPointsMMax := _ptg.M ;
      end ;
  end ;

  if not assigned( Layer ) then exit ;

  {$IFDEF MANAGED}
    ext3D := GisExtent3D( ext.XMin, ext.YMin, FPointsZMin, FPointsMMin,
                          ext.XMax, ext.YMax, FPointsZMax, FPointsMMax
                         ) ;
  {$ELSE}
    ext3D := GisExtent3D( pext^.XMin, pext^.YMin, FPointsZMin, FPointsMMin,
                          pext^.XMax, pext^.YMax, FPointsZMax, FPointsMMax
                         ) ;
  {$ENDIF}

  Layer.Extent3D := GisMaxExtent3D( Layer.Extent3D, ext3D ) ;

  UpdateIndex ;
end;

function  TGIS_Shape.getIntersectInternal(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
begin
  // for safe inheritance only
  Result := nil ;
end ;

function  TGIS_Shape.getIntersectInternal3D(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
begin
  // for safe inheritance only
  Result := nil ;
end ;

procedure TGIS_Shape.copyInternalFields(
  const _src : TGIS_Shape;
  const _dst : TGIS_Shape
) ;
begin
   if assigned( _src.mappedFields ) then begin
     _dst.mappedFields := TGIS_FieldList.Create ;
     _src.mappedFields.CopyTo( _dst.mappedFields ) ;
   end ;
end ;

procedure TGIS_Shape.copyInternalParams(
  const _src : TGIS_Shape;
  const _dst : TGIS_Shape
) ;
begin
  if assigned( _src.FParams ) then begin
    _dst.FParams := TGIS_ParamsSectionVector.Create ;
    _dst.FParams.Assign( _src.FParams ) ;
  end ;
end ;

function TGIS_ShapePoint.getIntersectInternal(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
begin
  if IsInsideExtent( _extent, TGIS_InsideType.Full ) then begin
    Result := TGIS_ShapePoint.Create(nil, nil, False, Uid, Layer) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    Result.AddPart ;
    Result.AddPoint( GetPoint(0, 0) ) ;

    Result.Unlock ;
  end
  else
    Result := nil ;
end ;

function TGIS_ShapePoint.getIntersectInternal3D(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
begin
  if IsInsideExtent( _extent, TGIS_InsideType.Full ) then begin
    Result := TGIS_ShapePoint.Create(nil, nil, False, Uid, Layer, Dimension) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    Result.AddPart ;
    Result.AddPoint3D( GetPoint3D(0, 0) ) ;

    Result.Unlock ;
  end
  else
    Result := nil ;
end ;

function TGIS_Shape.getLabelOld
  : String ;
var
  slabel        : String  ;
  i             : Integer ;
  c             : Char    ;
  state         : Integer ;
  vtmp          : Variant ;
  fmt           : TStringBuilder ;
  lname         : TStringBuilder ;
  res           : TStringBuilder ;

  procedure parse_name ;
  var
    v    : Variant ;
    s    : String  ;
    i64  : TGIS_Uid   ;
    sfmt : String  ;
  begin
    v := GetField( lname.ToString ) ;

    sfmt := fmt.ToString ;
    try
      if IsStringEmpty( sfmt ) then begin
        {$IFDEF CLR}
          case VarTypeEx( v ) of
              varExFloat,
              varExFixed : res.Append( VarToDouble( v ).ToString('G15') )
          else             res.Append( VarToString( v ) ) ;
          end ;
        {$ELSE}
        res.Append( VarToString( v ) ) ;
        {$ENDIF}
      end
      else begin
        case VarTypeEx( v ) of
          varExAnsiString :
            res.Append( Format( '%'+sfmt, [String(v)] ) ) ;
          varExWideString :
            res.Append( Format( '%'+sfmt, [String(v)] ) ) ;
          varExDateTime :
            begin
              DateTimeToString( s, sfmt, VarToDateTime( v ) ) ;
              res.Append( s ) ;
            end ;

          varExBoolean :
            res.Append( VarToString( v ) ) ;

          varExUInt :
            res.Append( Format( '%'+sfmt, [Cardinal(v)] ) ) ;

          varExFixed :
            res.Append( Format( '%'+sfmt, [Double(v)] ) ) ;

          varExInt :
            res.Append( Format( '%'+sfmt, [Integer(v)] ) ) ;

          varExInt64  :
             begin
              i64 := VarToUInt64( v ) ;
              res.Append( Format( '%'+sfmt, [i64] ) ) ;
             end ;

          varExUInt64 :
             begin
               i64 := VarToInt64( v ) ;
               res.Append( Format( '%'+sfmt, [i64] ) ) ;
             end ;

          varExFloat :
            res.Append( Format( '%'+sfmt, [Double(v)] ) ) ;
        end ;
      end ;
    except
    end ;
  end ;
begin
  Result := '' ;

  with Params.Labels do begin
    if IsStringEmpty( Value ) then
      slabel := Field
    else begin
      slabel := Value ;
      if Copy( slabel, StringFirst, 1 ) <> ':' then begin
        Result := slabel ;
        exit ;
      end ;
    end ;
  end ;

  state  := 0  ;
  fmt    := TStringBuilder.Create ;
  lname  := TStringBuilder.Create ;
  res    := TStringBuilder.Create ;

  try

    for i := StringFirst to StringLast( slabel ) do begin
      c := slabel[ i ] ;

      case state of
        0 : begin
              if c = ':' then state := 1
                         else begin
                                vtmp := GetFieldEx( slabel ) ;
                                if VarIsNull( vtmp ) then
                                  {$IFDEF JAVA}
                                    res.setLength(0)
                                  {$ELSE}
                                    res.Length := 0
                                  {$ENDIF}
                                else if VarIsEmpty( vtmp ) then
                                  {$IFDEF JAVA}
                                    res.setLength(0)
                                  {$ELSE}
                                    res.Length := 0
                                  {$ENDIF}
                                else begin
                                  {$IFDEF JAVA}
                                    res.setLength(0) ;
                                  {$ELSE}
                                    res.Length := 0 ;
                                  {$ENDIF}
                                  res.Append( VarToString( vtmp ) ) ;
                                end;

                                exit ;
                              end ;
            end ;
        1 : begin  // interpret plain text
              case c of
                '\' : state := 2 ;
                '<' : state := 3 ;
                else  res.Append( c ) ;
              end ;
            end ;
        2 : begin // interpret \n
              if      c = 'n' then begin
                                res.Append( '<' ) ;
                                res.Append( 'B' ) ;
                                res.Append( 'R' ) ;
                                res.Append( '>' ) ;
                              end
              else if c = #13 then begin
                                res.Append( '<' ) ;
                                res.Append( 'B' ) ;
                                res.Append( 'R' ) ;
                                res.Append( '>' ) ;
                              end
                         else res.Append( c ) ;
              state := 1 ;
            end ;
        3 : begin // interpret <XXX:___>
              case c of
                ':' : state := 4 ;
                '>' : state := 1 ;
                else  fmt.Append( c ) ;
              end ;
            end ;
        4 : begin // interpret <___:XXX>
              case c of
                ' ' : ; // ignore space
                '>' : begin
                        parse_name ;
                        {$IFDEF JAVA}
                          fmt.setLength(0) ;
                          lname.setLength(0) ;
                        {$ELSE}
                          fmt.Length   := 0 ;
                         lname.Length := 0 ;
                        {$ENDIF}
                        state := 1  ;
                      end
                else  lname.Append( c ) ;
              end ;
            end ;
        else assert( False, 'unexpected case' ) ;
      end ;
    end ;

  finally
    Result := res.ToString ;

    FreeObject( fmt   ) ;
    FreeObject( lname ) ;
    FreeObject( res   ) ;
  end;

end ;

function TGIS_Shape.getLabelInternal
  : String ;
var
  slabel : String ;
begin
  Result  := ''  ;

  with Params.Labels do begin
    if IsStringEmpty( Value ) then begin
      Result := getLabelOld ;
      exit ;
    end
    else begin
      slabel := Value ;
      if Copy( slabel, StringFirst, 1 ) = ':' then begin
        Result := getLabelOld ;
        exit ;
      end ;
    end ;
  end ;

  Result := GisExpandLabel( slabel, self ) ;
end ;

function TGIS_Shape.getTruncatedShape(
  const _restrictive : Boolean
) : TGIS_Shape ;
var
  vwr  : TGIS_ViewerRef ;
  ex   : TGIS_Extent ;
  inch : Double      ;
begin
  Result := nil ;

  vwr := Viewer ;
  if not assigned( vwr ) then exit ;

  if _restrictive then begin
    ex := vwr.Ref.VisibleExtent ;
  end
  else begin
    inch := vwr.Ref.TwipsToPixels( 1440 ) / vwr.Ref.Zoom ;
    if GisIsNoWorld( vwr.Ref.TemporaryVisibleExtent ) then
      ex := vwr.Ref.VisibleExtent
    else
      ex := _TGIS_Extent( vwr.Ref.TemporaryVisibleExtent ) ;
    ex.XMin := ex.XMin - inch ;
    ex.YMin := ex.YMin - inch ;
    ex.XMax := ex.XMax + inch ;
    ex.YMax := ex.YMax + inch ;
  end ;

  // do truncation
  if IsInsideExtent( ex, TGIS_InsideType.Full) then
    Result := self
  else begin
    Result := getIntersectInternal( ex, True ) ;
  end ;
end ;

function TGIS_Shape.getTruncatedShapeEx
  : TGIS_Shape ;
var
  vwr  : TGIS_ViewerRef ;
  ex   : TGIS_Extent ;

begin
  Result := nil ;

  vwr := Viewer ;
  if not assigned( vwr ) then exit ;

  ex := TGIS_RendererAbstract( Layer.Renderer ).CanvasExtent ;

  // do truncation
  if IsInsideExtent( ex, TGIS_InsideType.Full) then
    Result := self
  else begin
    Result := getIntersectInternal( ex, True ) ;
  end ;
end ;


function TGIS_Shape.isTruncatedPoint(
  const _ptg         : TGIS_Point ;
  const _restrictive : Boolean
) : Boolean ;
var
  vwr  : TGIS_ViewerRef ;
  ex   : TGIS_Extent ;
  inch : Double      ;
begin
  Result := False ;

  vwr := Viewer ;
  if not assigned( vwr ) then exit ;

  if _restrictive then begin
    ex := vwr.Ref.VisibleExtent ;
  end
  else begin
    inch := vwr.Ref.TwipsToPixels( 1440 ) / vwr.Ref.Zoom ;
    ex := vwr.Ref.VisibleExtent ;
    ex.XMin := ex.XMin - inch ;
    ex.YMin := ex.YMin - inch ;
    ex.XMax := ex.XMax + inch ;
    ex.YMax := ex.YMax + inch ;
  end;

  // do test
  Result := not GisIsPointInsideExtent( _ptg, ex ) ;
end;

function TGIS_Shape.isTruncatedPointEx(
  const _ptg         : TGIS_Point
) : Boolean ;
var
  vwr  : TGIS_ViewerRef ;
  ex   : TGIS_Extent ;
  inch : Double      ;
begin

  Result := False ;

  vwr := Viewer ;
  if not assigned( vwr ) then exit ;

  inch := vwr.Ref.TwipsToPixels( 1440 ) / vwr.Ref.Zoom ;
  ex := TGIS_RendererAbstract( Layer.Renderer ).CanvasExtent ;
  ex.XMin := ex.XMin - 5*inch ;
  ex.YMin := ex.YMin - 5*inch ;
  ex.XMax := ex.XMax + 5*inch ;
  ex.YMax := ex.YMax + 5*inch ;

  // do test
  Result := not GisIsPointInsideExtent( _ptg, ex ) ;
end;

procedure TGIS_Shape.freeTruncatedShape(
  var _shape : TGIS_Shape
) ;
begin
  if assigned( _shape ) and ( _shape <> self ) then FreeObject( _shape ) ;
end ;

procedure TGIS_Shape.prepareTrackingPoints ;
var
  renderer : TGIS_RendererAbstract ;
  editor   : IGIS_Editor ;
begin
  renderer := TGIS_RendererAbstract( Viewer.Ref.ViewerParent.ControlRenderer ) ;
  editor   := Viewer.Ref.Editor ;
  renderer.CanvasBrush.Style :=
      editor.EditingPointsStyle.SnappingPoints.BrushStyle ;
  renderer.CanvasBrush.Color :=
      editor.EditingPointsStyle.SnappingPoints.BrushColor ;
  renderer.CanvasPen.Style   :=
      editor.EditingPointsStyle.SnappingPoints.PenStyle ;
  renderer.CanvasPen.Color   :=
      editor.EditingPointsStyle.SnappingPoints.PenColor ;
  renderer.CanvasPen.Width   :=
      editor.EditingPointsStyle.SnappingPoints.PenWidth ;
end ;


function TGIS_Shape.pointToWGS(
  const _pt : TGIS_Point
) : TGIS_Point ;
var
  acs : TGIS_CSCoordinateSystem ;
begin
  if assigned( Viewer ) then
    acs := Viewer.Ref.CS
  else
    acs := Layer.CS ;

  Result := acs.ToWGS( _pt ) ;
end ;


function TGIS_Shape.pointFromWGS(
  const _pt : TGIS_Point
) : TGIS_Point ;
var
  acs : TGIS_CSCoordinateSystem ;
begin
  if assigned( Viewer ) then
    acs := Viewer.Ref.CS
  else
    acs := Layer.CS ;

  Result := acs.FromWGS( _pt ) ;
end ;


function TGIS_Shape.haversineFormula(
  const _p1 : TGIS_Point ;
  const _p2 : TGIS_Point
) : Double ;
var
  dist : Double ;
  py   : Double ;
  px   : Double ;
  spy  : Double ;
  spx  : Double ;
begin
  py   := ( _p2.Y - _p1.Y )/2 ;
  px   := ( _p2.X - _p1.X )/2 ;
  spy  := Sin( py ) ;
  spx  := Sin( px ) ;
  dist := spy*spy + Cos( _p1.Y )*Cos( _p2.Y )*spx*spx ;
  dist := 2*6378137*ArcSin( Sqrt( dist ) ) ;

  Result := dist ;
end ;


function TGIS_Shape.distanceWGS(
  const _p1 : TGIS_Point ;
  const _p2 : TGIS_Point
) : Double ;
var
  ell : TGIS_CSEllipsoid ;
  dst : Double ;
  tmp : Double ;
  rat : Double ;
begin
  ell := CSEllipsoidList.ByEPSG( 7030 ) ;
  dst := ell.Distance( _p1, _p2 ) ;
  tmp := haversineFormula( _p1, _p2 ) ;
  rat := tmp/dst ;
  if ( dst < 0 ) or ( rat > 1.1 ) or ( rat < 0.9 ) then
    Result := tmp
  else
    Result := dst ;
end ;


function TGIS_Shape.distance2SegmentWGS(
  const _p0   : TGIS_Point ;
  const _p1   : TGIS_Point ;
  const _p2   : TGIS_Point ;
  const _togc : Boolean ;
    out _out  : TGIS_Point
) : Double ;
var
  p0  : TGIS_Point ;
  p1  : TGIS_Point ;
  p2  : TGIS_Point ;

  sinx1 : Double ;
  cosx1 : Double ;
  siny1 : Double ;
  cosy1 : Double ;

  sinx2 : Double ;
  cosx2 : Double ;
  siny2 : Double ;
  cosy2 : Double ;

  tany1 : Double ;
  tany2 : Double ;

  gca  : Double ;
  gcb  : Double ;
  gcc  : Double ;

  cpx  : Double ;
  cpy  : Double ;
  cpz  : Double ;
  cp   : TGIS_Point ;

  sinx0 : Double ;
  cosx0 : Double ;
  siny0 : Double ;
  cosy0 : Double ;

  sinxp : Double ;
  cosxp : Double ;
  sinyp : Double ;
  cosyp : Double ;

  tany0 : Double ;
  tanyp : Double ;

  pca  : Double ;
  pcb  : Double ;
  pcc  : Double ;

  ci   : TGIS_Point ;
  aci  : TGIS_Point ;

  d1   : Double ;
  d2   : Double ;

  lrgx : Integer ;
  lrgy : Integer ;

  pout : TGIS_Point ;

  function greater_x
    : TGIS_Point ;
  begin
    case lrgx of
      1 : Result := _TGIS_Point(p1) ;
      2 : Result := _TGIS_Point(p2) ;
    end ;
  end ;

  function smaller_x
    : TGIS_Point ;
  begin
    case lrgx of
      1 : Result := _TGIS_Point(p2) ;
      2 : Result := _TGIS_Point(p1) ;
    end ;
  end ;

  function greater_y
    : TGIS_Point ;
  begin
    case lrgy of
      1 : Result := _TGIS_Point(p1) ;
      2 : Result := _TGIS_Point(p2) ;
    end ;
  end ;

  function smaller_y
    : TGIS_Point ;
  begin
    case lrgy of
      1 : Result := _TGIS_Point(p2) ;
      2 : Result := _TGIS_Point(p1) ;
    end ;
  end ;

begin
  p0 := _TGIS_Point(_p0) ;
  p1 := _TGIS_Point(_p1) ;
  p2 := _TGIS_Point(_p2) ;

  // grand circle through p1 and p2

  if p1.X > p2.X then
    lrgx := 1
  else
    lrgx := 2 ;

  if p1.Y > p2.Y then
    lrgy := 1
  else
    lrgy := 2 ;

  SinCos( p1.X, sinx1, cosx1 ) ;
  SinCos( p1.Y, siny1, cosy1 ) ;
  SinCos( p2.X, sinx2, cosx2 ) ;
  SinCos( p2.Y, siny2, cosy2 ) ;

  tany1 := Tan( p1.Y ) ;
  tany2 := Tan( p2.Y ) ;

  gca := tany2*sinx1 - tany1*sinx2 ;
  gcb := tany1*cosx2 - tany2*cosx1 ;
  gcc := cosx1*sinx2 - sinx1*cosx2 ;

  // cross product between p1 and p2

  cpx := cosy1*sinx1*siny2 - cosy2*sinx2*sinx1 ;
  cpy := cosy1*cosx1*siny2 - cosy2*cosx2*sinx1 ;
  cpz := cosy1*cosx1*cosy2*sinx2 - cosy2*cosx2*cosy1*sinx1 ;

  {$IFDEF GIS_NORECORDS}
    cp := new TGIS_Point();
    ci := new TGIS_Point();
    aci := new TGIS_Point();
    pout := new TGIS_Point();
  {$ENDIF}

  cp.X := ArcTan2( cpy, cpx ) ;
  cp.Y := ArcSin( cpz ) ;

  // grand circle between p0 and cross product

  SinCos( p0.X, sinx0, cosx0 ) ;
  SinCos( p0.Y, siny0, cosy0 ) ;

  SinCos( cp.X, sinxp, cosxp ) ;
  SinCos( cp.Y, sinyp, cosyp ) ;

  tany0 := Tan( p0.Y ) ;
  tanyp := Tan( cp.Y ) ;

  pca := tany0*sinxp - tanyp*sinx0 ;
  pcb := tanyp*cosx0 - tany0*cosxp ;
  pcc := cosxp*sinx0 - sinxp*cosx0 ;

  // point of intersection between grand circles

  ci.X := ArcTan2( ( pca*gcc - gca*pcc ), ( gcb*pcc - pcb*gcc ) ) ;
  ci.Y := ArcTan2( -( gca*Cos( ci.X ) + gcb*Sin( ci.X ) ), gcc ) ;
  if ci.X < 0 then
    aci.X := ci.X + Pi
  else
    aci.X := ci.X - Pi ;
  if ci.Y > Pi/2 then
    ci.Y := ci.Y - Pi
  else
  if ci.Y < -Pi/2 then
    ci.Y := ci.Y + Pi ;

  aci.Y := -ci.Y ;
  if haversineFormula( p0, aci ) < haversineFormula( p0, ci ) then
    ci := _TGIS_Point(aci) ;

  // distance from p0 to the grand circle between p1 and p2

  if _togc then begin

    _out := _TGIS_Point(ci) ;
    Result := distanceWGS( p0, ci ) ;

    exit ;
  end ;

  // distance from p0 to the segment between p1 and p2

  if ( ci.X >= Min( p1.X, p2.X ) ) and
     ( ci.X <= Max( p1.X, p2.X ) ) then begin

    if ( ci.Y >= Min( p1.Y, p2.Y ) ) and
       ( ci.Y <= Max( p1.Y, p2.Y ) ) then
      pout := _TGIS_Point(ci)
    else
    if ci.Y > Max( p1.Y, p2.Y ) then
      pout := greater_y
    else
      pout := smaller_y ;

    _out := _TGIS_Point(pout) ;
    Result := distanceWGS( p0, pout ) ;

  end
  else
  if ( ci.Y >= Min( p1.Y, p2.Y ) ) and
     ( ci.Y <= Max( p1.Y, p2.Y ) ) then begin

    if ( ci.X >= Min( p1.X, p2.X ) ) and
       ( ci.X <= Max( p1.X, p2.X ) ) then
      pout := _TGIS_Point(ci)
    else
    if ci.X > Max( p1.X, p2.X ) then
      pout := greater_x
    else
      pout := smaller_x ;

    _out := _TGIS_Point( pout) ;
    Result := distanceWGS( p0, pout ) ;

  end
  else begin

    d1 := distanceWGS( p0, p1 ) ;
    d2 := distanceWGS( p0, p2 ) ;

    if d1 < d2 then begin
      _out := _TGIS_Point(p1) ;
      Result := d1 ;
    end
    else begin
      _out := _TGIS_Point(p2) ;
      Result := d2 ;
    end ;

  end ;

end ;

function TGIS_Shape.getVirtualField(
  const _id     : Integer ;
  const _iscs   : Boolean
) : Variant ;
var
  i    : Integer ;
  stmp : TStringBuilder ;
begin
  Result := Unassigned ;
  case _id of
    GIS_FIELD_ID_UID :
      begin
        Result := Uid ;
      end ;
    GIS_FIELD_ID_SELECTED :
      begin
        Result := IsSelected ;
      end ;
    GIS_FIELD_ID_HIDDEN :
      begin
        Result := IsHidden ;
      end ;
    GIS_FIELD_ID_AREA :
      begin
        if _iscs then
          Result := auto_round(AreaCS)
        else
          Result := auto_round(Area  ) ;
      end ;
    GIS_FIELD_ID_LENGTH :
      begin
        if _iscs then
          Result := auto_round(LengthCS)
        else
          Result := auto_round(Length  ) ;
        end ;
    GIS_FIELD_ID_COORD_Z :
      begin
        if not IsEmpty then
          Result := GetPoint3D( 0, 0 ).Z
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_COORD_M :
      begin
        if not IsEmpty then
          Result := GetPoint3D( 0, 0 ).M
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_NOW :
      begin
        Result := Now ;
      end ;
    GIS_FIELD_ID_MIN_X :
      begin
        if not IsEmpty then
          Result := Extent.XMin
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_MIN_Y :
      begin
        if not IsEmpty then
          Result := Extent.YMin
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_MIN_Z :
      begin
        if not IsEmpty then
          Result := PointsZMin
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_MIN_M :
      begin
        if not IsEmpty then
          Result := PointsMMin
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_MAX_X :
      begin
        if not IsEmpty then
          Result := Extent.XMax
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_MAX_Y :
      begin
        if not IsEmpty then
          Result := Extent.YMax
        else
          Result := 0 ;
        end ;
    GIS_FIELD_ID_MAX_Z :
      begin
        if not IsEmpty then
          Result := PointsZMax
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_MAX_M :
      begin
        if not IsEmpty then
          Result := PointsMMax
        else
          Result := 0 ;
        end ;
    GIS_FIELD_ID_CENTER_X :
      begin
        if not IsEmpty then
          Result := ( Extent.XMin + Extent.XMax ) / 2
        else
          Result := 0 ;
        end ;
    GIS_FIELD_ID_CENTER_Y :
      begin
        if not IsEmpty then
          Result := ( Extent.YMin + Extent.YMax ) / 2
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_CENTER_Z :
      begin
        if not IsEmpty then
          Result := ( PointsZMin + PointsZMax ) / 2
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_CENTER_M :
      begin
        if not IsEmpty then
          Result := ( PointsMMin + PointsMMax ) / 2
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_CENTROID_X :
      begin
        if not IsEmpty then
          Result := Centroid.X
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_CENTROID_Y :
      begin
        if not IsEmpty then
          Result := Centroid.Y
        else
          Result := 0 ;
      end ;
    GIS_FIELD_ID_NUM_PARTS :
      begin
        Result := GetNumParts ;
      end ;
    GIS_FIELD_ID_NUM_POINTS :
      begin
        Result := GetNumPoints ;
      end ;
    GIS_FIELD_ID_AGGREGATED_COUNT :
      begin
        if ( TagPointer <> nil )             and
           ( Tag = AGGREGATED_MAGIC_NUMBER ) and
           ( TObject( TagPointer ) is TGIS_DynamicAggregatorValue )
        then
          Result := high( TGIS_DynamicAggregatorValue( TagPointer ).Uids ) + 1
        else
          Result := -1 ;
      end;
    GIS_FIELD_ID_AGGREGATED_VALUE :
      begin
        if ( TagPointer <> nil )             and
           ( Tag = AGGREGATED_MAGIC_NUMBER ) and
           ( TObject( TagPointer ) is TGIS_DynamicAggregatorValue )
        then
          Result := TGIS_DynamicAggregatorValue( TagPointer ).Value
        else
          Result := NullVar ;
      end;
    GIS_FIELD_ID_AGGREGATED_UIDS :
      begin
        if ( TagPointer <> nil )             and
           ( Tag = AGGREGATED_MAGIC_NUMBER ) and
           ( TObject( TagPointer ) is TGIS_DynamicAggregatorValue )
        then begin
          stmp := TStringBuilder.Create ;
          try
            for i := 0 to high( TGIS_DynamicAggregatorValue( TagPointer ).Uids ) do
            begin
              if i > 0 then
                stmp.Append( ';' ) ;
              stmp.Append(
                IntToStr( TGIS_DynamicAggregatorValue( TagPointer ).Uids[i] )
              ) ;
            end;
          finally
            Result := stmp.ToString ;
            FreeObject( stmp ) ;
          end;
        end
        else
          Result := NullVar ;
      end;
    GIS_FIELD_ID_SHAPE_TYPE :
      begin
        case FShapeType of
          TGIS_ShapeType.Point      : Result := 'Point' ;
          TGIS_ShapeType.MultiPoint : Result := 'MultiPoint' ;
          TGIS_ShapeType.Arc        : Result := 'LineString' ;
          TGIS_ShapeType.Polygon    : Result := 'Polygon' ;
          TGIS_ShapeType.Complex    : Result := 'Complex' ;
          TGIS_ShapeType.MultiPatch : Result := 'MultiPatch' ;
        else                          Result := 'Unknown' ;
        end ;
      end ;
    GIS_FIELD_ID_VIEWER_SCALE :
      begin
        if assigned( Viewer ) then
          Result := Viewer.Ref.ScaleAsFloat
        else
          Result := 1 ;
      end ;
    GIS_FIELD_ID_VIEWER_LEVEL :
      begin
        if assigned( Viewer ) then
          Result := Viewer.Ref.Level
        else
          Result := 0 ;
      end ;
  end ;
end;

procedure TGIS_Shape.SetParamsInternal(
  const _value : TGIS_ParamsSectionVector
) ;
begin
  FParams := _value ;
end ;

procedure TGIS_Shape.Flash ;
begin
  Flash( 4, 100 ) ;
end ;

procedure TGIS_Shape.Flash(
  const _times : Integer ;
  const _delay : Integer
) ;
begin
  FLayer.FlashShape( FUid, _times, _delay ) ;
end ;

procedure TGIS_Shape.SetPosition(
  const _ptg   : TGIS_Point;
  const _layer : TGIS_LayerVector ;
  const _prec  : Double
) ;
var
  ptgpos   : TGIS_Point ;
  part_no,
  point_no : Integer    ;
  dist     : Double     ; // unused - only for calling purposes
  part     : Integer    ; // unused - only for calling purposes
  ptg      : TGIS_Point ;
  shp      : TGIS_Shape ;
  shp_src  : TGIS_Shape ;
  delta    : TGIS_Point ;
  old_lock : TGIS_Lock  ;
begin
  old_lock := lockMode ;
  if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and
     assigned( Layer )
  then
    ptgpos := _TGIS_Point(Layer.Unproject( _ptg ))
  else
    ptgpos := _TGIS_Point(_ptg) ;

  if assigned( _layer ) then begin
    if GisLockGreaterThanEqual( lockMode, TGIS_Lock.Projection ) and
       assigned( Layer )
    then
      ptg := _TGIS_Point(Layer.Project( _ptg ))
    else
      ptg := _TGIS_Point(_ptg );

    shp := _layer.LocateEx( ptg, _prec, -1, dist, part, ptg ) ;
    if assigned( shp ) then begin
      // snap to layer
      ptgpos := _TGIS_Point(ptg) ;
      ptgpos := _TGIS_Point(Layer.Unproject( ptg )) ;
    end;
  end ;
  if GisLockLessThan( lockMode, TGIS_Lock.Projection ) then
    lockMode := TGIS_Lock.Projection ;
  try

    if not IsEmpty then begin
      if GisIsSamePoint( Centroid, ptgpos ) then exit ;
    end
    else begin
      Reset ;
      AddPart ;
      AddPoint( ptgpos ) ;

      if old_lock = TGIS_Lock.None then
        Unlock ;

      if assigned( Layer ) then
        Invalidate ;
      exit ;
    end ;

    delta := GisPointsDelta( ptgpos, Centroid ) ;

    shp_src := CreateCopy ;
    try
      shp_src.Lock( TGIS_Lock.Projection ) ;
      try
        Reset ;

        Lock( TGIS_Lock.Projection ) ;
        try
          for part_no := 0 to shp_src.GetNumParts -1 do begin
            AddPart ;
            for point_no := 0 to shp_src.GetPartSize( part_no ) -1 do
              AddPoint3D( GisMovePoint3D( shp_src.GetPoint3D( part_no, point_no ),
                                          GisPoint3DFrom2D( delta )
                                        )
                          ) ;
          end ;
        finally
          Unlock ;
        end;

        shp_src.IsHidden := True ;

        if assigned( Layer ) then begin
          shp_src.Invalidate ;
          Invalidate ;
        end ;
      finally
        shp_src.Unlock ;
      end ;
    finally
      FreeObject( shp_src ) ;
    end ;
  finally
    lockMode := old_lock ;
  end;
end ;

procedure TGIS_Shape.Lock(
  const _lock : TGIS_Lock
) ;
begin
  // this implementation is not valid for TGIS_Point
  if GisLockGreaterThanEqual( _lock, lockMode ) then begin
    lockMode     := _lock ;
    lockModified := False ;
  end ;
end ;

procedure TGIS_Shape.Unlock ;
var
  currmode : TGIS_Lock  ;
  old_ex   : TGIS_Extent ;
  {$IFDEF MANAGED}
    ext    : TGIS_Extent ;
  {$ELSE}
    pext   : PGIS_Extent ;
  {$ENDIF}
    ext3D  : TGIS_Extent3D ;

  procedure recalc_extent ;
  var
    part_no  : Integer      ;
    point_no : Integer      ;
    ptg      : TGIS_Point3D ;
  begin
    {$IFNDEF MANAGED}
      pext := PGIS_Extent( FParts ) ;
    {$ENDIF}
    {$IFDEF GIS_NORECORDS}
      ext := new TGIS_Extent ;
    {$ENDIF}
    for part_no := 0 to GetNumParts - 1 do begin // all parts
      for point_no := 0 to GetPartSize( part_no ) -1 do  begin // all points
        ptg := GetPoint3D( part_no, point_no ) ;
        if ( part_no = 0 ) and ( point_no = 0 ) then begin
          {$IFDEF MANAGED}
            ext.XMin := ptg.X ;
            ext.XMax := ptg.X ;
            ext.YMin := ptg.Y ;
            ext.YMax := ptg.Y ;
            FParts.WriteDouble( 0 * sizeOf( Double ), ext.XMin );
            FParts.WriteDouble( 1 * sizeOf( Double ), ext.YMin );
            FParts.WriteDouble( 2 * sizeOf( Double ), ext.XMax );
            FParts.WriteDouble( 3 * sizeOf( Double ), ext.YMax );
          {$ELSE}
            pext^.XMin := ptg.X ;
            pext^.XMax := ptg.X ;
            pext^.YMin := ptg.Y ;
            pext^.YMax := ptg.Y ;
          {$ENDIF}
            FPointsZMin := ptg.Z ;
            FPointsZMax := ptg.Z ;
            if not IsNan( ptg.M ) then begin
              FPointsMMin := ptg.M ;
              FPointsMMax := ptg.M ;
            end
            else begin
              FPointsMMin := 0 ;
              FPointsMMax := 0 ;
            end ;
        end ;

        {$IFDEF MANAGED}
          if      ptg.X < ext.XMin then begin
                  ext.XMin := ptg.X ;
                  FParts.WriteDouble( 0 * sizeOf( Double ), ext.XMin );
          end
          else if ptg.X > ext.XMax then begin
                  ext.XMax := ptg.X ;
                  FParts.WriteDouble( 2 * sizeOf( Double ), ext.XMax );
          end ;
          if      ptg.Y < ext.YMin then begin
                  ext.YMin := ptg.Y ;
                  FParts.WriteDouble( 1 * sizeOf( Double ), ext.YMin );
          end
          else if ptg.Y > ext.YMax then begin
                  ext.YMax := ptg.Y ;
                  FParts.WriteDouble( 3 * sizeOf( Double ), ext.YMax );
          end ;
        {$ELSE}
          if      ptg.X < pext^.XMin then pext^.XMin := ptg.X
          else if ptg.X > pext^.XMax then pext^.XMax := ptg.X ;
          if      ptg.Y < pext^.YMin then pext^.YMin := ptg.Y
          else if ptg.Y > pext^.YMax then pext^.YMax := ptg.Y ;
        {$ENDIF}
          if      ptg.Z < FPointsZMin then FPointsZMin := ptg.Z
          else if ptg.Z > FPointsZMax then FPointsZMax := ptg.Z ;
          if not IsNan( ptg.M ) then begin
            if      ptg.M < FPointsMMin then FPointsMMin := ptg.M
            else if ptg.M > FPointsMMax then FPointsMMax := ptg.M ;
          end ;
      end ;
    end ;
  end ;

begin
  // this implementation is not valid for TGIS_Point

  if lockMode = TGIS_Lock.None then begin
    exit ;
  end ;

  ensureProperPart ;

  if lockMode = TGIS_Lock.Internal2 then begin
    if lockModified then
      recalc_extent ;
    lockModified := False ;
    exit ;
  end ;

  try
    currmode := lockMode ;

    if not lockModified then exit ;
    if IsMapped         then exit ;
    if IsEmpty          then exit ;

    lockMode := TGIS_Lock.Projection ;

    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        old_ex := new TGIS_Extent ;
      {$ENDIF}
      old_ex.XMin := FParts.ReadDouble( 0 * sizeOf( Double ) ) ;
      old_ex.YMin := FParts.ReadDouble( 1 * sizeOf( Double ) ) ;
      old_ex.XMax := FParts.ReadDouble( 2 * sizeOf( Double ) ) ;
      old_ex.YMax := FParts.ReadDouble( 3 * sizeOf( Double ) ) ;
    {$ELSE}
      old_ex := PGIS_Extent( FParts )^ ;
    {$ENDIF}

    recalc_extent ;

    if not assigned( Layer ) then exit ;

    {$IFDEF MANAGED}
      ext3D := GisExtent3D( ext.XMin, ext.YMin, FPointsZMin, FPointsMMin,
                            ext.XMax, ext.YMax, FPointsZMax, FPointsMMax
                           ) ;
    {$ELSE}
      ext3D := GisExtent3D( pext^.XMin, pext^.YMin, FPointsZMin, FPointsMMin,
                            pext^.XMax, pext^.YMax, FPointsZMax, FPointsMMax
                           ) ;
    {$ENDIF}

    if {$IFDEF MANAGED}
         ( not GisIsSameExtent( ext, old_ex ) )
       {$ELSE}
         ( not GisIsSameExtent( pext^, old_ex ) )
       {$ENDIF}
       and
       ( Uid > 0 )
    then begin

        if GisLockLessThan( currmode, TGIS_Lock.Internal ) then
          Layer.Extent3D := GisMaxExtent3D( Layer.Extent3D, ext3D ) ;
        UpdateIndex ;
    end ;
  finally
    lockMode     := TGIS_Lock.None ;
    lockModified := False       ;
  end ;
end ;

function TGIS_Shape.AddPointBearing(
  const _bearing  : Double ;
  const _distance : Double
) : Boolean ;
begin
  Result := AddPointBearing( _bearing, _distance, False ) ;
end ;

function TGIS_Shape.AddPointBearing(
  const _bearing  : Double ;
  const _distance : Double ;
  const _compass  : Boolean
) : Boolean ;
var
  angle    : Double     ;
  ptg1     : TGIS_Point ;
  ptg2     : TGIS_Point ;
  new_ptg  : TGIS_Point ;
  pt_cnt   : Integer    ;
  part_cnt : Integer    ;
  sa, ca   : Double     ;

  function _adjust( _a : Double ): Double ;
  begin
    repeat
      if _a <= -Pi then _a := _a + 2*Pi ;
      if _a >   Pi then _a := _a - 2*Pi ;
    until ( _a > -Pi ) and ( _a <= Pi ) ;
    Result := _a ;
  end ;

  function _arctan2( _x, _y : Double ) : Double ;
  var
    at2 : Double ;
  begin
    if _y = 0 then begin
      if _x>=0 then Result :=  Pi/2
              else Result := -Pi/2
    end
    else begin
      at2 := ArcTan( Abs( _x / _y ) ) ;
      if _y > 0 then begin
        if _x > 0 then Result := at2
                  else Result := _adjust( -at2 ) ;
      end
      else begin
        if _x > 0 then Result := _adjust(  Pi - at2 )
                  else Result := _adjust( -Pi + at2 ) ;
      end ;
    end ;
  end ;

begin
  Result := False ;

  part_cnt := self.GetNumParts ;
  if part_cnt < 1 then exit ;

  pt_cnt := self.GetPartSize( part_cnt - 1 ) ;

  if _compass then begin
    if pt_cnt < 1 then exit ;
    if ( FShapeType = TGIS_ShapeType.Polygon ) and ( pt_cnt > 1 ) and
       ( GisIsSamePoint( GetPoint( part_cnt -1, pt_cnt - 1 ),
                         GetPoint( part_cnt -1, 0 )
                        ) )  then
      ptg2 := GetPoint( part_cnt -1, pt_cnt - 2 )
    else
      ptg2 := GetPoint( part_cnt -1, pt_cnt - 1 ) ;

    angle := _bearing ;
  end
  else begin
    if pt_cnt < 2 then exit ;
    if ( FShapeType = TGIS_ShapeType.Polygon ) and ( pt_cnt > 2 ) and
       ( GisIsSamePoint( GetPoint( part_cnt -1, pt_cnt - 1 ),
                         GetPoint( part_cnt -1, 0 )
                        ) ) then begin
      ptg1 := GetPoint( part_cnt -1, pt_cnt - 3 ) ;
      ptg2 := GetPoint( part_cnt -1, pt_cnt - 2 ) ;
    end
    else begin
      ptg1 := GetPoint( part_cnt -1, pt_cnt - 2 ) ;
      ptg2 := GetPoint( part_cnt -1, pt_cnt - 1 ) ;
    end ;

    angle := _arctan2( ( ptg2.X - ptg1.X ), ( ptg2.Y - ptg1.Y ) ) ;
    angle := angle + _bearing ;
  end ;

  SinCos( angle, sa, ca ) ;
  {$IFDEF GIS_NORECORDS}
    new_ptg := new TGIS_Point();
  {$ENDIF}

  new_ptg.X := ptg2.X + ( sa * _distance ) ;
  new_ptg.Y := ptg2.Y + ( ca * _distance ) ;

  AddPoint( new_ptg ) ;

  Result := True ;
end ;

procedure TGIS_Shape.AddPart ;
var
  {$IFDEF MANAGED}
    ext  : TGIS_Extent ;
  {$ELSE}
    pext : PGIS_Extent ;
  {$ENDIF}
begin
  ensureProperPart ;

  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  unmapGeometry ;
  FIsFixed := False ;

  if IsEmpty then begin
    reallocGeometry ;
    {$IFDEF MANAGED}
      FParts.WriteInt32( OFFSET_NUM_POINTS, 0 ) ;
      FParts.WriteInt32( OFFSET_NUM_PARTS,  1 ) ;
      FParts.WriteInt32( OFFSET_PARTS,      0 ) ;
    {$ELSE}
      PInteger(NativeInt(FParts) + OFFSET_NUM_POINTS)^ := 0 ;
      PInteger(NativeInt(FParts) + OFFSET_NUM_PARTS)^ := 1 ;
      PInteger(NativeInt(FParts) + OFFSET_PARTS)^ :=  0 ;
    {$ENDIF}
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        ext := new TGIS_Extent ;
      {$ENDIF}
      ext.XMin := 0 ;
      ext.XMax := 0 ;
      ext.YMin := 0 ;
      ext.YMax := 0 ;
      FParts.WriteDouble( 0 * sizeOf( Double ), ext.XMin ) ;
      FParts.WriteDouble( 1 * sizeOf( Double ), ext.YMin ) ;
      FParts.WriteDouble( 2 * sizeOf( Double ), ext.XMax ) ;
      FParts.WriteDouble( 3 * sizeOf( Double ), ext.YMax ) ;
    {$ELSE}
      pext := PGIS_Extent(FParts) ;
      pext^.XMin := 0 ;
      pext^.XMax := 0 ;
      pext^.YMin := 0 ;
      pext^.YMax := 0 ;
    {$ENDIF}
    if assigned( FPartTypes ) then
      {$IFDEF MANAGED}
        FPartTypes.WriteInt32( 0, 5 ) ;
      {$ELSE}
        PInteger(NativeInt(FPartTypes) )^ := 5 ;
      {$ENDIF}
  end
  else begin
    if GetPartSize(GetNumParts -1) > 0 then begin
      reallocGeometry ;

      {$IFDEF MANAGED}
        FParts.Inc( OFFSET_NUM_PARTS ) ;
      {$ELSE}
        inc( PInteger(NativeInt(FParts) + OFFSET_NUM_PARTS)^ ) ;
      {$ENDIF}
      {$IFDEF MANAGED}
        FParts.WriteInt32( OFFSET_PARTS + (GetNumParts - 1)* sizeOf(Integer),
                           GetNumPoints ) ;
      {$ELSE}
        PInteger( NativeInt(FParts) + OFFSET_PARTS +
                (GetNumParts -1)* sizeOf(Integer) )^
                := GetNumPoints ;
      {$ENDIF}
      if assigned( FPartTypes ) then
        {$IFDEF MANAGED}
          FPartTypes.WriteInt32( (GetNumParts - 1)* sizeOf(Integer), 5 ) ;
        {$ELSE}
          PInteger(NativeInt(FPartTypes)+(GetNumParts -1)* sizeOf(Integer) )^ := 5 ;
        {$ENDIF}
    end ;
  end ;
  layerModified( True ) ;
end ;

function TGIS_Shape.GetPoint(
  const _part : Integer ;
  const _pos  : Integer
) : TGIS_Point ;
{$IFDEF MANAGED}
  var
    off : Integer ;
{$ENDIF}
begin
  if FShape3D then begin
    Result := GisPoint2DFrom3D( GetPoint3D( _part, _pos ) ) ;
  end
  else begin
    // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
    {$IFDEF MANAGED}
      off := ( FParts.ReadInt32(
                 OFFSET_PARTS + _part * sizeOf(DWORD)
               ) + _pos
             ) * SIZEOF_TGIS_POINT ;
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Point ;
      {$ENDIF}
      Result.X := FPoints.ReadDouble( off ) ;
      Result.Y := FPoints.ReadDouble( off + sizeOf( Double ) ) ;
    {$ELSE}
      Result := PGIS_Point(
                  NativeInt(FPoints) +
                  (  ( PInteger(
                        NativeInt(FParts) +
                        OFFSET_PARTS + _part * sizeOf(DWORD)
                     )^ +  _pos
                     ) * SIZEOF_TGIS_POINT
                  )
                ) ^ ;
    {$ENDIF}
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project_Ref( Result ) ;
  end ;
end ;

procedure TGIS_Shape.GetPointEx(
  const _part : Integer ;
  const _pos  : Integer ;
  var   _x    : Double  ;
  var   _y    : Double
) ;
var
  ptg       : TGIS_Point   ;
  ptg3D     : TGIS_Point3D ;
    off     : Integer ;
begin
  if FShape3D then begin
    {$IFDEF MANAGED}
      off := FParts.ReadInt32(
               OFFSET_PARTS + _part * sizeOf(DWORD)
             ) + _pos ;
      {$IFDEF GIS_NORECORDS}
        ptg3D := new TGIS_Point3D ;
      {$ENDIF}
      ptg3D.X := FPoints.ReadDouble(
                   off * SIZEOF_TGIS_POINT
                 ) ;
      ptg3D.Y := FPoints.ReadDouble(
                   off * SIZEOF_TGIS_POINT + sizeOf( Double )
                 ) ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        ptg3D.Z := FPointsZ.ReadDouble( off * sizeOf( Double ) )
      else
        ptg3D.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        ptg3D.M := FPointsM.ReadDouble( off * sizeOf( Double ) )
      else
        ptg3D.M := 0 ;
    {$ELSE}
      off := PInteger(
               NativeInt(FParts) +
               OFFSET_PARTS + _part * sizeOf(DWORD)
             )^ + _pos ;

      ptg3D.X := PDouble(
                   NativeInt(FPoints) +
                   off * SIZEOF_TGIS_POINT
                 )^ ;
      ptg3D.Y := PDouble(
                   NativeInt(FPoints) +
                   off * SIZEOF_TGIS_POINT + sizeOf( Double )
                 ) ^ ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        ptg3D.Z := PDouble( NativeInt(FPointsZ) + off * sizeOf( Double ) )^
      else
        ptg3D.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        ptg3D.M := PDouble( NativeInt(FPointsM) + off * sizeOf( Double ) )^
      else
        ptg3D.M := 0 ;

    {$ENDIF}
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project3D_Ref( ptg3D ) ;
    _x := ptg3D.X ;
    _y := ptg3D.Y ;
  end
  else begin
    // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
    {$IFDEF MANAGED}
      off := ( FParts.ReadInt32(
                 OFFSET_PARTS + _part * sizeOf(DWORD)
               ) + _pos
             ) * SIZEOF_TGIS_POINT ;
      {$IFDEF GIS_NORECORDS}
        ptg := new TGIS_Point ;
      {$ENDIF}
      ptg.X := FPoints.ReadDouble( off ) ;
      ptg.Y := FPoints.ReadDouble( off + sizeOf( Double ) ) ;
    {$ELSE}
      ptg := PGIS_Point( NativeInt(FPoints) +
               ( ( PInteger(
                   NativeInt(FParts) +
                   OFFSET_PARTS + _part * sizeOf(DWORD)
                 )^ +  _pos
               ) *   SIZEOF_TGIS_POINT
               )
             ) ^ ;
    {$ENDIF}
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project_Ref( ptg ) ;
    _x := ptg.X ;
    _y := ptg.Y ;
  end ;
end ;

{$IFDEF JAVA}
  procedure TGIS_Shape.GetPointEx2(
    const _part : Integer ;
    const _pos  : Integer ;
    const _ptg  : TGIS_Point3D ;
    const _pt   : TPointD
  ) ;
  var
    x, y, z, m : Double ;
    off        : Integer ;
  //  ptg3D       : TGIS_Point3D   ;
  begin
    if FShape3D then begin

        off := FParts.ReadInt32(
                 OFFSET_PARTS + _part * sizeOf(DWORD)
               ) + _pos ;

        x := FPoints.ReadDouble(
                     off * SIZEOF_TGIS_POINT
                   ) ;
        y := FPoints.ReadDouble(
                     off * SIZEOF_TGIS_POINT + sizeOf( Double )
                   ) ;

        if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
          z := FPointsZ.ReadDouble( off * sizeOf( Double ) )
        else
          z := 0 ;

        if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
          m := FPointsM.ReadDouble( off * sizeOf( Double ) )
        else
          m := 0 ;

      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then begin
        _ptg.X := x ;
        _ptg.Y := y ;
        _ptg.Z := z ;
        _ptg.M := m ;
        Layer.Project3D_Ref( _ptg ) ;
        _pt.X := _ptg.X ;
        _pt.Y := _ptg.Y ;
      end
      else begin
        _pt.X := x ;
        _pt.Y := y ;
      end
    end
    else begin
      // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
        off := ( FParts.ReadInt32(
                   OFFSET_PARTS + _part * sizeOf(DWORD)
                 ) + _pos
               ) * SIZEOF_TGIS_POINT ;
        x := FPoints.ReadDouble( off ) ;
        y := FPoints.ReadDouble( off + sizeOf( Double ) ) ;
        z := 0 ;
        m := 0 ;

      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then begin
        _ptg.X := x ;
        _ptg.Y := y ;
        _ptg.Z := z ;
        _ptg.M := m ;
        Layer.Project3D_Ref( _ptg ) ;
        _pt.X := _ptg.X ;
        _pt.Y := _ptg.Y ;
      end
      else begin
        _pt.X := x ;
        _pt.Y := y ;
      end ;
    end ;
  end ;
{$ENDIF}

function TGIS_Shape.GetPoint3D(
  const _part : Integer ;
  const _pos  : Integer
) : TGIS_Point3D ;
var
  off      : Integer ;
  old_lock : TGIS_Lock ;
begin
  if FShape3D then begin
    {$IFDEF MANAGED}
      off := FParts.ReadInt32(
                OFFSET_PARTS + _part * sizeOf(DWORD)
              ) + _pos ;
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Point3D ;
      {$ENDIF}
      Result.X := FPoints.ReadDouble(
                    off * SIZEOF_TGIS_POINT
                  ) ;
      Result.Y := FPoints.ReadDouble(
                    off * SIZEOF_TGIS_POINT + sizeOf( Double )
                  ) ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        Result.Z := FPointsZ.ReadDouble( off * sizeOf( Double ) )
      else
        Result.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        Result.M := FPointsM.ReadDouble( off * sizeOf( Double ) )
      else
        Result.M := 0 ;
    {$ELSE}
      off := PInteger(
                NativeInt(FParts) +
                OFFSET_PARTS + _part * sizeOf(DWORD)
              )^ + _pos ;

      Result.X := PDouble(
              NativeInt(FPoints) +
              off * SIZEOF_TGIS_POINT
            )^ ;
      Result.Y := PDouble(
              NativeInt(FPoints) +
              off * SIZEOF_TGIS_POINT + sizeOf( Double )
            ) ^ ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        Result.Z := PDouble( NativeInt(FPointsZ) + off * sizeOf( Double ) )^
      else
        Result.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        Result.M := PDouble( NativeInt(FPointsM) + off * sizeOf( Double ) )^
      else
        Result.M := 0 ;
    {$ENDIF}
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project3D_Ref( Result ) ;
  end
  else begin
    old_lock := lockMode ;
    lockMode := TGIS_Lock.Projection ; // turn off projection for a while

    Result := GisPoint3DFrom2D( GetPoint( _part, _pos ) ) ;

    lockMode := old_lock ;
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project3D_Ref( Result ) ;
  end ;
end ;

procedure TGIS_Shape.GetPoint3DEx (
  const _part : Integer ;
  const _pos  : Integer ;
  var   _x    : Double  ;
  var   _y    : Double  ;
  var   _z    : Double  ;
  var   _m    : Double
) ;
begin
  if FShape3D then begin
    GetPointEx( _part, _pos, _x, _y ) ;
    _z := 0 ;
    _m := 0 ;
  end
  else
    GetPointEx( _part, _pos, _x, _y ) ;
end ;

function TGIS_Shape.GetFirstPoint
  : TGIS_Point ;
begin
  Result := GetPoint( 0, 0 ) ;
end ;

function TGIS_Shape.GetFirstPoint3D
  : TGIS_Point3D ;
begin
  Result := GetPoint3D( 0, 0 ) ;
end ;

function TGIS_Shape.GetLastPoint
  : TGIS_Point ;
begin
  Result := GetPoint( GetNumParts - 1, GetPartSize( GetNumParts - 1 ) - 1 ) ;
end ;

function TGIS_Shape.GetLastPoint3D
  : TGIS_Point3D ;
begin
  Result := GetPoint3D( GetNumParts - 1, GetPartSize( GetNumParts - 1 ) - 1 ) ;
end ;

function TGIS_Shape.GetNumPoints
  : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  if assigned( FParts ) and assigned( FPoints ) then
    {$IFDEF MANAGED}
      Result := FParts.ReadInt32( OFFSET_NUM_POINTS )
    {$ELSE}
      Result := PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS )^
    {$ENDIF}
  else
    Result := 0 ;
end ;

function  TGIS_Shape.GetSnapPoint(
  const _ptg  : TGIS_Point ;
  const _prec : Double;
  var   _dist : Double
) : TGIS_Point ;
var
  i,j      : Integer ;
  tmp      : Double  ;
  min      : Double  ;
begin
  Result := _TGIS_Point(_ptg) ;      // default is the same point as input ;
  min    := Abs(_prec); // Abs() because negative values are valid in similar
                        // functions like TGIS_layerVector.Locate
  _dist  := GIS_MAX_DOUBLE ; // really far away :)

  for i:= 0 to GetNumParts-1 do begin
    for j:=0 to GetPartSize(i) -1 do begin
      tmp := GisPoint2Point( _ptg, GetPoint( i, j ))  ;
      if tmp < min then begin
        min := tmp ;
        Result := GetPoint( i, j ) ;
      end ;
    end ;
  end ;
  _dist := min ;
end ;

function  TGIS_Shape.GetSnapPoint3D(
  const _ptg  : TGIS_Point3D ;
  const _prec : Double;
  var   _dist : Double
) : TGIS_Point3D ;
var
  i,j      : Integer ;
  tmp      : Double ;
  min      : Double ;
begin
  Result := _TGIS_Point3D(_ptg) ;      // default is the same point as input ;
  min    := Abs(_prec); // Abs() because negative values are valid in similar
                        // functions like TGIS_layerVector.Locate
  _dist  := GIS_MAX_DOUBLE ; // really far away :)

  for i:= 0 to GetNumParts-1 do begin
    for j:=0 to GetPartSize(i) -1 do begin
      tmp := GisPoint2Point3D( _ptg, GetPoint3D( i, j ))  ;
      if tmp < min then begin
        min := tmp ;
        Result := GetPoint3D( i, j ) ;
      end ;
    end ;
  end ;
  _dist := min ;
end ;

function TGIS_Shape.GetNumParts
  : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  if assigned( FParts ) then
    {$IFDEF MANAGED}
      Result := FParts.ReadInt32( OFFSET_NUM_PARTS )
    {$ELSE}
      Result := PInteger( NativeInt(FParts) + OFFSET_NUM_PARTS )^
    {$ENDIF}
  else
    Result := 0 ;
end ;

function TGIS_Shape.GetPartSize(
  const _part : Integer
) : Integer ;
var
  numparts  : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint

  if IsEmpty then begin
    Result := 0 ;
    exit ;
  end ;

  // numparts := GetNumParts ;
  if assigned( FParts ) then
    {$IFDEF MANAGED}
      numparts := FParts.ReadInt32( OFFSET_NUM_PARTS )
    {$ELSE}
      numparts := PInteger( NativeInt(FParts) + OFFSET_NUM_PARTS )^
    {$ENDIF}
  else
    numparts := 0 ;

  if numparts = 0 then begin
    Result := 0 ;
    exit ;
  end ;

  if numparts=1 then begin
    assert( _part = 0 ) ;

    // Result := GetNumPoints ;
    {$IFDEF MANAGED}
      Result := FParts.ReadInt32( OFFSET_NUM_POINTS ) ;
    {$ELSE}
      Result := PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS )^ ;
    {$ENDIF}

    exit ;
  end ;

  if _part < numparts - 1 then begin
    // Result := getPartOffset(_part+1) - getPartOffset(_part)
    {$IFDEF MANAGED}
      Result := FParts.ReadInt32(
                  OFFSET_PARTS + ( _part + 1 ) * sizeOf( DWORD )
                ) -
                FParts.ReadInt32(
                  OFFSET_PARTS + ( _part     ) * sizeOf( DWORD )
                )
    {$ELSE}
      Result := PInteger(
                  NativeInt(FParts) +
                  OFFSET_PARTS +  ( _part + 1 ) * sizeOf( DWORD )
                )^ -
                PInteger(
                  NativeInt(FParts) +
                  OFFSET_PARTS +  _part * sizeOf( DWORD )
                )^
    {$ENDIF}
  end
  else begin
    // Result := GetNumPoints - getPartOffset(_part) ;
    {$IFDEF MANAGED}
      Result := FParts.ReadInt32( OFFSET_NUM_POINTS ) -
                FParts.ReadInt32( OFFSET_PARTS + _part * sizeOf( DWORD ) )
    {$ELSE}
      Result := PInteger( NativeInt(FParts) + OFFSET_NUM_POINTS )^ -
                PInteger( NativeInt(FParts) + OFFSET_PARTS +
                _part * sizeOf( DWORD ) )^
    {$ENDIF}
  end ;

end ;

function TGIS_Shape.GetPartType(
  const _part : Integer
) : TGIS_PartType ;
var
  numparts, ptype : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint
  Result := TGIS_PartType.Ring ;

  if IsEmpty then exit ;

  if assigned( FParts ) then
    {$IFDEF MANAGED}
      numparts := FParts.ReadInt32( OFFSET_NUM_PARTS )
    {$ELSE}
      numparts := PInteger( NativeInt(FParts) + OFFSET_NUM_PARTS )^
    {$ENDIF}
  else
    numparts := 0 ;

  if numparts = 0 then exit ;

  ptype := 5 ;
  if assigned( FPartTypes ) and ( _part < numparts ) then
    {$IFDEF MANAGED}
      ptype :=  FPartTypes.ReadInt32( ( _part ) * sizeOf( DWORD ) ) ;
    {$ELSE}
      ptype := PInteger(
                  NativeInt(FPartTypes) + ( _part ) * sizeOf( DWORD )
                )^ ;
    {$ENDIF}
  case ptype of
    0 : Result := TGIS_PartType.TriangleStrip ;
    1 : Result := TGIS_PartType.TriangleFan ;
    2 : Result := TGIS_PartType.OuterRing ;
    3 : Result := TGIS_PartType.InnerRing ;
    4 : Result := TGIS_PartType.FirstRing ;
    5 : Result := TGIS_PartType.Ring ;
    6 : Result := TGIS_PartType.Triangle
  else  Result := TGIS_PartType.Ring ;
  end ;
end ;

procedure TGIS_Shape.SetPartType(
  const _part : Integer ;
  const _type : TGIS_PartType
 ) ;
var
  numparts, ptype : Integer ;
begin
  // this implementation is not valid for TGIS_Point and TGIS_MultiPoint

  if assigned( FParts ) then
    {$IFDEF MANAGED}
      numparts := FParts.ReadInt32( OFFSET_NUM_PARTS )
    {$ELSE}
      numparts := PInteger( NativeInt(FParts) + OFFSET_NUM_PARTS )^
    {$ENDIF}
  else
    numparts := 0 ;

  if numparts = 0 then exit ;

  case _type of
    TGIS_PartType.TriangleStrip : ptype := 0 ;
    TGIS_PartType.TriangleFan   : ptype := 1 ;
    TGIS_PartType.OuterRing     : ptype := 2 ;
    TGIS_PartType.InnerRing     : ptype := 3 ;
    TGIS_PartType.FirstRing     : ptype := 4 ;
    TGIS_PartType.Ring          : ptype := 5 ;
    TGIS_PartType.Triangle      : ptype := 6
  else                            ptype := 5 ;
  end ;

  if assigned( FPartTypes ) and ( _part < numparts ) then
    {$IFDEF MANAGED}
      FPartTypes.WriteInt32( _part* sizeOf(Integer), ptype ) ;
    {$ELSE}
      PInteger(NativeInt(FPartTypes)+_part* sizeOf(Integer) )^ := ptype ;
    {$ENDIF}

  layerModified( True ) ;
end ;

function TGIS_Shape.AsPoint
  : TGIS_ShapePoint ;
begin
  Result := TGIS_ShapePoint.Create( FDimension ) ;
  Result.CopyGeometry( self )
end ;

function  TGIS_Shape.AsMultiPoint
  : TGIS_ShapeMultiPoint ;
begin
  Result := TGIS_ShapeMultiPoint.Create( FDimension ) ;
  Result.CopyGeometry( self )
end ;

function  TGIS_Shape.AsArc
  : TGIS_ShapeArc ;
begin
  Result := TGIS_ShapeArc.Create( FDimension ) ;
  Result.CopyGeometry( self )
end ;

function  TGIS_Shape.AsPolygon
  : TGIS_ShapePolygon ;
begin
  Result := TGIS_ShapePolygon.Create( FDimension ) ;
  Result.CopyGeometry( self )
end ;

procedure TGIS_Shape.Reset ;
begin
  FIsFixed := False ;

  {$IFDEF MANAGED}
    if not IsEmpty then begin
      if assigned( FParts  ) then begin
        if not IsMapped then
          FParts.Reset ;
        FreeObject( FParts  ) ;
      end ;
      if assigned( FPoints  ) then begin
        if not IsMapped then
          FPoints.Reset ;
        FreeObject( FPoints ) ;
      end ;
      if not assigned( FParts ) and
         not assigned( FPoints ) then
        FIsEmpty := True ;
    end ;
  {$ELSE}
    if not IsMapped then begin
      if not IsEmpty then begin
        if assigned( FParts  ) then FreeMem( FParts  ) ;
        if assigned( FPoints ) then FreeMem( FPoints ) ;
        FParts  := nil ;
        FPoints := nil ;
        if assigned( FPointsZ ) then FreeMem( FPointsZ ) ;
        FPointsZ := nil ;
        if assigned( FPointsM ) then FreeMem( FPointsM ) ;
        FPointsM := nil ;
        FIsEmpty := True ;
      end ;
    end ;
  {$ENDIF}
  layerModified( True ) ;
end ;

procedure TGIS_Shape.ResetModified ;
begin
  FIsModified := False ;
end;

procedure TGIS_Shape.Assign(
  const _source : TGIS_Shape
) ;
begin
  if ShapeType <> _source.ShapeType then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_WRONGSHAPE ), '', 0 ) ;
  end ;
  Recreate( _source, nil, False, 0, nil ) ;
  layerModified( True ) ;
end ;

function TGIS_Shape.AddToLayer
  : TGIS_Shape ;
var
  i    : Integer ;
  lname : String  ;
  oval  : Variant ;
begin
  Result             := CreateCopy ;
  Result.FUid        := Layer.GetNewUid ;
  Result.FIsNewShape := True ;

  for i := 0 to Layer.FFields.Count -1 do begin
    lname := Layer.FieldInfo(i).NewName ;
    oval  := GetField( lname ) ;
    Result.SetField( lname, oval ) ;
  end ;

  Result.FIsEditable    := True ;
  Layer.Items.Add( Result ) ;
  Result.AddToIndex ;

  Result.layerModified( False ) ;
end ;

function TGIS_Shape.MakeEditable
  : TGIS_Shape ;
var
  ipos : Integer ;
  i    : Integer ;
begin
  Result := self ;

  if IsEditable then exit ;

  if assigned( ParentShape ) and
    ( ParentShape.ShapeType = TGIS_ShapeType.Complex ) then begin
    exit ;
  end;

  if Uid = 0 then begin
    Result             := CreateCopy      ;
    Result.FUid        := Layer.GetNewUid ;
    Result.FIsNewShape := True ;

    Result.FIsEditable := True ;
    Layer.Items.Add( Result ) ;
    Result.AddToIndex ;

    exit ;
  end ;

  if Layer.getShapePos( Uid, ipos ) then begin
    Result := TGIS_Shape( Layer.Items[ipos] ) ;
    Result.FIsEditable := True ;
  end
  else begin
    Result := CreateCopy ;
    Result.FManageRTree   := True ;
    Result.FIsEditable    := True ;
    Result.oldIndexExtent := _TGIS_Extent( Result.Extent ) ;
    if ipos < Layer.Items.Count then
      Layer.Items.Insert( ipos, Result )
    else
      Layer.Items.Add( Result ) ;

    // synchronize against all cursors
    for i:= 0 to high( Layer.cursorState ) do begin
      with Layer.cursorState[ i ] do begin
        if not curInUse then continue ;
        if curPos >= ipos then
          inc( curPos ) ;
        if curShape = self then begin
          curPos := ipos ;
          Layer.cursorShapeInternal( i ) ;
        end ;
      end ;
    end;
  end ;

end ;

procedure TGIS_Shape.Delete ;
begin
  FIsDeleted := True ;
  if assigned( Layer ) then
    Layer.SelectedList.Remove( Uid ) ;
  UpdateIndex ;
  layerModified( False ) ;
end ;

procedure TGIS_Shape.AddToIndex ;
begin
  if not Layer.UseRTree then exit ;
  if Layer.RTreeFile.IsReadOnly then begin
    Layer.UseRTree := False ;
    exit ;
  end ;

  FManageRTree := True ;

  if not IsEmpty then begin
    Layer.RTreeFile.Insert( Extent, Uid ) ;
    layerModified( False ) ;
    oldIndexExtent := _TGIS_Extent( Extent ) ;
  end
  else begin
    Layer.RTreeFile.Insert( GisExtent(0,0,0,0), Uid );
    layerModified( False ) ;
    oldIndexExtent := GisExtent(0,0,0,0) ;
  end ;
end ;

procedure TGIS_Shape.UpdateIndex   ;
var
  r : Boolean ;
begin
  if not ManageRTree then exit ;
  if Layer.RTreeFile.IsReadOnly then begin
    Layer.UseRTree := False ;
    exit ;
  end ;

  if not ManageRTree then exit ;

  if ( not IsDeleted )
     and
     GisIsSameExtent( oldIndexExtent, Extent )
  then
    exit ;

  if assigned( ParentShape ) and
    ( ParentShape.ShapeType = TGIS_ShapeType.Complex ) then begin
    ParentShape.UpdateIndex ;
    exit ;
  end ;

  r := Layer.RTreeFile.Delete( oldIndexExtent, Uid );

  if r then begin
    layerModified( False ) ;
    assert( r = True ) ; // should not happen
  end ;

  if not IsDeleted then begin
    if GisIsSameExtent( Extent, GisNoWorld ) then begin
      Layer.RTreeFile.Insert( GisExtent( 0, 0, 0, 0 ), Uid );
      oldIndexExtent := GisExtent( 0, 0, 0, 0 ) ;
    end
    else begin
      Layer.RTreeFile.Insert( Extent, Uid );
      oldIndexExtent := _TGIS_Extent( Extent ) ;
    end ;
    layerModified( False ) ;
  end ;
end ;

procedure TGIS_Shape.DrawChart;
var
  vwr    : IGIS_Viewer ;
  shp    : TGIS_Shape  ;
begin
  vwr := Viewer.Ref ;
  if not assigned( vwr ) then exit ;

  with vwr do begin
    if not assigned( Layer ) or
       not assigned( Layer.Renderer ) then exit ;

    if GisTestLabelPosition( TGIS_LabelPosition.Flow, self.Params.Labels.Position )
    then begin
      shp := getTruncatedShapeEx ;
      try
        if shp = nil then exit ;
        TGIS_RendererAbstract( Layer.Renderer ).RenderChart( shp ) ;
      finally
        freeTruncatedShape( shp ) ;
      end ;
    end
    else begin
      if isTruncatedPointEx( PointOnShape ) then
        exit ;
      TGIS_RendererAbstract( Layer.Renderer ).RenderChart( self ) ;
    end ;
  end ;
end ;

procedure TGIS_Shape.DrawLabel;
var
  vwr    : IGIS_Viewer ;
  shp    : TGIS_Shape  ;
begin
  vwr := Viewer.Ref ;
  if not assigned( vwr ) then exit ;

  if IsHidden or IsDeleted or IsEmpty then exit ;

  with vwr do begin
    if not assigned( Layer ) or
       not assigned( Layer.Renderer ) then exit ;

    if GisTestLabelPosition( TGIS_LabelPosition.Flow, self.Params.Labels.Position )
    then begin
      shp := getTruncatedShapeEx ;
      try
        if shp = nil then exit ;
        TGIS_RendererAbstract( Layer.Renderer ).RenderLabel( shp ) ;
      finally
        freeTruncatedShape( shp ) ;
      end ;
    end
    else begin
      if isTruncatedPointEx( PointOnShape ) then
        exit ;
      TGIS_RendererAbstract( Layer.Renderer ).RenderLabel( self ) ;
    end ;
  end ;
end ;

procedure TGIS_Shape.DrawLabel(
  var _points : TGIS_DrawBuf
) ;
var
  vwr    : IGIS_Viewer ;
  shp    : TGIS_Shape  ;
begin
  vwr := Viewer.Ref ;
  if not assigned( vwr ) then exit ;

  with vwr do begin
    if not assigned( Layer ) or
       not assigned( Layer.Renderer ) then exit ;

    if GisTestLabelPosition( TGIS_LabelPosition.Flow, self.Params.Labels.Position )
    then begin
      shp := getTruncatedShapeEx ;
      try
        if shp = nil then exit ;
        TGIS_RendererAbstract( Layer.Renderer ).RenderLabel( shp, _points ) ;
      finally
        freeTruncatedShape( shp ) ;
      end ;
    end
    else begin
      if isTruncatedPointEx( PointOnShape ) then
        exit ;
      TGIS_RendererAbstract( Layer.Renderer ).RenderLabel( self, _points ) ;
    end ;
  end ;
end ;

function TGIS_Shape.GetField(
  const _name : String
) : Variant ;
var
  id   : Integer ;
  fld  : TGIS_FieldInfo ;

begin
  Result := GetFieldEx( _name ) ;

  if VarIsNull( Result ) or VarIsEmpty( Result ) then begin
    id := Layer.FindField( _name ) ;
    if id >= 0 then begin
      fld := Layer.FieldInfo( id ) ;
      if assigned( fld ) then
        Result := GisDefaultField( fld.FieldType ) ;
    end
    else
      Result := Unassigned ;
  end ;
end ;

function TGIS_Shape.GetFieldEx(
  const _name : String
) : Variant ;
begin
  Result := GetFieldEx( _name, 0 ) ;
end ;

function TGIS_Shape.GetFieldEx(
  const _name     : String ;
  const _cursor   : Integer
) : Variant ;
begin
  Result := GetFieldEx( _name, _cursor, False ) ;
end ;

function TGIS_Shape.GetFieldEx(
  const _name     : String  ;
  const _rule     : Boolean
) : Variant ;
begin
  Result := GetFieldEx( _name, 0, _rule ) ;
end ;

function TGIS_Shape.GetFieldEx(
  const _name     : String  ;
  const _cursor   : Integer ;
  const _rule     : Boolean
) : Variant ;
var
  id      : Integer        ;
  fld     : TGIS_FieldInfo ;
  cfg     : TGIS_ConfigShapeStyle ;
  wasjoin : Boolean      ;
  fname   : String       ;

    {$IFDEF CLR}
      dr    : IDataReader  ;
      i     : Integer      ;
      {$IFDEF DEBUG}
        found : Boolean    ;
      {$ENDIF}
    {$ENDIF}

  iscs     : Boolean ;

  function _t( const _tmp : String ) : Boolean ;
  begin
    Result := CompareText( _name, _tmp ) = 0 ;
  end ;

  {$IFNDEF GIS_NOADO_JOIN}
    function _convertADOFieldCP : Variant ;
    begin
      Result := ConvertADOFieldCP(
                  _Recordset(Layer.JoinADO).Fields[ fname ],
                  Layer.JoinCodePage
                ) ;
    end ;
  {$ENDIF}
  {$IFNDEF GIS_NOJDBC}
    function _convertADOFieldCPJDBC : Variant ;
    begin
      Result := ConvertJDBCFieldCP(
                  java.sql.ResultSet(Layer.JoinJDBC).getString( fname ),
                  Layer.JoinCodePage
                ) ;
    end ;
  {$ENDIF}

begin
  Result := Unassigned ;

  fname := '' ; // to avoid hints

  if not assigned( Layer ) then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDNOEXIST ), _name, 0) ;
  end ;

  iscs := Layer.CS.EPSG > 0  ;

  id := Layer.FindField( _name ) ;

  if ( id < 0 ) and  _t( GIS_SQL_ORIGINAL_UID_NAME ) then begin
    Result := Uid        ;
    exit ;
  end ;

  // built-in fields?
  if id >= GIS_FIELD_ID_UID then begin
    Result := getVirtualField( id, iscs ) ;
    if not VarIsEmpty( Result ) then
      exit ;
  end ;

  if ( id < 0 ) and ( _name = GIS_FIELD_STYLE ) then begin
    cfg := TGIS_ConfigShapeStyle.Create ;
    try
      Params.SaveToConfig( cfg );
      Result := cfg.Text;
      exit ;
    finally
      FreeObject( cfg ) ;
    end;
  end;

  // joined fields?
  if id < 0 then begin
    try
      if syncJoin( _cursor ) then begin
        if IsStringEmpty( _name ) then exit ;

        wasjoin := False ;

        {$IFNDEF GIS_NODB}
          if ( not wasjoin) and assigned( Layer.JoinDB ) then begin
            wasjoin := True ;
            fname  := FromJoinFieldName( _name ) ;
            Result := ConvertDBFieldCP(
                        Layer.JoinDB.FieldByName( fname ),
                        Layer.JoinCodePage
                      ) ;
          end ;
        {$ENDIF}


        {$IFDEF CLR}
          if ( not wasjoin) and assigned( Layer.JoinNET ) then begin
            wasjoin := True ;
            fname := FromJoinFieldName( _name ) ;
            if Layer.JoinNET is IDataReader then begin
              dr := Layer.JoinNET as IDataReader ;
              {$IFDEF DEBUG}
                found := False ;
              {$ENDIF}
              for i := 0 to dr.GetSchemaTable.Rows.Count do begin
                if dr.GetSchemaTable.Rows[i]['ColumnName'].ToString =
                   fname
                then begin
                  {$IFDEF DEBUG}
                    found := True ;
                  {$ENDIF}
                  break ;
                end ;
              end ;
              {$IFDEF DEBUG}
                assert( found ) ;
              {$ENDIF}
              Result := ConvertNETFieldCP(
                          dr,
                          dr.GetSchemaTable.Rows[i],
                          Layer.JoinCodePage
                        ) ;
            end
            else if Layer.JoinNET is DataTable then begin
              Result := ConvertNETFieldCP(
                          DataTable(Layer.JoinNET).Rows[Layer.rJoin.RowNET],
                          DataTable(Layer.JoinNET).Columns[ fname ],
                          Layer.JoinCodePage
                        )
            end ;
          end ;
        {$ENDIF}


        {$IFNDEF GIS_NOADO_JOIN}
          if ( not wasjoin) and assigned( Layer.JoinADO ) then begin
            //wasjoin := True ;
            fname  := FromJoinFieldName( _name ) ;
            Result := _convertADOFieldCP ;
          end ;
        {$ENDIF}
        {$IFNDEF GIS_NOJDBC}
          if ( not wasjoin) and assigned( Layer.JoinJDBC ) then begin
            //wasjoin := True ;
            fname  := FromJoinFieldName( _name ) ;
            Result := _convertADOFieldCPJDBC ;
          end ;
        {$ENDIF}
      end ;
    except
    end ;
    exit ;
  end ;

  fld := Layer.FieldInfo( id ) ;

  if assigned( mappedFields ) then
    if ( id >= 0 ) and mappedFields.Exists( id ) then begin
      Result := mappedFields[id] ;

    end ;

  if VarIsEmpty( Result ) then begin
    if fld.Saved then begin // saved field
      try
        Result := Layer.getFieldInternal( Uid, fld.Name, FCursor ) ;
      except
        Result := Unassigned ;
      end ;
    end
    else
      Result := NullVar ;
  end ;

  {$IFDEF JAVA}
    if _rule and assigned( fld.Rules) then begin
      Result := TGIS_FieldRule(fld.Rules).ResolveGet(Result, fld);
    end;
  {$ELSE}
    if _rule and assigned( fld.Rules ) then begin
      Result := TGIS_FieldRule( fld.Rules ).ResolveGet( Result, fld ) ;
    end ;
  {$ENDIF}
end ;

procedure TGIS_Shape.SetField(
  const _name : String ;
  const _val  : Variant
) ;
var
  id   : Integer ;
  oval : Variant ;
  i64  : Int64   ;
  fld  : TGIS_FieldInfo ;
  msg  : String  ;
  itmp : Integer ;

  function _t( const _tmp : String ) : Boolean ;
  begin
    Result := CompareText( _name, _tmp ) = 0 ;
  end ;
begin
  if not assigned( Layer ) then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDNOEXIST ), _name, 0 ) ;
  end ;

  id := Layer.FindField( _name ) ;

  if id < 0 then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDNOEXIST ), _name, 0 ) ;
  end
  else if id >= GIS_FIELD_ID_UID then begin
    if _t( GIS_FIELD_SELECTED ) then
      IsSelected := Boolean( _val )
    else if _t( GIS_FIELD_HIDDEN ) then
      IsHidden := Boolean( _val )
    else begin
      raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDREADONLY ), _name, 0 ) ;
    end ;
    exit ;
  end ;

  fld := Layer.FieldInfo( id ) ;

  if TGIS_FieldFlags.ReadOnly in Layer.FieldInfo( id ).Flags then begin
    raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_FIELDREADONLY ), _name, 0 ) ;
  end ;

  if VarIsEmpty( _val ) then
    oval := NullVar
  else begin
    if assigned( fld.Rules ) then begin
      if not TGIS_FieldRule( fld.Rules ).ResolveSet( _val, oval, msg ) then
        raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_WRONGVALUE ), msg, 0 ) ;
    end
    else
      oval := _val ;
  end ;

  if not assigned( mappedFields ) then
    mappedFields := TGIS_FieldList.Create ;

  with Layer.FieldInfo( id ) do begin
    if VarIsNull( oval ) then
      mappedFields[id] := NullVar
    else begin
      case FieldType of
        TGIS_FieldType.String :
           begin
             mappedFields[id] := oval ;
             {$IFDEF OXYGENE}
               itmp := VarToString( oval ).Length ;
             {$ELSE}
               itmp := System.length( oval ) ;
             {$ENDIF}
             if itmp > NewWidth then
               NewWidth := itmp ;
           end ;
        TGIS_FieldType.Number :
           begin
             try
               case VarTypeEx( oval ) of
                 varExAnsiString,
                 varExWideString :
                   oval := DotStrToFloat( VarToString( oval ) ) ;
               end ;
               if NewDecimal = 0 then begin
                 i64 := VarToInt64( oval ) ;
                 if Abs( i64 ) > Abs( high( Integer ) ) then begin
                   mappedFields[id] := i64 ;
                 end
                 else
                   mappedFields[id] := VarToInt32( oval )
               end
               else
                 mappedFields[id] := VarToDouble(oval) ;
             except
               raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_WRONGFLOAT ), VarToString( oval ), 0 ) ;
             end ;
           end ;
        TGIS_FieldType.Float :
           begin
             try
               case VarTypeEx( oval ) of
                 varExAnsiString,
                 varExWideString :
                   oval := DotStrToFloat( VarToString( oval ) ) ;
               end ;

               mappedFields[id] := VarToDouble(oval) ;
             except
               raise EGIS_Exception.Create( _rsrc( GIS_RS_ERR_WRONGFLOAT ), VarToString( oval ), 0 ) ;
             end ;
           end ;
        TGIS_FieldType.Boolean :
           begin
             case VarTypeEx( oval ) of
               varExAnsiString,
               varExWideString :
                 begin
                   {$IFDEF OXYGENE}
                      if String( oval ).Length < 1 then
                   {$ELSE}
                     if System.Length( oval ) < 1 then
                   {$ENDIF}
                      raise EGIS_Exception.Create(
                               _rsrc( GIS_RS_ERR_WRONGBOOLEAN ), VarToString( oval ), 0
                            ) ;

                   case UpCase( VarToString( oval )[StringFirst] ) of
                     'T', '1', 'Y' : mappedFields[id] := True  ;
                     'F', '0', 'N' : mappedFields[id] := False ;
                     else            raise EGIS_Exception.Create(
                                             _rsrc( GIS_RS_ERR_WRONGBOOLEAN ),
                                             VarToString( oval ),
                                             0
                                           ) ;
                   end ;
                 end ;
               else
                 begin
                   try
                     mappedFields[id] := VarToBoolean( oval ) ;
                   except
                     raise EGIS_Exception.Create(
                             _rsrc( GIS_RS_ERR_WRONGBOOLEAN ),
                             VarToString( oval ),
                             0
                           ) ;
                   end ;
               end ;
             end ;
           end ;
        TGIS_FieldType.Date :
           begin
             try
               case VarTypeEx( oval ) of
                 varExAnsiString,
                 varExWideString :
                   mappedFields[id] := VarAsType( oval, varDate ) ;
                 varExFloat :
                   mappedFields[id] := VarToDateTime( oval )
                 else
                   mappedFields[id] := oval ;
               end ;

             except
               raise EGIS_Exception.Create(
                       _rsrc( GIS_RS_ERR_WRONGDATE ),
                       VarToString( oval ),
                       0
                     ) ;
             end ;
           end ;
      end ;
    end ;
  end ;

  layerModified( False ) ;

  {$IFDEF OXYGENE}
    if assigned( Layer ) and GisLockLessThan( lockMode, TGIS_Lock.Internal ) and
       assigned( Layer.FOnShapeFieldChange ) then
        Layer.FOnShapeFieldChange( Layer,
                                   TGIS_ShapeFieldChangeEventArgs.Create(
                                      Self, id
                                    )
                                  ) ;
  {$ELSE}
    if assigned( Layer ) and GisLockLessThan( lockMode, TGIS_Lock.Internal ) and
      assigned( Layer.ShapeFieldChangeEvent ) then
        Layer.ShapeFieldChangeEvent( Layer, Self, id ) ;
  {$ENDIF}
end ;

procedure TGIS_Shape.SetFieldsDefaulRuleValue ;
var
  i    : Integer        ;
  fld  : TGIS_FieldInfo ;
  vtmp : Variant        ;
begin
  for i:=0 to Layer.Fields.Count -1 do begin
    fld := Layer.FieldInfo( i ) ;
    if assigned( fld.Rules ) then begin
      vtmp := TGIS_FieldRule( fld.Rules ).Values.DefaultValue ;
      try
        if not ( VarIsEmpty( vtmp ) or VarIsNull( vtmp ) ) then
          SetField( fld.NewName, vtmp ) ;
      except
      end ;
    end ;
  end ;
end ;

function TGIS_Shape.IsFieldModified(
  const _field : String
) : Boolean ;
var
  id : Integer ;
begin
  Result := False ;

  id := Layer.FindField( _field ) ;

  if assigned( mappedFields ) then begin
    if ( id >= 0 ) and mappedFields.Exists( id ) then begin
      Result := not VarIsEmpty( mappedFields[ id ] ) ;
    end ;
  end ;
end ;

function TGIS_Shape.IsFieldModifiedEx(
  const _id : Integer
) : Boolean ;
begin
  Result := False ;

  if ( _id < 0 ) or ( _id >= Layer.Fields.Count ) then exit ;

  if assigned( mappedFields ) then
    if mappedFields.Exists( _id ) then
      Result := not VarIsEmpty( mappedFields[ _id ] ) ;
end ;

function TGIS_Shape.GetLabel
  : String ;
begin
  Result := getLabelInternal ;
end;

function TGIS_Shape.GetLabelPlain(
  const _all_lines : Boolean
) : String ;
var
  i      : Integer ;
  s      : String  ;
  res    : TStringBuilder ;
  c      : Char    ;
  state  : Integer ;
  level  : Integer ;
  marker : String  ;
begin
  s := getLabelInternal ;

  res := TStringBuilder.Create ;
  try
    level := 0 ;
    state := 0 ;
    for i := StringFirst to StringLast( s ) do begin
      c := s[i] ;

      if      c = '<' then
              inc( level )
      else if c = '>' then
              dec( level ) ;

      case state of
        0 :  if c = '<' then begin
                marker := '' ;
                state  := 1  ;
             end
             else begin
               res.Append( c ) ;
             end;
        1 :  if c = '>' then begin
               if level <> 0 then
                 level := 999 ;  // eliminate <<xxx>> cases

               if ( not _all_lines ) and
                  (
                    ( marker ='BR' ) or
                    ( marker ='HR' ) or
                    ( marker ='P'  )
                  )
               then begin
                 state := 0 ;
                 break
               end
               else begin
                 state := 0 ;
                 res.Append( ' ' ) ;
               end;
             end
             else begin
               marker := marker + UpCase( c ) ;
             end;
        else begin
               assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
             end;

      end ;
    end ;
    if ( level <> 0 ) or ( state <> 0 ) then
      Result := s  //not a HTML text
    else
      Result := res.ToString ;
  finally
    FreeObject( res ) ;
  end;

end ;

function TGIS_Shape.Distance(
  const _ptg : TGIS_Point ;
  const _prec : Double
) : Double ;
var
  part_no : Integer ;
  dist    : Double ;
  proj    : TGIS_Point ;
begin
  dist := GIS_MAX_DOUBLE ; // really far away :)

  for part_no := 0 to GetNumParts - 1 do // all parts
    dist := Min( Distance2Part( _ptg, _prec, part_no, proj ), dist ) ;
  Result := dist ;
end ;

function TGIS_Shape.DistanceCS(
  const _ptg : TGIS_Point ;
  const _prec : Double
) : Double ;
var
  part_no : Integer ;
  dist    : Double ;
  proj    : TGIS_Point ;
begin
  dist := GIS_MAX_DOUBLE ;

  for part_no := 0 to GetNumParts - 1 do // all parts
    dist := Min( Distance2PartCS( _ptg, _prec, part_no, proj ), dist ) ;

  Result := dist ;
end ;

function TGIS_Shape.Centroid
  : TGIS_Point ;
begin
  Result.X := 0 ;
  Result.Y := 0 ;
end ;

function TGIS_Shape.Distance2Shape(
  const _shp : TGIS_Shape
) : Double ;
var
  partno1, pointno1    : Integer    ;
  partno2, pointno2    : Integer    ;
  partsize1, partsize2 : Integer    ;
  line1A, line1B       : TGIS_Point ;
  line2A, line2B       : TGIS_Point ;
  shp1, shp2           : TGIS_Shape ;
  ispoint1, ispoint2   : Boolean    ;
begin
  Result := GIS_MAX_DOUBLE ;

  if self.IsEmpty             or
     ( not assigned( _shp ) ) or
     _shp.IsEmpty
  then begin
    Result := -1 ;
    exit ;
  end ;

  if not Relate( _shp, RELATE_DISJOINT ) then begin
    Result := 0 ;
    exit ;
  end ;

  shp1 := self ;
  shp2 := _shp ;

  for partno1 := 0 to shp1.GetNumParts -1 do begin

    partsize1 := shp1.GetPartSize( partno1 ) ;
    for pointno1 := 0 to partsize1 - 1 do begin

      if ( partsize1 > 1 ) and ( pointno1 = partsize1 - 1 ) then
        break ;

      line1A := shp1.GetPoint( partno1, pointno1     ) ;
      if partsize1 > 1 then begin
        line1B := shp1.GetPoint( partno1, pointno1 + 1 ) ;
        ispoint1 := False ;
      end
      else
        ispoint1 := True ;

      for partno2 := 0 to shp2.GetNumParts -1 do begin

        partsize2 := shp2.GetPartSize( partno2 ) ;
        for pointno2 := 0 to partsize2 - 1 do begin

          if ( partsize2 > 1 ) and ( pointno2 = partsize2 - 1 ) then
            break ;

          line2A := shp2.GetPoint( partno2, pointno2     ) ;
          if partsize2 > 1 then begin
            line2B := shp2.GetPoint( partno2, pointno2 + 1 ) ;
            ispoint2 := False ;
          end
          else
            ispoint2 := True ;

          if      ispoint1 and ispoint2 then
                  Result := Min( Result,
                                 GisPoint2Point( line1A, line2A )
                               )
          else if ispoint1 then
                  Result := Min( Result,
                                 GisLine2Point( line2A, line2B, line1A )
                               )
          else if ispoint2 then
                  Result := Min( Result,
                                 GisLine2Point( line1A, line1B, line2A )
                               )
          else    Result := Min( Result,
                                 GisLine2Line( line1A, line1B, line2A, line2B )
                               ) ;
          if Result <= 0 then begin
            Result := 0 ; // to avoid rounding errors etc.
            break ;
          end ;

        end ;

        if Result <= 0 then begin
          break ;
        end ;

      end ;

    end ;

  end ;

end ;

function TGIS_Shape.Distance2ShapeCS(
  const _shp : TGIS_Shape
) : Double ;
var
  dst  : Double ;
  tmp  : Double ;
  pt   : TGIS_Point ;
  ipa1 : Integer ;
  ipo1 : Integer ;
  ipa2 : Integer ;
  ipo2 : Integer ;
  tmp1 : Double ;
  tmp2 : Double ;
  opt1 : TGIS_Point ;
  opt2 : TGIS_Point ;
  i : Integer ;
  j : Integer ;
  k : Integer ;
  l : Integer ;
begin
  dst := GIS_MAX_DOUBLE ;

  if self.IsEmpty             or
     ( not assigned( _shp ) ) or
     _shp.IsEmpty
  then begin
    Result := -1 ;
    exit ;
  end ;

  if not Relate( _shp, RELATE_DISJOINT ) then begin
    Result := 0 ;
    exit ;
  end ;

  ipa1 := 0 ;
  ipo1 := 0 ;
  ipa2 := 0 ;
  ipo2 := 0 ;

  for i := 0 to GetNumParts - 1 do begin
    for j := 0 to GetPartSize( i ) - 1 do begin
      pt := pointToWGS( GetPoint( i, j ) ) ;
      for k := 0 to _shp.GetNumParts - 1 do begin
        for l := 0 to _shp.GetPartSize( k ) - 1 do begin
          tmp := haversineFormula(
            pt, pointToWGS( _shp.GetPoint( k, l ) )
          ) ;
          if tmp < dst then begin
            ipa1 := i ;
            ipo1 := j ;
            ipa2 := k ;
            ipo2 := l ;
            dst := tmp ;
          end ;
        end ;
      end ;
    end ;
  end ;

  indexDist2PartCS := ipo1 ;
  tmp1 := Distance2PartCS( _shp.GetPoint( ipa2, ipo2 ), 0, ipa1, opt1 ) ;
  indexDist2PartCS := -1 ;

  _shp.indexDist2PartCS := ipo2 ;
  tmp2 := _shp.Distance2PartCS( GetPoint( ipa1, ipo1 ), 0, ipa2, opt2 ) ;
  _shp.indexDist2PartCS := -1 ;

  if tmp1 < tmp2 then
    dst := tmp1
  else
    dst := tmp2 ;

  Result := dst ;
end ;

function TGIS_Shape.PointOnShape
  : TGIS_Point ;
begin
  Result := Centroid ;
end ;

function TGIS_Shape.Area
  : Double ;
begin
  Result := 0 ;
end ;

function TGIS_Shape.AreaCS
  : Double ;
var
  lcs : TGIS_CSCoordinateSystem ;
begin
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          Result := 0
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          Result := 0 ;
end ;

function TGIS_Shape.Length
  : Double ;
begin
  Result := 0 ;
end ;

function TGIS_Shape.LengthCS
  : Double ;
var
  lcs : TGIS_CSCoordinateSystem ;
begin
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          Result := 0
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          Result := 0 ;
end ;

function TGIS_Shape.PartLength(
  const _part : Integer
) : Double ;
begin
  Result := 0 ;
end ;

function TGIS_Shape.PartLengthCS(
  const _part : Integer
) : Double ;
var
  lcs : TGIS_CSCoordinateSystem ;
begin
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          Result := 0
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          Result := 0 ;
end ;

function TGIS_Shape.IsInsideCircle(
  const _center : TGIS_Point ;
  const _range : Double ;
  const _itype : TGIS_InsideType
) : Boolean  ;
begin
  Result := False ;
end ;

function TGIS_Shape.IsInsideExtent(
  const _extent : TGIS_Extent ;
  const _itype  : TGIS_InsideType
) : Boolean ;
var
  ptg      : TGIS_Point  ;
  ext      : TGIS_Extent ;
  part_no  : Integer     ;
  point_no : Integer     ;

  function check_overlap : Boolean ;
  var
    tpl : TGIS_Topology ;
    shp : TGIS_Shape ;
  begin
    shp := TGIS_ShapePolygon.Create();
    try
      shp.AddPart ;
      shp.AddPoint(GisPoint(_extent.XMin, _extent.YMin)) ;
      shp.AddPoint(GisPoint(_extent.XMin, _extent.YMax)) ;
      shp.AddPoint(GisPoint(_extent.XMax, _extent.YMax)) ;
      shp.AddPoint(GisPoint(_extent.XMax, _extent.YMin)) ;

      tpl := TGIS_Topology.Create ;
      try
        Result := tpl.Relate(shp, self, 'T') ;
      finally
        FreeObject( tpl ) ;
      end ;
    finally
      FreeObject( shp ) ;
    end ;
  end ;
begin
  if IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  if GisLockLessThan( LockLevel, TGIS_Lock.Projection ) then
    ext := ProjectedExtent
  else
    ext := Extent ;

  Result := false ;

  if ( ext.XMin > _extent.XMax) or
     ( ext.YMin > _extent.YMax) or
     ( ext.XMax < _extent.XMin) or
     ( ext.YMax < _extent.YMin) then begin
    exit ;
  end ;

  case _itype of
    TGIS_InsideType.Full :
         begin
           if (ext.XMin >= _extent.XMin) and
              (ext.YMin >= _extent.YMin) and
              (ext.XMax <= _extent.XMax) and
              (ext.YMax <= _extent.YMax)
           then
             Result := True
           else
             Result := False
         end ;
    TGIS_InsideType.Centroid :
       begin
         ptg := Centroid ;
         if ( (ptg.X < _extent.XMin) or
              (ptg.X > _extent.XMax) or
              (ptg.Y < _extent.YMin) or
              (ptg.Y > _extent.YMax)
            )
         then
           Result := False
         else
           Result := True ;
       end ;
    TGIS_InsideType.Partial  :
       begin
         if (ext.XMin < _extent.XMax) and
            (ext.YMin < _extent.YMax) and
            (ext.XMax > _extent.XMin) and
            (ext.YMax > _extent.YMin)
         then begin
           for part_no := 0 to self.GetNumParts - 1 do begin
             for point_no :=0 to GetPartSize( part_no ) - 1 do begin
               ptg := GetPoint( part_no, point_no ) ;
               if ( (ptg.X < _extent.XMin) or
                    (ptg.X > _extent.XMax) or
                    (ptg.Y < _extent.YMin) or
                    (ptg.Y > _extent.YMax)
                  )
               then
                 continue
               else begin
                 Result := True ;
                 break ;
               end ;
             end ;
             if Result then break ;
           end ;
           if not Result then begin
             if (self.ShapeType = TGIS_ShapeType.Arc) or
                (self.ShapeType = TGIS_ShapeType.Polygon) then
               Result := check_overlap ;
           end ;
         end
         else
           Result := False
       end ;
    else
       begin
         assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
         Result := False ;
       end ;
  end ;
end ;

function TGIS_Shape.IsInsidePolygon(
  const _shape : TGIS_ShapePolygon ;
  const _itype : TGIS_InsideType
) : Boolean ;
begin
  Result := False ;
end ;

function TGIS_Shape.IsCommonPoint(
  const _shape : TGIS_Shape
) : Boolean ;
begin
  Result := False ;
end ;

function TGIS_Shape.GetCrossings(
  const _shape : TGIS_Shape
) : TGIS_PointList ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := nil ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.GetCrossings(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function TGIS_Shape.GetIntersection(
  const _extent : TGIS_Extent ;
  const _draft  : Boolean
) : TGIS_Shape ;
begin
  if _draft then begin
    Lock( TGIS_Lock.Projection ) ;
    try
      if FShape3D then
        Result := getIntersectInternal3D( _extent, False )
      else
        Result := getIntersectInternal( _extent, False ) ;
    finally
      Unlock() ;
    end;
  end
  else
    Result := GetIntersection( _extent ) ;
end ;

function TGIS_Shape.GetIntersection(
  const _extent : TGIS_Extent
) : TGIS_Shape ;
var
  shp : TGIS_Shape ;
begin
  Lock( TGIS_Lock.Projection ) ;
  try
    shp := TGIS_ShapePolygon.Create();
    try
      shp.AddPart ;
      shp.AddPoint( GisPoint(_extent.XMin, _extent.YMin) ) ;
      shp.AddPoint( GisPoint(_extent.XMin, _extent.YMax) ) ;
      shp.AddPoint( GisPoint(_extent.XMax, _extent.YMax) ) ;
      shp.AddPoint( GisPoint(_extent.XMax, _extent.YMin) ) ;

      Result := self.Intersection( shp, True ) ;
    finally
      FreeObject( shp ) ;
    end ;
  finally
    Unlock() ;
  end;
end ;

function TGIS_Shape.GetAngle(
  const _reverse : Boolean
) : Double ;
var
  ptg1 : TGIS_Point ;
  ptg2 : TGIS_Point ;
  part : Integer ;
  size : Integer ;
begin
  Result := 0 ;

  assert( GetNumParts > 0 ) ;
  if _reverse then begin
    part := GetNumParts - 1;
    size := GetPartSize( part ) ;
    if size < 2 then exit ;
    ptg1 := GetPoint( part, size - 1 ) ;
    ptg2 := GetPoint( part, size - 2 ) ;
  end
  else begin
    part := 0 ;
    size := GetPartSize( 0 ) ;
    if size < 2 then exit ;
    ptg1 := GetPoint( part, 0 ) ;
    ptg2 := GetPoint( part, 1 ) ;
  end ;
  Result := ArcTan2( ptg2.X-ptg1.X, ptg2.Y-ptg1.Y ) ;

  if Result < 0 then Result := 2*Pi + Result ;
end ;

procedure TGIS_Shape.createShapeFromPart(
    const _part          : Integer ;
    const _only_add_part : Boolean ;
    var   _shape         : TGIS_Shape
  ) ;
var
  k : Integer ;
  ptg : TGIS_Point ;
begin
  if not _only_add_part then begin
    _shape := CreateCopy ;
    _shape.Reset ;
  end ;

  _shape.Lock( TGIS_Lock.Projection ) ;
  _shape.AddPart ;
  for k := 0 to GetPartSize( _part ) - 1 do begin
    ptg := GetPoint( _part, k ) ;
    _shape.AddPoint( ptg ) ;
  end ;
  _shape.Unlock ;
end ;

procedure TGIS_Shape.ensureProperPart ;
var
  i, j     : Integer    ;
  currmode : TGIS_Lock  ;
begin
  if lockMode = TGIS_Lock.None then
    exit ;

  if not lockModified then
    exit ;
  if IsMapped then
    exit ;
  if IsEmpty then
    exit ;

  currmode := lockMode ;
  lockMode := TGIS_Lock.Projection ;

  if ( FShapeType = TGIS_ShapeType.Polygon )
     or
    ( FShapeType = TGIS_ShapeType.MultiPatch ) then
  begin
    // check if last point on active part is the same as first
    // and has at least 2 points
    i := GetNumParts - 1 ;
    if i >= 0 then begin
      j := GetPartSize( i ) - 1 ;
      if FShape3D then begin
        if not GisIsSamePoint3D( GetPoint3D(i,0), GetPoint3D(i,j) ) or ( j < 1 ) then
          insertPoint3D( i, -1, GetPoint3D( i, 0 ) ) ;
      end
      else begin
        if not GisIsSamePoint( GetPoint(i,0), GetPoint(i,j) ) or ( j < 1 ) then
          insertPoint( i, -1, GetPoint( i, 0 ) ) ;
      end ;
    end ;
  end
  else if ( FShapeType = TGIS_ShapeType.Arc ) then begin
    // check if has at least 2 points
    i := GetNumParts - 1 ;
    if i >= 0 then begin
      j := GetPartSize( i ) - 1 ;
      if j < 1 then
        if FShape3D then
          insertPoint3D( i, -1, GetPoint3D( i, 0 ) )
        else
          insertPoint( i, -1, GetPoint( i, 0 ) ) ;
    end ;
  end ;

  lockMode := currmode ;
end;


function TGIS_Shape.Split
  : TGIS_ShapeList ;
var
  i, npoints, nparts : Integer ;
  shp                : TGIS_Shape ;
begin
  nparts := GetNumParts ;

  Result := TGIS_ShapeList.Create( True ) ;
  Lock( TGIS_Lock.Projection ) ;
    for i := 0 to nparts -1 do begin
      npoints := GetPartSize(i);
      if npoints > 0 then begin
        createShapeFromPart( i, False, shp ) ;
        Result.Add(shp);
      end ;
    end ;
  Unlock ;
end ;

function TGIS_Shape.Join(
  const _shape : TGIS_Shape
) : TGIS_Shape ;
begin
  Result := Join( _shape, True ) ;
end ;

function TGIS_Shape.Join(
  const _shape        : TGIS_Shape ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  i, k, npoints, nparts: Integer ;
  spoint, wpoint : TGIS_Point3D ;
  check_point : Boolean ;
begin

  case _shape.ShapeType of
    TGIS_ShapeType.Polygon :
      Result := TGIS_ShapePolygon.Create(
                  nil, nil, False, 0, _shape.Layer, Dimension
                ) ;
    TGIS_ShapeType.Arc :
      Result := TGIS_ShapeArc.Create(
                  nil, nil, False, 0, _shape.Layer, Dimension
                ) ;
    TGIS_ShapeType.MultiPoint :
      Result := TGIS_ShapeMultiPoint.Create(
                  nil, nil, False, 0, _shape.Layer, Dimension
                ) ;
    TGIS_ShapeType.Point :
      begin
        Result := nil ;
        exit ;
      end ;
    else begin
      Result := nil ;
      exit ;
    end ;
  end ;

  nparts := GetNumParts ;

  Result.Lock( TGIS_Lock.Internal ) ;
  Lock( TGIS_Lock.Internal ) ;
  try

    check_point := false ;

    for i := 0 to nparts -1 do begin
      npoints := GetPartSize(i);
      for k := 0 to npoints -1 do begin
         if k = 0 then begin
           check_point := true ;
           Result.AddPart ;
         end ;
         wpoint := GetPoint3D(i, k);
         Result.AddPoint3D(wpoint);
      end ;
    end ;

    if _shape.ShapeType = TGIS_ShapeType.Polygon then
      check_point := false ;

    nparts := _shape.GetNumParts ;

    for i := 0 to nparts -1 do begin
      npoints := _shape.GetPartSize(i);
      for k := 0 to npoints -1 do begin
        spoint := _shape.GetPoint3D(i, k);
        if check_point then
          if GisPoint2Point3D(spoint, wpoint) > 0 then
            check_point := false ;
        if k = 0 then begin
          if check_point then
            check_point := false
          else
            Result.AddPart ;
        end ;
        Result.AddPoint3D(spoint);
      end ;
    end ;

  finally
    Unlock ;
    Result.Unlock ;

    if not _returnnewobj then begin
      if assigned( Result ) then begin
        self.CopyGeometry( Result ) ;
        FreeObject( Result ) ;
      end ;
        Result := self ;
    end ;
  end ;

end ;

function TGIS_Shape.Reverse
  : TGIS_Shape ;
begin
  Result := Reverse( True ) ;
end ;

function TGIS_Shape.Reverse(
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  i, k, spoints, sparts: Integer ;
  spoint : TGIS_Point ;
begin
  Result := nil ;
  if ShapeType = TGIS_ShapeType.Point then begin
    exit ;
  end ;

  sparts := GetNumParts ;

  Result := CreateCopy ;
  Result.Reset ;
  Result.Lock( TGIS_Lock.Internal ) ;
  Lock( TGIS_Lock.Internal ) ;
  try

    for i := sparts -1 downto 0 do begin
      spoints := GetPartSize(i);
      if spoints > 0 then begin
        Result.AddPart ;
        for k := spoints -1 downto 0 do begin
          spoint := GetPoint(i, k);
          Result.AddPoint(spoint);
        end ;
      end ;
    end ;

  finally
    Unlock ;
    Result.Unlock ;

    if not _returnnewobj then begin
      if assigned( Result ) then begin
        self.CopyGeometry( Result ) ;
        FreeObject( Result ) ;
      end ;
        Result := self ;
    end ;
  end ;

end ;

function TGIS_Shape.Simplify(
  const _tolerance : Double
) : TGIS_Shape ;
begin
  Result := Simplify( _tolerance, True ) ;
end ;

function TGIS_Shape.Simplify(
  const _tolerance    : Double ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  part_num : Integer               ;
  vt_3d    : array of TGIS_Point3D ;
  vt       : array of TGIS_Point   ;
  mk       : array of Integer      ;
  tol2     : Double ;
  res      : TGIS_Shape ;

  // squared distance
  function dot( const _u, _v  : TGIS_Point ) : Double ;
  begin
    Result := _u.X * _v.X  +  _u.Y * _v.Y ;
  end ;

  function dot_3d( const _u, _v  : TGIS_Point3D ) : Double ;
  begin
    Result := _u.X * _v.X  +  _u.Y * _v.Y  +  _u.Z * _v.Z ;
  end ;

  // squared length of vector
  function norm2( const _v : TGIS_Point ) : Double ;
  begin
    Result := dot( _v , _v ) ;
  end ;

  // squared length of vector
  function norm2_3d( const _v : TGIS_Point3D ) : Double ;
  begin
    Result := dot_3d( _v , _v ) ;
  end ;

  // length of vector
  function norm( const _v : TGIS_Point ) : Double ;
  begin
    Result := Sqrt( norm2( _v ) ) ;
  end ;

  function norm_3d( const _v : TGIS_Point3D ) : Double ;
  begin
    Result := Sqrt( norm2_3d( _v ) ) ;
  end ;

  // distance squared = norm2 of difference
  function d2( const _u, _v  : TGIS_Point ) : Double ;
  begin
    Result := norm2( GisPointsDelta( _u, _v  ) ) ;
  end ;

  // distance squared = norm2 of difference
  function d2_3d( const _u, _v  : TGIS_Point3D ) : Double ;
  begin
    Result := norm2_3d( GisPointsDelta3D( _u, _v  ) ) ;
  end ;

  // distance = norm of difference
  function d( const _u, _v  : TGIS_Point ) : Double ;
  begin
    Result := norm( GisPointsDelta( _u, _v ) ) ;
  end ;

  // distance = norm of difference
  function d_3d( const _u, _v  : TGIS_Point3D ) : Double ;
  begin
    Result := norm_3d( GisPointsDelta3D( _u, _v ) ) ;
  end ;

  // scale point
  function scale( const _u : TGIS_Point; const _scale : Double ) : TGIS_Point ;
  begin
    Result.X := _u.X * _scale ;
    Result.Y := _u.Y * _scale ;
  end ;

  // scale point
  function scale3D( const _u : TGIS_Point3D;
                    const _scale : Double
                  ) : TGIS_Point3D ;
  begin
    Result.X := _u.X * _scale ;
    Result.Y := _u.Y * _scale ;
    Result.Z := _u.Z * _scale ;
  end ;

  // Douglas-Peucker recursive simplification routine
  procedure simplifyDP( const _j : Integer; const _k : Integer ) ;
  var
    i          : Integer     ;
    maxi       : Integer     ;  // index of vertex farthest from S
    maxd2      : Double      ;  // distance squared of farthest vertex
    s          : TGIS_Line   ;  // segment from v[j] to v[k]
    u          : TGIS_Point  ;
    cu         : Double      ;  // segment length squared
    w          : TGIS_Point  ;
    pb         : TGIS_Point  ;  // base of perpendicular from v[i] to S
    b, cw, dv2 : Double      ;  // dv2 = distance v[i] to S squared
  begin
    if _k <= _j + 1 then
      exit ; // there is nothing to simplify

    maxi  := _j ;
    maxd2 := 0 ;
    s.A   := vt[ _j ] ;
    s.B   := vt[ _k ] ;
    u     := GisPointsDelta( s.B, s.A ) ;
    cu    := dot( u, u ) ;     // segment length squared

    // test each vertex v[i] for max distance from S
    // compute using the Feb 2001 Algorithm's dist_Point_to_Segment()
    // Note: this works in any dimension (2D, 3D, ...)

    for i:= _j + 1 to _k - 1 do begin
      // compute distance squared
      w  := GisPointsDelta( vt[i], s.A ) ;
      cw := dot( w, u ) ;
      if      cw <= 0  then dv2 := d2( vt[ i ], s.A )
      else if cu <= cw then dv2 := d2( vt[ i ], s.B )
      else                  begin
                              b   := cw / cu ;
                              pb  := GisMovePoint( s.A,
                                                   GisScalePoint(
                                                     GisPoint( 0, 0 ),
                                                     u,
                                                     b
                                                   )
                                                 ) ;
                              dv2 := d2( vt[ i ], pb ) ;
                            end ;

      // test with current max distance squared
      if dv2 <= maxd2 then
        continue;

      // v[i] is a new max vertex
      maxi  := i   ;
      maxd2 := dv2 ;
    end ;

    if maxd2 > tol2 then begin
      // error is worse than the tolerance

      // split the polyline at the farthest vertex from S
      mk[ maxi ] := 1 ;      // mark v[maxi] for the simplified polyline
      // recursively simplify the two subpolylines at v[maxi]
      simplifyDP( _j  , maxi ) ;  // polyline v[j] to v[maxi]
      simplifyDP( maxi, _k   ) ;  // polyline v[maxi] to v[k]
    end ;
    // else the approximation is OK, so ignore intermediate vertices

  end ;

  // Douglas-Peucker recursive simplification routine
  procedure simplifyDP_3D( const _j : Integer; const _k : Integer ) ;
  var
    i          : Integer      ;
    maxi       : Integer      ;  // index of vertex farthest from S
    maxd2      : Double       ;  // distance squared of farthest vertex
    s          : TGIS_Line3D  ;  // segment from v[j] to v[k]
    u          : TGIS_Point3D ;
    cu         : Double       ;  // segment length squared
    w          : TGIS_Point3D ;
    pb         : TGIS_Point3D ;  // base of perpendicular from v[i] to S
    b, cw, dv2 : Double       ;  // dv2 = distance v[i] to S squared
  begin
    if _k <= _j + 1 then
      exit ; // there is nothing to simplify

    maxi  := _j ;
    maxd2 := 0 ;
    s.A   := vt_3d[ _j ] ;
    s.B   := vt_3d[ _k ] ;
    u     := GisPointsDelta3D( s.B, s.A ) ;
    cu    := dot_3d( u, u ) ;     // segment length squared

    // test each vertex v[i] for max distance from S
    // compute using the Feb 2001 Algorithm's dist_Point_to_Segment()
    // Note: this works in any dimension (2D, 3D, ...)

    for i:= _j + 1 to _k - 1 do begin
      // compute distance squared
      w  := GisPointsDelta3D( vt_3d[i], s.A ) ;
      cw := dot_3d( w, u ) ;
      if      cw <= 0  then dv2 := d2_3d( vt_3d[ i ], s.A )
      else if cu <= cw then dv2 := d2_3d( vt_3d[ i ], s.B )
      else                  begin
                              b   := cw / cu ;
                              pb  := GisMovePoint3D( s.A,
                                                     GisScalePoint3D(
                                                       GisPoint3D( 0, 0, 0 ),
                                                       u,
                                                       b
                                                     )
                                                   ) ;
                              dv2 := d2_3d( vt_3d[ i ], pb ) ;
                            end ;

      // test with current max distance squared
      if dv2 <= maxd2 then
        continue;

      // v[i] is a new max vertex
      maxi  := i   ;
      maxd2 := dv2 ;
    end ;

    if maxd2 > tol2 then begin
      // error is worse than the tolerance

      // split the polyline at the farthest vertex from S
      mk[ maxi ] := 1 ;      // mark v[maxi] for the simplified polyline
      // recursively simplify the two subpolylines at v[maxi]
      simplifyDP_3D( _j  , maxi ) ;  // polyline v[j] to v[maxi]
      simplifyDP_3D( maxi, _k   ) ;  // polyline v[maxi] to v[k]
    end ;
    // else the approximation is OK, so ignore intermediate vertices
  end ;

  // main simplify subroutine
  procedure simplify_2D( const _part : Integer ) ;
  var
     i, k, pv : Integer ;  // misc counters
     n        : Integer ;  // number of points
     ptg      : TGIS_Point ;
  begin
    n := GetPartSize( _part ) ;

    if n <= 0 then exit ;

    {$IFDEF OXYGENE}
      if assigned( vt ) then
        SetLength( vt, Max( vt.Length, n ) )
      else
        SetLength( vt, n ) ;
      if assigned( mk ) then
        SetLength( mk, Max( mk.Length, n ) )
      else
        SetLength( mk, n ) ;
    {$ELSE}
      SetLength( vt, Max( System.Length( vt ), n ) ) ;
      SetLength( mk, Max( System.Length( mk ), n ) ) ;
    {$ENDIF}

    // STAGE 1.  Vertex Reduction within tolerance of prior vertex cluster
    vt[0] := GetPoint( _part, 0 ); // start at the beginning
    k := 1 ;
    pv := 0 ;
    for i := 1 to n - 1 do begin
      ptg := GetPoint( _part, i  ) ;
      if ( d2( ptg, GetPoint( _part, pv ) ) < tol2 ) then
        continue ;

      vt[ k ] := _TGIS_Point(ptg) ;
      pv := i ;
      inc( k ) ;
    end ;
    if pv < n-1 then begin
      vt[ k ] := GetPoint( _part, n-1 ) ;      // finish at the end
      inc( k ) ;
    end ;

    // STAGE 2.  Douglas-Peucker polyline simplification
    mk[ 0 ]   := 1 ;  // mark the first and last vertices
    mk[ k-1 ] := 1 ;

    simplifyDP( 0, k-1 ) ;

    // copy marked vertices to the output simplified polyline
    for i := 0 to k - 1 do begin
      if mk[ i ] <> 0 then begin
        res.AddPoint( vt[i] ) ;
      end ;
    end ;
  end ;

  // main simplify subroutine
  procedure simplify_3D( const _part : Integer ) ;
  var
     i, k, pv : Integer ;  // misc counters
     n        : Integer ;  // number of points
     tol21    : Double  ;
     ptg      : TGIS_Point3D ;
  begin
    n := GetPartSize( _part ) ;

    if n <= 0 then exit ;

    tol21 := _tolerance * _tolerance ;  // tolerance squared

    {$IFDEF OXYGENE}
      if assigned( vt ) then
        SetLength( vt_3d, Max( vt.Length, n ) )
      else
        SetLength( vt_3d, n ) ;
      if assigned( mk ) then
        SetLength( mk, Max( mk.Length, n ) )
      else
        SetLength( mk, n ) ;
    {$ELSE}
      SetLength( vt_3D, Max( System.Length( vt ), n ) ) ;
      SetLength( mk, Max( System.Length( mk ), n ) ) ;
    {$ENDIF}

    // STAGE 1.  Vertex Reduction within tolerance of prior vertex cluster
    vt_3d[0] := GetPoint3D( _part, 0 ); // start at the beginning
    k := 1 ;
    pv := 0 ;
    for i := 1 to n - 1 do begin
      ptg := GetPoint3D( _part, i  ) ;
      if ( d2_3d( ptg, GetPoint3D( _part, pv ) ) < tol21 ) then
        continue ;

      vt_3d[ k ] := _TGIS_Point3D(ptg) ;
      pv := i ;
      inc( k ) ;
    end ;
    if pv < n-1 then begin
      vt_3d[ k ] := GetPoint3D( _part, n-1 ) ;      // finish at the end
      inc( k ) ;
    end ;

    // STAGE 2.  Douglas-Peucker polyline simplification
    mk[ 0 ]   := 1 ;  // mark the first and last vertices
    mk[ k-1 ] := 1 ;

    simplifyDP_3D( 0, k-1 ) ;

    // copy marked vertices to the output simplified polyline
    for i := 0 to k - 1 do begin
      if mk[ i ] <> 0 then begin
        res.AddPoint3D( vt_3d[i] ) ;
      end ;
    end ;
  end ;

begin
  case ShapeType of
    TGIS_ShapeType.Polygon :
      res := TGIS_ShapePolygon.Create(
                  nil, nil, False, 0, Layer, Dimension
                ) ;
    TGIS_ShapeType.Arc :
      res := TGIS_ShapeArc.Create(
                  nil, nil, False, 0, Layer, Dimension
                ) ;
    TGIS_ShapeType.MultiPoint,
    TGIS_ShapeType.Point :
      begin
        if _returnnewobj then Result := nil
                         else Result := self ;
        exit ;
      end ;
    else begin
      if _returnnewobj then Result := nil
                       else Result := self ;
      exit ;
    end ;
  end ;

  tol2 := _tolerance * _tolerance ;  // tolerance squared
  res.Lock( TGIS_Lock.Extent ) ;
  try

    for part_num := 0 to GetNumParts -1 do begin
      res.AddPart ;
      if self.FShape3D then
        simplify_3D( part_num )
      else
        simplify_2D( part_num ) ;
    end ;

  finally
    Result := res ;

    Result.Unlock ;

    if not _returnnewobj then begin
      self.CopyGeometry( Result ) ;
      FreeObject( Result ) ;
      Result := self ;
    end ;
  end ;

end ;

function TGIS_Shape.Smooth(
  const _factor : Integer
) : TGIS_Shape ;
begin
  Result := Smooth( _factor, True ) ;
end ;

function TGIS_Shape.Smooth(
  const _factor       : Integer ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  res : TGIS_Shape ;
  crs : T_CatmullRomSpline ;
  cls : Boolean ;
  p0  : TGIS_Point3D ;
  p1  : TGIS_Point3D ;
  p2  : TGIS_Point3D ;
  p3  : TGIS_Point3D ;
  pi  : TGIS_Point3D ;
  pt  : TGIS_Point3D ;
  pc  : TGIS_Point3D ;
  siz : Integer ;
  f   : Integer ;
  f1  : Integer ;
  d   : Double ;
  i   : Integer ;

  procedure do_copy( const _i : Integer ) ;
  var
    kk : Integer ;
    cc : Integer ;
  begin
    if ShapeType = TGIS_ShapeType.Arc then
      cc := 1
    else
      cc := 2 ;

    res.AddPart ;

    for kk := 0 to siz - cc do
      res.AddPoint( GetPoint( _i, kk ) ) ;
  end ;

  procedure do_crs ;
  var
    cc : Integer ;
  begin
    crs.Prepare( p0, p1, p2, p3 ) ;

    pt := p1 ;
    res.AddPoint3D( p1 ) ;
    d := ( crs.Knot2 - crs.Knot1 )/f1 ;
    for cc := 1 to f do begin
      if crs.Ready then begin
        pi := crs.Calculate( crs.Knot1 + cc*d ) ;
        if GisIsSamePoint3D( pi, pt ) then
          continue ;
        res.AddPoint3D( pi ) ;
        pt := pi ;
      end;
    end ;
  end ;

  function next_point( const _i : Integer ;
                         var _k : Integer ) : TGIS_Point3D ;
  var
    pp : TGIS_Point3D ;
  begin
    pp := pc ;
    while True do begin
      inc( _k ) ;
      if _k >= siz then begin
        if cls then
          _k := 0
        else
          break ;
      end ;
      pp := GetPoint3D( _i, _k ) ;
      if GisIsSamePoint3D( pc, pp ) then
        continue ;
      pc := pp ;
      break ;
    end ;
    Result := pc ;
  end ;

  procedure do_closed( const _i : Integer ) ;
  var
    kk : Integer ;
  begin
    cls := True ;

    res.AddPart ;

    pc := GetPoint3D( _i, siz - 2 ) ;
    p0 := pc ;
    kk := -1 ;
    p1 := next_point( _i, kk ) ;
    p2 := next_point( _i, kk ) ;
    p3 := next_point( _i, kk ) ;
    do_crs ;

    while kk < siz - 1 do begin
      p0 := p1 ;
      p1 := p2 ;
      p2 := p3 ;
      p3 := next_point( _i, kk ) ;
      do_crs ;
    end ;

    p0 := p1 ;
    p1 := p2 ;
    p2 := p3 ;
    p3 := next_point( _i, kk ) ;
    do_crs ;

    if ShapeType = TGIS_ShapeType.Arc then
      res.AddPoint3D( p2 ) ;
  end ;

  procedure do_open( const _i : Integer ) ;
  var
    kk : Integer ;
  begin
    cls := False ;

    res.AddPart ;

    pc := GetPoint3D( _i, siz - 1 ) ;
    p0 := pc ;
    kk := -1 ;
    p1 := next_point( _i, kk ) ;
    p2 := next_point( _i, kk ) ;
    p3 := next_point( _i, kk ) ;
    pt := GisPoint3D( p2.X-p1.X, p2.Y-p1.Y, p2.Z-p1.Z ) ;
    p0 := GisPoint3D( p1.X-pt.X, p1.Y-pt.Y, p1.Z-pt.Z ) ;
    do_crs ;


    while kk < siz - 1 do begin
      p0 := p1 ;
      p1 := p2 ;
      p2 := p3 ;
      p3 := next_point( _i, kk ) ;
      do_crs ;
    end ;

    p0 := p1 ;
    p1 := p2 ;
    p2 := p3 ;
    pt := GisPoint3D( p1.X-p2.X, p1.Y-p2.Y, p1.Z-p2.Z ) ;
    p3 := GisPoint3D( p2.X-pt.X, p2.Y-pt.Y, p2.Z-pt.Z ) ;
    do_crs ;

    res.AddPoint3D( p2 ) ;
  end ;

begin
  Result := nil ;

  f := _factor ;
  if f < 0 then
    f := 0 ;
  f1 := f + 1 ;

  case ShapeType of
    TGIS_ShapeType.Polygon :
      res := TGIS_ShapePolygon.Create(
               nil, nil, False, 0, Layer, Dimension
             ) ;
    TGIS_ShapeType.Arc :
      res := TGIS_ShapeArc.Create(
               nil, nil, False, 0, Layer, Dimension
             ) ;
    TGIS_ShapeType.MultiPoint,
    TGIS_ShapeType.Point :
      begin
        if _returnnewobj then Result := nil
                         else Result := self ;
        exit ;
      end ;
    else begin
      if _returnnewobj then Result := nil
                       else Result := self ;
      exit ;
    end ;
  end ;

  res.Lock( TGIS_Lock.Projection );
  try

    crs := T_CatmullRomSpline.Create ;
    try
      case ShapeType of
        TGIS_ShapeType.Polygon :
          begin
            for i := 0 to GetNumParts - 1 do begin
              siz := GetPartSize( i ) ;

              // eliminate duplicated points at tail
              while siz > 2 do begin
                if not GisIsSamePoint3D(
                         GetPoint3D( i, siz - 1 ),
                         GetPoint3D( i, siz - 2 )
                       )
                then
                  break ;
                dec( siz ) ;
              end ;

              if siz <= 3 then begin
                do_copy( i ) ;
                continue ;
              end ;
              do_closed( i ) ;
            end ;
          end ;
        TGIS_ShapeType.Arc :
          begin
            for i := 0 to GetNumParts - 1 do begin
              siz := GetPartSize( i ) ;

              // eliminate duplicated points at tail
              while siz > 2 do begin
                if not GisIsSamePoint3D(
                         GetPoint3D( i, siz - 1 ),
                         GetPoint3D( i, siz - 2 )
                       )
                then
                  break ;
                dec( siz ) ;
              end ;


              if siz <= 2 then begin
                do_copy( i ) ;
                continue ;
              end ;

              p0 := GetPoint3D( i, 0 ) ;
              p1 := GetPoint3D( i, siz - 1 ) ;
              if GisIsSamePoint3D( p0, p1 ) then
                do_closed( i )
              else
                do_open( i ) ;
            end ;
          end ;
      end ;
    finally
      FreeObject( crs ) ;
    end ;

  finally
    res.Unlock ;

    Result := res ;

    if not _returnnewobj then begin
      self.CopyGeometry( Result ) ;
      FreeObject( Result ) ;
      Result := self ;
    end ;

  end ;
end ;

function TGIS_Shape.Relate(
  const _shape          : TGIS_Shape ;
  const _isectionMatrix : String
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Relate(self, _shape, _isectionMatrix) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function  TGIS_Shape.Equality(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Equality(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function  TGIS_Shape.Disjoint(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := True ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Disjoint(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function  TGIS_Shape.Intersect(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Intersect(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function TGIS_Shape.Touch(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    if ord(self.ShapeType) <= ord(_shape.ShapeType) then
      Result := tpl.Touch(self, _shape)
    else
      Result := tpl.Touch(_shape, self) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function  TGIS_Shape.Cross(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Cross(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function  TGIS_Shape.Within(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Within(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function  TGIS_Shape.Contains(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Contains(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

function  TGIS_Shape.Overlap(
  const _shape : TGIS_Shape
) : Boolean ;
var
  tpl : TGIS_Topology ;
begin
  if not assigned( _shape ) then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Overlap(self, _shape) ;
  finally
    FreeObject( tpl ) ;
  end ;
end ;

procedure TGIS_Shape.CopyGeometry(
  const _shape : TGIS_Shape
) ;
var
  part_no  : Integer ;
  point_no : Integer ;
begin
  if not assigned( _shape ) then exit ;

  Reset ;
  self.Lock( TGIS_Lock.Extent );
  try
    for part_no := 0 to _shape.GetNumParts - 1 do begin
      AddPart ;
      SetPartType( part_no, _shape.GetPartType( part_no ) ) ;
      for point_no := 0 to _shape.GetPartSize( part_no ) - 1 do begin
        AddPoint3D( _shape.GetPoint3D( part_no, point_no) ) ;
      end ;
    end ;
  finally
    self.Unlock ;
  end;
end ;

procedure TGIS_Shape.AppendGeometry(
  const _shape : TGIS_Shape
) ;
var
  part_no  : Integer ;
  point_no : Integer ;
  do_lock  : Boolean ;
begin
  if not assigned( _shape ) then exit ;

  do_lock := lockMode = TGIS_Lock.None ;
  if do_lock then
    Self.Lock( TGIS_Lock.Extent ) ;
  try
    for part_no := 0 to _shape.GetNumParts - 1 do begin
      AddPart ;
      SetPartType( GetNumParts-1, _shape.GetPartType( part_no ) ) ;
      for point_no := 0 to _shape.GetPartSize( part_no ) - 1 do
        AddPoint3D(  _shape.GetPoint3D( part_no, point_no) ) ;
    end ;
  finally
    if do_lock then
      Self.Unlock ;
  end;
end ;

procedure TGIS_Shape.CopyFields(
  const _shape : TGIS_Shape
) ;
var
  i      : Integer          ;
  ll     : TGIS_LayerVector ;
  fld_s  : TGIS_FieldInfo   ;
  ifld_d : Integer          ;
  fld_d  : TGIS_FieldInfo   ;
  bro    : Boolean          ;
begin

  // copy fields
  if not assigned( _shape ) then exit ;
  ll := _shape.Layer ;
  if not assigned( ll     ) then exit ;
  if not assigned( Layer  ) then exit ;

  for i:=0 to ll.Fields.Count - 1 do begin
    fld_s := _shape.Layer.FieldInfo( i )    ;

    if not fld_s.FileFormat then begin
      ifld_d := Layer.FindField( fld_s.NewName ) ;
      if ifld_d >= 0 then begin
        fld_d := Layer.FieldInfo( ifld_d ) ;
        if not fld_d.FileFormat then begin
          bro := fld_d.ReadOnly ;
          fld_d.ReadOnly := False ;
          try
            SetField( fld_d.NewName, _shape.GetFieldEx( fld_s.NewName ) ) ;
          finally
            fld_d.ReadOnly := bro ;
          end ;
        end ;
      end ;
    end ;
  end ;

end ;

function TGIS_Shape.Combine(
  const _shape     : TGIS_Shape ;
  const _operation : TGIS_TopologyCombineType
) : TGIS_Shape ;
begin
  Result := Combine( _shape, _operation, True ) ;
end ;

function TGIS_Shape.Combine(
  const _shape        : TGIS_Shape               ;
  const _operation    : TGIS_TopologyCombineType ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  tpl : TGIS_Topology ;
begin
  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Combine(self, _shape, _operation ) ;
  finally
    FreeObject( tpl ) ;

    if not _returnnewobj then begin
      if assigned( Result ) then begin
        self.CopyGeometry( Result ) ;
        FreeObject( Result ) ;
      end
      else
        self.Reset ;
      Result := self ;
    end ;
  end ;
end ;

function  TGIS_Shape.Union(
  const _shape : TGIS_Shape
) : TGIS_Shape ;
begin
  Result := Union( _shape, True ) ;
end ;

function  TGIS_Shape.Union(
  const _shape        : TGIS_Shape ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  tpl : TGIS_Topology ;
begin
  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Combine(self, _shape, TGIS_TopologyCombineType.Union) ;
  finally
    FreeObject( tpl ) ;

    if not _returnnewobj then begin
      if assigned( Result ) then begin
        self.CopyGeometry( Result ) ;
        FreeObject( Result ) ;
      end
      else
        self.Reset ;
      Result := self ;
    end ;
  end ;
end ;

function  TGIS_Shape.Intersection(
  const _shape : TGIS_Shape
) : TGIS_Shape ;
begin
  Result := Intersection( _shape, True ) ;
end ;

function  TGIS_Shape.Intersection(
  const _shape        : TGIS_Shape ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  tpl : TGIS_Topology ;
begin
  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Combine(self, _shape, TGIS_TopologyCombineType.Intersection) ;
  finally
    FreeObject( tpl ) ;

    if not _returnnewobj then begin
      if assigned( Result ) then begin
        self.CopyGeometry( Result ) ;
        FreeObject( Result ) ;
      end
      else
        self.Reset ;
      Result := self ;
    end ;
  end ;
end ;

function  TGIS_Shape.Difference(
  const _shape : TGIS_Shape
) : TGIS_Shape ;
begin
  Result := Difference( _shape, True ) ;
end ;

function  TGIS_Shape.Difference(
  const _shape        : TGIS_Shape ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  tpl : TGIS_Topology ;
begin
  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Combine(self, _shape, TGIS_TopologyCombineType.Difference) ;
  finally
    FreeObject( tpl ) ;

    if not _returnnewobj then begin
      if assigned( Result ) then begin
        self.CopyGeometry( Result ) ;
        FreeObject( Result ) ;
      end
      else
        self.Reset ;
      Result := self ;
    end ;
  end ;
end ;

function  TGIS_Shape.SymmetricalDifference(
  const _shape : TGIS_Shape
) : TGIS_Shape ;
begin
  Result := SymmetricalDifference( _shape, True ) ;
end ;

function  TGIS_Shape.SymmetricalDifference(
  const _shape        : TGIS_Shape ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  tpl : TGIS_Topology ;
begin
  tpl := TGIS_Topology.Create ;
  try
    Result := tpl.Combine( self, _shape,
                           TGIS_TopologyCombineType.SymmetricalDifference
                         ) ;
  finally
    FreeObject( tpl ) ;

    if not _returnnewobj then begin
      if assigned( Result ) then begin
        self.CopyGeometry( Result ) ;
        FreeObject( Result ) ;
      end
      else
        self.Reset ;
      Result := self ;
    end ;
  end ;
end ;

procedure TGIS_Shape.RevertParams ;
begin
  FreeObject( FParams ) ;
end ;

procedure TGIS_Shape.Draw(
  const _mode : TGIS_RendererMultipassMode
) ;
var
  shp : TGIS_Shape ;
begin

  if IsHidden or IsDeleted or IsEmpty then exit ;

  if not assigned( Layer ) or
     not assigned( Layer.Renderer ) then exit ;

  shp := getTruncatedShape( False ) ;
  if shp = nil then exit ;
  try
    TGIS_RendererAbstract( Layer.Renderer ).RenderShape(
      shp, Self, False, _mode
    ) ;
  finally
    {$IFNDEF JAVA}
      freeTruncatedShape( shp ) ;
    {$ENDIF}
  end;
end;

procedure TGIS_Shape.Draw ;
begin
  Draw( TGIS_RendererMultipassMode.Single ) ;
end;

procedure TGIS_Shape.DrawTrackingPoints ;
var
  part_no  : Integer ;
  point_no : Integer ;
  old_pt_x : Integer ;
  old_pt_y : Integer ;
  ex, ey   : Double  ;
  zm       : Double  ;
  dx, dy   : Double  ;
  dx2, dy2 : Double  ;
  pt_x     : Integer ;
  pt_y     : Integer ;
  tps      : Integer ; //tracking point size
  ext      : TGIS_Extent ;
  edt      : IGIS_Editor ;
  npsize   : Integer ;
begin
  if IsHidden or IsDeleted or IsEmpty then exit ;

  old_pt_x := -1000 ;
  old_pt_y := -1000 ;

  with Viewer.Ref do  begin

    tps := TwipsToPixels( GIS_TRACKING_POINT_SIZE div 2 ) ;

    ext := VisibleExtent ;

    prepareTrackingPoints ;

    edt := Editor ;
    begin
      zm := Zoom ;
      if zm <= 0 then Abort ;
      assert( not GisIsNoWorld( Extent ) ) ;

      ex := - Extent.XMin - Viewport.X ;
      ey :=   Extent.YMax - Viewport.Y ;
    end ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      npsize := GetPartSize( part_no ) -1 ;
      if edt.SnapType = TGIS_EditorSnapType.Midpoint then
        npsize := npsize -1 ;

      for point_no := 0 to npsize do  begin // all points
        if edt.SnapType = TGIS_EditorSnapType.EndPoint then begin
          if ( point_no <> 0 ) and ( point_no <> npsize ) then continue ;
          GetPointEx( part_no, point_no, dx, dy ) ;
        end
        else if edt.SnapType = TGIS_EditorSnapType.Midpoint then begin
          GetPointEx( part_no, point_no  , dx , dy  ) ;
          GetPointEx( part_no, point_no+1, dx2, dy2 ) ;
          dx := (dx + dx2) / 2 ;
          dy := (dy + dy2) / 2 ;
        end
        else
          GetPointEx( part_no, point_no, dx, dy ) ;

        if ( dx < ext.XMin ) or
           ( dx > ext.XMax ) or
           ( dy < ext.YMin ) or
           ( dy > ext.YMax )
        then continue ;

        // like MapToScreen does
        pt_x := TruncS( (  dx + ex ) * zm ) ;
        pt_y := TruncS( ( -dy + ey ) * zm ) ;

        if ( Abs( old_pt_x - pt_x ) +
             Abs( pt_y - old_pt_y )
           ) >= 2 * tps
        then  begin
          old_pt_x := pt_x ;
          old_pt_y := pt_y ;

          TGIS_RendererAbstract(ViewerParent.ControlRenderer).CanvasDrawEllipse(
            pt_x - tps, pt_y - tps, 2 * tps, 2 * tps
          ) ;
        end ;
      end ;
    end ;
  end ;
end ;

procedure TGIS_Shape.Invalidate ;
begin
  if not IsEmpty and assigned( Viewer ) then begin
    if Layer.IsTopmost then
      Viewer.Ref.InvalidateTopmost
    else
      Viewer.Ref.InvalidateWholeMap ;
  end;
end ;

function TGIS_Shape.CreateFromEWKT(
  const _ewkt : String
) : TGIS_Shape ;
begin
  Result := TGIS_GeometryFactory.GisCreateShapeFromEWKT( _ewkt, nil, nil, False, -1, Layer ) ;
end ;

function TGIS_Shape.CreateFromEWKB(
  const _ewkb : OleVariant
) : TGIS_Shape ;
begin
  Result := TGIS_GeometryFactory.GisCreateShapeFromEWKB( OleVariant(_ewkb), nil, nil, False, -1, Layer ) ;
end ;

function TGIS_Shape.CreateFromWKT(
  const _wkt : String
) : TGIS_Shape ;
begin
  Result := TGIS_GeometryFactory.GisCreateShapeFromWKT( _wkt, nil, nil, False, -1, Layer ) ;
end ;

function TGIS_Shape.CreateFromWKB(
  const _wkb : OleVariant
) : TGIS_Shape ;
begin
  Result := TGIS_GeometryFactory.GisCreateShapeFromWKB( OleVariant(_wkb), nil, nil, False, -1, Layer ) ;
end ;

function TGIS_Shape.CreateFromGDO(
  const _gdo : OleVariant
) : TGIS_Shape ;
begin
  Result := TGIS_GeometryFactory.GisCreateShapeFromGDO( OleVariant(_gdo), nil, nil, False, -1, Layer ) ;
end ;

function TGIS_Shape.CreateFromJSON(
  const _json : String
) : TGIS_Shape ;
begin
  Result := TGIS_GeometryFactory.GisCreateShapeFromJSON( _json, nil, nil, False, -1, Layer ) ;
end ;

function TGIS_Shape.CreateFromGML(
  const _gml : String
) : TGIS_Shape ;
begin
  Result := TGIS_GeometryFactory.GisCreateShapeFromGML( _gml, nil, nil, False, -1, Layer ) ;
end ;

procedure TGIS_Shape.ImportFromEWKT(
  const _ewkt : String
) ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
  corr : Integer   ;
begin
  shp := CreateFromEWKT( _ewkt ) ;
  shp.Lock( TGIS_Lock.Projection ) ;
  if FShapeType = TGIS_ShapeType.Polygon then
    corr := 2
  else
    corr := 1 ;
  try
    Reset ;
    if FShapeType = TGIS_ShapeType.Complex then begin
      Recreate( shp, nil, False, self.Uid, self.Layer, self.Dimension ) ;
    end
    else begin
      if IsSameType( shp, self ) then begin
        for i:= 0 to shp.GetNumParts - 1 do begin
          AddPart ;
          for j:= 0 to shp.GetPartSize( i ) - corr do begin
            if FShape3D then
              AddPoint3D( shp.GetPoint3D( i, j ) )
            else
              AddPoint  ( shp.GetPoint  ( i, j ) ) ;
          end ;
        end ;
      end ;
    end ;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
  end ;
end ;

procedure TGIS_Shape.ImportFromEWKB(
   var   _ewkb : OleVariant
) ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
begin
  shp := CreateFromEWKB( _ewkb ) ;
  shp.Lock( TGIS_Lock.Projection ) ;
  Lock( TGIS_Lock.Projection ) ;
  try
    Reset ;
    if FShapeType = TGIS_ShapeType.Complex then begin
      Recreate( shp, nil, False, self.Uid, self.Layer, self.Dimension ) ;
    end
    else begin
      if IsSameType( shp, self ) then begin

        for i:= 0 to shp.GetNumParts - 1 do begin
          AddPart ;
          for j:= 0 to shp.GetPartSize( i ) - 1 do begin
            if FShape3D then
              AddPoint3D( shp.GetPoint3D( i, j ) )
            else
              AddPoint( shp.GetPoint( i, j ) ) ;
          end ;
        end ;
      end ;
    end;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
    Unlock ;
  end ;
end ;

procedure TGIS_Shape.ImportFromWKT(
  const _wkt : String
) ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
  corr : Integer   ;
begin
  shp := CreateFromWKT( _wkt ) ;
  shp.Lock( TGIS_Lock.Projection ) ;
  if FShapeType = TGIS_ShapeType.Polygon then
    corr := 2
  else
    corr := 1 ;
  try
    Reset ;
    if FShapeType = TGIS_ShapeType.Complex then begin
      Recreate( shp, nil, False, self.Uid, self.Layer, self.Dimension ) ;
    end
    else begin
      if IsSameType( shp, self ) then begin
        for i:= 0 to shp.GetNumParts - 1 do begin
          AddPart ;
          for j:= 0 to shp.GetPartSize( i ) - corr do begin
            if FShape3D then
              AddPoint3D( shp.GetPoint3D( i, j ) )
            else
              AddPoint  ( shp.GetPoint  ( i, j ) ) ;
          end ;
        end ;
      end ;
    end ;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
  end ;
end ;

procedure TGIS_Shape.ImportFromWKB(
  var _wkb : OleVariant
) ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
begin
  shp := CreateFromWKB( _wkb ) ;
  shp.Lock( TGIS_Lock.Projection ) ;
  Lock( TGIS_Lock.Projection ) ;
  try
    Reset ;
    if FShapeType = TGIS_ShapeType.Complex then begin
      Recreate( shp, nil, False, self.Uid, self.Layer, self.Dimension ) ;
    end
    else begin
      if IsSameType( shp, self ) then begin
        for i:= 0 to shp.GetNumParts - 1 do begin
          AddPart ;
          for j:= 0 to shp.GetPartSize( i ) - 1 do begin
            if FShape3D then
              AddPoint3D( shp.GetPoint3D( i, j ) )
            else
              AddPoint( shp.GetPoint( i, j ) ) ;
          end ;
        end ;
      end ;
    end;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
    Unlock ;
  end ;
end ;

procedure TGIS_Shape.ImportFromGDO(
  var _gdo : OleVariant
) ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
begin
  shp := CreateFromGDO( _gdo ) ;
  shp.Lock( TGIS_Lock.Projection ) ;
  Lock( TGIS_Lock.Projection ) ;
  try
    Reset ;
    if FShapeType = TGIS_ShapeType.Complex then begin
      Recreate( shp, nil, False, self.Uid, self.Layer, self.Dimension ) ;
    end
    else begin
      if IsSameType( shp, self ) then begin
        for i:= 0 to shp.GetNumParts - 1 do begin
          AddPart ;
          for j:= 0 to shp.GetPartSize( i ) - 1 do begin
            if FShape3D then
              AddPoint3D( shp.GetPoint3D( i, j ) )
            else
              AddPoint( shp.GetPoint( i, j ) ) ;
          end ;
        end ;
      end ;
    end;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
    Unlock ;
  end ;
end ;

procedure TGIS_Shape.ImportFromVAR(
  var _var : OleVariant
) ;
var
  {$IFDEF MANAGED}
    vr     : TBytes  ;
    vr_off : Integer ;
    buf    : TGIS_Bytes ;
  {$ELSE}
    buf   : Pointer ;
  {$ENDIF}
begin
  {$IFDEF MANAGED}
    {$IFNDEF OXYGENE}
      assert( VarArrayElementsIsType(OleVariant(_var), varByte) ) ;
    {$ENDIF}
    vr := TBytes( _var );
    vr_off := 0  ;
    buf := TGIS_Bytes.Create( vr, vr_off ) ;
  {$ELSE}
    buf := VarArrayLock( _var ) ;
  {$ENDIF}
  try
    Recreate( nil, buf, False, Uid, Layer, Dimension ) ;
  finally
    {$IFDEF MANAGED}
      FreeObject( buf ) ;
    {$ELSE}
      VarArrayUnLock( _var ) ;
    {$ENDIF}
  end ;
end ;

procedure TGIS_Shape.ImportFromJSON(
  const _json : String
) ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
begin
  shp := CreateFromJSON( _json ) ;
  shp.Lock( TGIS_Lock.Projection ) ;
  try
    Reset ;
    if FShapeType = TGIS_ShapeType.Complex then begin
      Recreate( shp, nil, False, self.Uid, self.Layer, self.Dimension ) ;
    end
    else begin
      if IsSameType( shp, self ) then begin
        for i:= 0 to shp.GetNumParts - 1 do begin
          AddPart ;
          for j:= 0 to shp.GetPartSize( i ) - 1 do begin
            if FShape3D then
              AddPoint3D( shp.GetPoint3D( i, j ) )
            else
              AddPoint  ( shp.GetPoint  ( i, j ) ) ;
          end ;
        end ;
      end ;
    end;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
  end ;
end ;

procedure TGIS_Shape.ImportFromGML(
  const _gml : String
) ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
begin
  shp := CreateFromGML( _gml ) ;
  shp.Lock( TGIS_Lock.Projection ) ;
  try
    Reset ;
    if FShapeType = TGIS_ShapeType.Complex then begin
      Recreate( shp, nil, False, self.Uid, self.Layer, self.Dimension ) ;
    end
    else begin
      if IsSameType( shp, self ) then begin
        for i:= 0 to shp.GetNumParts - 1 do begin
          AddPart ;
          for j:= 0 to shp.GetPartSize( i ) - 1 do begin
            if FShape3D then
              AddPoint3D( shp.GetPoint3D( i, j ) )
            else
              AddPoint  ( shp.GetPoint  ( i, j ) ) ;
          end ;
        end ;
      end ;
    end;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
  end ;
end ;

procedure TGIS_Shape.PrepareContourInternal(
  const _size    : Integer     ;
  const _outline : Boolean     ;
  var   _pixels  : TGIS_Pixels ;
  var   _scale   : Double      ;
  var   _offset  : TPoint
) ;
var
  bmp : TGIS_Bitmap ;
  pix : TGIS_Pixels ;
begin
  _scale := 0 ;

  if not assigned( BitmapHelper ) then
    exit ;

  bmp := TGIS_Bitmap.Create( _size, _size ) ;
  try
    bmp.DrawShape( self, _outline, _scale, _offset );

    if _scale = 0 then
      exit ;

    bmp.LockPixels( pix, false,
                    TGIS_BitmapFormat.ARGB,
                    TGIS_BitmapLinesOrder.Down
                  );
    try
      SetLength( _pixels, _size * _size ) ;
      assert( high( pix ) = high( _pixels ) ) ;
      {$IFDEF OXYGENE}
        GisCopyPixels( pix, 0, _pixels, 0, pix.Length ) ;
      {$ELSE}
        GisCopyPixels( pix, 0, _pixels, 0, System.length( pix ) ) ;
      {$ENDIF}
    finally
      bmp.UnlockPixels ;
    end;
  finally
    FreeObject( bmp ) ;
  end;
end ;

function TGIS_Shape.Transform(
  const _origin : TGIS_Point3D ;
  const _m11    : Double       ;
  const _m12    : Double       ;
  const _m13    : Double       ;
  const _m21    : Double       ;
  const _m22    : Double       ;
  const _m23    : Double       ;
  const _m31    : Double       ;
  const _m32    : Double       ;
  const _m33    : Double       ;
  const _dx     : Double       ;
  const _dy     : Double       ;
  const _dz     : Double
) : TGIS_Shape ;
begin
  Result := Transform( _origin,
                       _m11, _m12, _m13,
                       _m21, _m22, _m23,
                       _m31, _m32, _m33,
                       _dx, _dy, _dz,
                       True
                     ) ;
end ;

function TGIS_Shape.Transform(
  const _origin : TGIS_Point3D ;
  const _m11    : Double       ;
  const _m12    : Double       ;
  const _m13    : Double       ;
  const _m21    : Double       ;
  const _m22    : Double       ;
  const _m23    : Double       ;
  const _m31    : Double       ;
  const _m32    : Double       ;
  const _m33    : Double       ;
  const _dx     : Double       ;
  const _dy     : Double       ;
  const _dz     : Double       ;
  const _returnnewobj : Boolean
) : TGIS_Shape ;
var
  shp_tmp  : TGIS_Shape ;
  part_no  : Integer    ;
  point_no : Integer    ;

  function do_transform( const _ptg : TGIS_Point3D ) : TGIS_Point3D ;
  var
    tmp : TGIS_Point3D {$IFDEF GIS_NORECORDS} = TGIS_Point3D.Create {$ENDIF} ;
  begin
    {$IFDEF GIS_NORECORDS}
      Result := TGIS_Point3D.create;
    {$ENDIF}
    tmp.X := _ptg.X - _origin.X ;
    tmp.Y := _ptg.Y - _origin.Y ;
    tmp.Z := _ptg.Z - _origin.Z ;

    Result.X := tmp.X * _m11 + tmp.Y * _m21 + tmp.Z * _m31 + _dx ;
    Result.Y := tmp.X * _m12 + tmp.Y * _m22 + tmp.Z * _m32 + _dy ;
    Result.Z := tmp.X * _m13 + tmp.Y * _m23 + tmp.Z * _m33 + _dz ;

    Result.X := Result.X + _origin.X ;
    Result.Y := Result.Y + _origin.Y ;
    Result.Z := Result.Z + _origin.Z ;
    Result.M := _ptg.M               ;
  end ;

begin
  if _returnnewobj then Result := self.CreateCopy
                   else Result := self.MakeEditable ;

  shp_tmp := Result.CreateCopy ;
  try
    Result.Reset ;

    Result.Lock( TGIS_Lock.Extent ) ;
    try
      for part_no :=0 to shp_tmp.GetNumParts -1 do begin
        Result.AddPart ;

        for point_no :=0 to shp_tmp.GetPartSize( part_no ) -1 do begin
          Result.AddPoint3D(
                   do_transform( shp_tmp.GetPoint3D( part_no, point_no ) )
                 ) ;
        end ;
      end ;
    finally
      Result.Unlock ;
    end;
  finally
    FreeObject( shp_tmp );
  end;

end ;

procedure TGIS_Shape.StrokeArc(
  const _center   : TGIS_Point3D ;
  const _radiusA  : Double       ;
  const _radiusB  : Double       ;
  const _start    : Double       ;
  const _stop     : Double       ;
  const _rotation : Double
) ;
begin
  StrokeArc( _center, _radiusA, _radiusB, _start, _stop, _rotation, 360 ) ;
end ;

procedure TGIS_Shape.StrokeArc(
  const _center   : TGIS_Point3D ;
  const _radiusA  : Double       ;
  const _radiusB  : Double       ;
  const _start    : Double       ;
  const _stop     : Double       ;
  const _rotation : Double       ;
  const _segments : Integer
) ;
var
  cnt      : Integer ;
  angle    : Double  ;
  arcangle : Double  ;
  delta    : Double  ;
  step     : Double  ;
  steps    : Integer ;
  rsin     : Double  ;
  rcos     : Double  ;
  ptg      : TGIS_Point3D {$IFDEF GIS_NORECORDS} = TGIS_Point3D.create {$ENDIF};
  block    : Boolean ;
  sa,ca    : Double ;

  function fmod( a, b : Double ) : Double ;
  var
   f : Integer ;
  begin
    f := TruncS( a/b ) ;
    Result := a - (b*f) ;
  end ;
begin

  block := lockMode = TGIS_Lock.None ;
  if block then
    Lock( TGIS_Lock.Extent ) ;
  try
    if GetNumParts = 0 then
      AddPart ;

    // rotation
    SinCos( -_rotation, rsin, rcos ) ;

    delta := (_stop-_start) ;

    if delta > 0 then
      arcangle := fmod( (_stop-_start) + 4*Pi, 2*Pi)
    else
      arcangle := fmod( (_stop-_start) -4*Pi, 2*Pi) ;

    if arcangle = 0 then begin
      // full rotation
      if _stop <> _start then
        arcangle := 2*Pi ;
    end;

    // calculate number of segments - and minimize it
    steps := RoundS( Abs( arcangle ) / (2*Pi) * _segments ) ;
    steps := Max( 4, steps ) ;

    step := arcangle / steps ;

    // calculate elliptical arc
    angle := _start ;
    for cnt := 0 to steps do begin
      SinCos( angle, sa, ca ) ;
      ptg.Y := -_radiusB * sa * rcos +
                _radiusA * ca * rsin + _center.Y ;
      ptg.X :=  _radiusA * ca * rcos +
                _radiusB * sa * rsin + _center.X ;
      ptg.Z := _center.Z ;
      AddPoint3D( ptg ) ;

      angle := angle + step ;
    end ;
  finally
    if block then
      Unlock ;
  end ;
end;

procedure TGIS_Shape.ChangeWinding(
  const _part : Integer
) ;
var
  numParts  : Integer ;
  cShp      : TGIS_Shape ;
  i, j      : Integer ;
begin
  if IsEmpty then exit ;

  numParts := GetNumParts ;

  if ( _part < 0 ) or ( _part >= numParts ) then exit ;

  cShp := CreateCopy ;
  try
    Reset ;
    Lock( TGIS_Lock.Extent ) ;
    for i := 0 to numParts - 1 do begin
      AddPart ;
      if i <> _part then
        for j := 0 to cShp.GetPartSize( i ) - 1 do
          AddPoint3D( cShp.GetPoint3D( i, j ) )
      else
        for j := cShp.GetPartSize( i ) - 1 downto 0 do
          AddPoint3D( cShp.GetPoint3D( i, j ) )
    end ;
  finally
    Unlock ;
    FreeObject( cShp ) ;
  end ;
end ;

procedure TGIS_Shape.ParamsAsDrawn(
  const _params : TGIS_ParamsSectionVector
) ;
begin
  if assigned( Layer ) then
    Layer.ParamsAsDrawn( Self, _params ) ;
end ;

{$IFDEF OXYGENE}
  function TGIS_Shape.ToString
    : String ;
  begin
    Result := ExportToWKT ;
  end;
{$ENDIF}

{$ENDREGION 'TGIS_Shape'}

{$REGION 'TGIS_ShapePoint'}

constructor TGIS_ShapePoint.Create ;
begin
  Create( nil, nil, False, -1, nil, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapePoint.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Create( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapePoint.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Create( _source, _ptr, _mapped, _uid, _layer, _dim ) ;
  FShapeType := TGIS_ShapeType.Point ;
end ;

constructor TGIS_ShapePoint.Create(
  const _dim    : TGIS_DimensionType
) ;
begin
  Create( nil, nil, False, -1, nil, _dim ) ;
end ;


function  TGIS_ShapePoint.fget_Extent
  : TGIS_Extent ;
begin
  {$IFDEF MANAGED}
    {$IFDEF GIS_NORECORDS}
       Result := new TGIS_Extent ;
    {$ENDIF}
    Result.XMin := FPoints.ReadDouble( 0 * sizeOf( Double ) ) ;
    Result.YMin := FPoints.ReadDouble( 1 * sizeOf( Double ) ) ;
    Result.XMax := Result.XMin ;
    Result.YMax := Result.YMin ;
  {$ELSE}
    Result.XMin := PDouble( NativeInt(FPoints) + 0 * sizeOf( Double ) )^ ;
    Result.YMin := PDouble( NativeInt(FPoints) + 1 * sizeOf( Double ) )^ ;
    Result.XMax := PDouble( NativeInt(FPoints) + 0 * sizeOf( Double ) )^ ;
    Result.YMax := PDouble( NativeInt(FPoints) + 1 * sizeOf( Double ) )^ ;
  {$ENDIF}
end ;

function TGIS_ShapePoint.fget_SmartSize
  : Integer ;
begin
  Result := Params.Marker.SmartSize
end ;

function TGIS_ShapePoint.getPartOffset(
  _part : Integer
) : Integer ;
begin
  assert( False, _rsrc( GIS_RS_SHOULD_NOT_BE_CALLED ) ) ;
  Result := 0 ;
end ;

procedure TGIS_ShapePoint.setPoint(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point
) ;
begin
  assert( False, _rsrc( GIS_RS_SHOULD_NOT_BE_CALLED ) ) ;
end ;

function TGIS_ShapePoint.fget_PointsZMin
  : Double ;
begin
  if not IsEmpty and
     ( FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] )
  then begin
    {$IFDEF MANAGED}
      Result := FPoints.ReadDouble( SIZEOF_TGIS_POINT ) ;
    {$ELSE}
      Result := PDouble( NativeInt( FPoints ) + SIZEOF_TGIS_POINT )^
    {$ENDIF}
  end
  else
    Result := 0;
end ;

function TGIS_ShapePoint.fget_PointsZMax
  : Double ;
begin
  if not IsEmpty and
     ( FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] )
  then begin
    {$IFDEF MANAGED}
      Result := FPoints.ReadDouble( SIZEOF_TGIS_POINT ) ;
    {$ELSE}
      Result := PDouble( NativeInt( FPoints ) + SIZEOF_TGIS_POINT )^
    {$ENDIF}
  end
  else
    Result := 0;
end ;

function TGIS_ShapePoint.fget_PointsMMin
  : Double ;
begin
  if not IsEmpty and
     ( FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] )
  then begin
    {$IFDEF MANAGED}
      Result := FPoints.ReadDouble(
                  SIZEOF_TGIS_POINT + sizeOf( Double )
                ) ;
    {$ELSE}
      Result := PDouble(
                  NativeInt( FPoints ) +
                  SIZEOF_TGIS_POINT + sizeOf( Double )
                )^ ;
    {$ENDIF}
  end
  else
    Result := 0;
end ;

function TGIS_ShapePoint.fget_PointsMMax
  : Double ;
begin
  if not IsEmpty and
     ( FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] ) then
  begin
    {$IFDEF MANAGED}
      Result := FPoints.ReadDouble(
                  SIZEOF_TGIS_POINT + sizeOf( Double )
                ) ;
    {$ELSE}
      Result := PDouble(
                  NativeInt( FPoints ) + SIZEOF_TGIS_POINT + sizeOf( Double )
                )^ ;
    {$ENDIF}
  end
  else
    Result := 0;
end ;

procedure TGIS_ShapePoint.setPoint3D(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point3D
) ;
begin
  assert( False, _rsrc( GIS_RS_SHOULD_NOT_BE_CALLED ) ) ;
end ;

procedure TGIS_ShapePoint.setExtentByPoint(
  const _ptg : TGIS_Point
) ;
begin
  assert( False, _rsrc( GIS_RS_SHOULD_NOT_BE_CALLED ) ) ;
end ;

procedure TGIS_ShapePoint.Unlock ;
begin
  if lockMode = TGIS_Lock.None then begin
    exit ;
  end ;

  if lockMode = TGIS_Lock.Internal2 then begin
    lockModified := False ;
    exit ;
  end ;

  try
    if not lockModified then exit ;
    if IsMapped         then exit ;
    if IsEmpty          then exit ;

    if assigned( Layer ) then begin
      if GisLockLessThan( lockMode, TGIS_Lock.Internal ) then
        Layer.Extent3D := GisMaxExtent3D( Layer.Extent3D, Extent3D ) ;
      UpdateIndex ;
    end ;

  finally
    lockMode     := TGIS_Lock.None ;
    lockModified := False       ;
  end ;
end ;

procedure TGIS_ShapePoint.AddPoint(
  const _ptg : TGIS_Point
) ;
var
  ext : TGIS_Extent ;
  ptg : TGIS_Point  ;
begin
  if FShape3D then begin
    AddPoint3D( GisPoint3DFrom2D( _ptg ) )
  end
  else begin
    unmapGeometry ;

    ptg := _TGIS_Point(_ptg) ;
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Unproject_Ref( ptg ) ;

    {$IFDEF MANAGED}
      FPoints.WriteDouble( 0 * sizeOf( Double ), ptg.X ) ;
      FPoints.WriteDouble( 1 * sizeOf( Double ), ptg.Y ) ;
    {$ELSE}
      PGIS_Point( FPoints )^ := _TGIS_Point(ptg) ;
    {$ENDIF}

    {$IFDEF GIS_NORECORDS}
      ext := new TGIS_Extent ;
    {$ENDIF}
    ext.XMin := ptg.X ;
    ext.XMax := ptg.X ;
    ext.YMin := ptg.Y ;
    ext.YMax := ptg.Y ;

    if ( lockMode = TGIS_Lock.None ) and assigned( Layer ) then begin
      Layer.Extent := GisMaxExtent( Layer.Extent, ext ) ;
      UpdateIndex ;
    end ;

    FIsEmpty := False ;
    layerModified( True ) ;
  end ;
end ;

procedure TGIS_ShapePoint.AddPoint3D(
  const _ptg : TGIS_Point3D
) ;
var
  ext : TGIS_Extent3D ;
  ptg : TGIS_Point3D ;
  off : Integer      ;
begin
  if FShape3D then begin
    unmapGeometry ;

    ptg := _TGIS_Point3D(_ptg) ;
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Unproject3D_Ref( ptg ) ;

    {$IFDEF MANAGED}
      off := sizeOf( Double ) ;
      FPoints.WriteDouble( 0, ptg.X ) ;
      FPoints.WriteDouble( off, ptg.Y ) ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        FPoints.WriteDouble( off, ptg.Z ) ;
      end;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        FPoints.WriteDouble( off, ptg.M ) ;
      end;
    {$ELSE}
      PDouble( FPoints )^ := ptg.X ;
      off := sizeOf( Double ) ;
      PDouble( NativeInt( FPoints ) + off )^ := ptg.Y ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        PDouble( NativeInt( FPoints ) + off )^ := ptg.Z ;
      end;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        PDouble( NativeInt( FPoints ) + off )^ := ptg.M ;
      end;
    {$ENDIF}

    {$IFDEF GIS_NORECORDS}
      ext := new TGIS_Extent3D ;
    {$ENDIF}
    ext.XMin := ptg.X ;
    ext.XMax := ptg.X ;
    ext.YMin := ptg.Y ;
    ext.YMax := ptg.Y ;
    ext.ZMin := ptg.Z ;
    ext.ZMax := ptg.Z ;
    ext.MMin := ptg.M ;
    ext.MMax := ptg.M ;

    FPointsZMin := ptg.Z ;
    FPointsZMax := ptg.Z ;
    if not IsNan(ptg.M) then begin
      FPointsMMin := ptg.M ;
      FPointsMMax := ptg.M ;
    end
    else begin
      FPointsMMin := 0 ;
      FPointsMMax := 0 ;
    end ;

    if ( lockMode = TGIS_Lock.None ) and assigned( Layer ) then begin
      Layer.Extent3D := GisMaxExtent3D( Layer.Extent3D, ext ) ;
      UpdateIndex ;
    end ;

    FIsEmpty := False ;
    layerModified( True ) ;
  end
  else begin
    AddPoint( GisPoint2DFrom3D( _ptg ) ) ;
  end ;
end ;

procedure TGIS_ShapePoint.AddPart ;
var
  sizeMax : Integer ;
begin
  unmapGeometry ;
  FIsFixed := False ;

  if IsEmpty then begin
    {$IFDEF MANAGED}
      sizeMax := SIZEOF_TGIS_POINT ;
      if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        inc( sizeMax, sizeOf( Double ) ) ;
      if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        inc( sizeMax, sizeOf( Double ) ) ;

      FPoints := TGIS_Bytes.Create( sizeMax ) ;
    {$ELSE}
      sizeMax := SIZEOF_TGIS_POINT ;
      if FDimension in [TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        inc( sizeMax, sizeOf( Double ) ) ;
      if FDimension in [TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        inc( sizeMax, sizeOf( Double ) ) ;

      GetMem( FPoints, sizeMax ) ;
    {$ENDIF}
    FIsEmpty := False ;
  end ;
  layerModified( True ) ;
end ;

function TGIS_ShapePoint.GetPoint(
  const _part : Integer ;
  const _pos  : Integer
) : TGIS_Point ;
begin
  if FShape3D then begin
    Result := GisPoint2DFrom3D( GetPoint3D( _part, _pos ) ) ;
  end
  else begin
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Point ;
      {$ENDIF}
      Result.X := FPoints.ReadDouble( 0 * sizeOf( Double ) ) ;
      Result.Y := FPoints.ReadDouble( 1 * sizeOf( Double ) ) ;
    {$ELSE}
      Result := PGIS_Point( FPoints )^ ;
    {$ENDIF}

    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project_Ref( Result ) ;
  end ;
end ;

procedure TGIS_ShapePoint.GetPointEx(
  const _part : Integer ;
  const _pos  : Integer ;
  var   _x    : Double  ;
  var   _y    : Double
) ;
var
  ptg : TGIS_Point ;
  z   : Double ;
  m   : Double ;
begin
  if FShape3D then begin
    GetPoint3DEx( _part, _pos, _x, _y, z, m ) ;
  end
  else begin
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        ptg := new TGIS_Point ;
      {$ENDIF}
      ptg.X := FPoints.ReadDouble( 0 * sizeOf( Double ) ) ;
      ptg.Y := FPoints.ReadDouble( 1 * sizeOf( Double ) ) ;
    {$ELSE}
      ptg := PGIS_Point( FPoints )^ ;
    {$ENDIF}

    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project_Ref( ptg ) ;
    _x := ptg.X ;
    _y := ptg.Y ;
  end ;
end ;

{$IFDEF JAVA}
  procedure TGIS_ShapePoint.GetPointEx2(
    const _part : Integer ;
    const _pos  : Integer ;
    const _ptg  : TGIS_Point3D ;
    const _pt   : TPointD
  ) ;
  var
    off : Integer ;
  begin
    if FShape3D then begin
      _ptg.X := FPoints.ReadDouble( 0 ) ;
      off := sizeOf( Double ) ;
      _ptg.Y := FPoints.ReadDouble( off ) ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        _ptg.Z := FPoints.ReadDouble( off ) ;
      end
      else
        _ptg.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        _ptg.M := FPoints.ReadDouble( off ) ;
      end
      else
        _ptg.M := 0 ;

      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Project3D_Ref( _ptg ) ;

      _pt.X := _ptg.X ;
      _pt.Y := _ptg.Y ;
    end
    else begin
        _ptg.X := FPoints.ReadDouble( 0 * sizeOf( Double ) ) ;
        _ptg.Y := FPoints.ReadDouble( 1 * sizeOf( Double ) ) ;
        _ptg.Z := 0 ;
        _ptg.M := 0 ;

      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Project3D_Ref( _ptg ) ;

      _pt.X := _ptg.X ;
      _pt.Y := _ptg.Y ;
    end ;
  end ;
{$ENDIF}

function TGIS_ShapePoint.GetPoint3D(
  const _part : Integer ;
  const _pos  : Integer
) : TGIS_Point3D ;
var
  off      : Integer   ;
  old_lock : TGIS_Lock ;
begin
  if FShape3D then begin
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Point3D ;
      {$ENDIF}
      Result.X := FPoints.ReadDouble( 0 ) ;
      off := sizeOf( Double ) ;
      Result.Y := FPoints.ReadDouble( off ) ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        Result.Z := FPoints.ReadDouble( off ) ;
      end
      else
        Result.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        Result.M := FPoints.ReadDouble( off ) ;
      end
      else
        Result.M := 0 ;
    {$ELSE}
      Result.X := PDouble( FPoints )^ ;
      off := sizeOf( Double ) ;
      Result.Y := PDouble( NativeInt( FPoints ) + off )^ ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        Result.Z := PDouble( NativeInt( FPoints ) + off )^ ;
      end
      else
        Result.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
        inc( off, sizeOf( Double ) ) ;
        Result.M := PDouble( NativeInt( FPoints ) + off )^ ;
      end
      else
        Result.M := 0 ;
    {$ENDIF}

    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project3D_Ref( Result ) ;
  end
  else begin
    old_lock := lockMode ;
    lockMode := TGIS_Lock.Projection ; // turn off projection for a while

    Result := GisPoint3DFrom2D( GetPoint( _part, _pos ) ) ;

    lockMode := old_lock ;
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project3D_Ref( Result ) ;
  end ;
end ;

procedure TGIS_ShapePoint.GetPoint3DEx (
  const _part : Integer ;
  const _pos  : Integer ;
  var   _x    : Double  ;
  var   _y    : Double  ;
  var   _z    : Double  ;
  var   _m    : Double
) ;
var
  ptg3D : TGIS_Point3D ;
  off   : Integer      ;
begin
  if FShape3D then begin
    with ptg3D do begin
      {$IFDEF MANAGED}
        X := FPoints.ReadDouble( 0 ) ;
        off := sizeOf( Double ) ;
        Y := FPoints.ReadDouble( off ) ;

        if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
          inc( off, sizeOf( Double ) ) ;
          Z := FPoints.ReadDouble( off ) ;
        end
        else
          Z := 0 ;

        if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
          inc( off, sizeOf( Double ) ) ;
          M := FPoints.ReadDouble( off ) ;
        end
        else
          M := 0 ;
      {$ELSE}
        X := PDouble( FPoints )^ ;
        off := sizeOf( Double ) ;
        Y := PDouble( NativeInt( FPoints ) + off )^ ;

        if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
          inc( off, sizeOf( Double ) ) ;
          Z := PDouble( NativeInt( FPoints ) + off )^ ;
        end
        else
          Z := 0 ;

        if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
          inc( off, sizeOf( Double ) ) ;
          M := PDouble( NativeInt( FPoints ) + off )^ ;
        end
        else
          M := 0 ;
      {$ENDIF}

      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Project3D_Ref( ptg3D ) ;

      _x := X ;
      _y := Y ;
      _z := Z ;
      _m := M ;
    end ;
  end
  else begin
    GetPointEx( _part, _pos, _x, _y ) ;
  end ;
end ;

function TGIS_ShapePoint.GetNumPoints
  : Integer ;
begin
  if assigned( FPoints ) then Result := 1
                         else Result := 0
end ;

function TGIS_ShapePoint.GetNumParts
  : Integer ;
begin
  if assigned( FPoints ) then Result := 1
                         else Result := 0
end ;

function TGIS_ShapePoint.GetPartSize(
  const _part : Integer
) : Integer ;
begin
  if IsEmpty then Result := 0
             else Result := 1 ;
end ;

function TGIS_ShapePoint.Distance2Part(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  ptg : TGIS_Point ;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  ptg    := GetPoint( 0, 0 ) ;
  Result := GisLineLength( ptg, _ptg  );
  _proj  := _TGIS_Point(ptg) ;
end ;

function TGIS_ShapePoint.Distance2PartCS(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  ptg : TGIS_Point ;
  opt : TGIS_Point ;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  ptg := pointToWGS( _ptg ) ;
  opt := pointToWGS( GetPoint( 0, 0 ) ) ;

  _proj  := GetPoint( 0, 0 ) ;
  Result := distanceWGS( ptg, opt ) ;
end ;

function  TGIS_ShapePoint.Centroid
  : TGIS_Point ;
begin
  Result := GetPoint( 0, 0 ) ;
end ;

function TGIS_ShapePoint.IsInsideCircle(
  const _center : TGIS_Point;
  const _range : Double ;
  const _itype : TGIS_InsideType
) : Boolean;
var
  point    : TGIS_Point ;
begin
  if IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  Result := True ;
  point := GetPoint(0, 0) ;
  if Sqrt( Sqr( _center.X - point.X ) + Sqr( _center.Y - point.Y ) ) > _range then
    Result := False ;
end ;

function TGIS_ShapePoint.IsInsidePolygon(
  const _shape : TGIS_ShapePolygon ;
  const _itype : TGIS_InsideType
) : Boolean ;
begin
  if ( not assigned( _shape ) ) or IsEmpty or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  Result := GisIsPointInsidePolygon( GetFirstPoint, _shape ) ;
end ;

function TGIS_ShapePoint.IsCommonPoint(
  const _shape : TGIS_Shape
) : Boolean;
var
  point_idx,
  point_no  : Integer ;
begin
  if ( not assigned( _shape ) ) or IsEmpty or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  result := False ;

  case _shape.ShapeType of
    TGIS_ShapeType.Polygon :
       if GisIsPointInsidePolygon( self.GetPoint(0,0),
                                   TGIS_ShapePolygon(_shape)
                                 )
         then Result := True ;
    TGIS_ShapeType.Arc :
       if _shape.Distance(self.GetPoint(0,0), 0) = 0
       then Result := True ;
    TGIS_ShapeType.Point :
       if GisIsSamePoint( _shape.GetPoint(0,0), self.GetPoint(0,0) )
       then Result := True ;
    TGIS_ShapeType.MultiPoint :
       begin
         point_no := _shape.GetPartSize(0);
         for point_idx := 0 to point_no -1 do
           if GisIsSamePoint( _shape.GetPoint(0,0), self.GetPoint(0,0) ) then
           begin
             Result := True ;
             break ;
           end ;
         end ;
    else begin
           assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
           Result := False ;
         end ;
  end ;

end ;

function TGIS_ShapePoint.ExportToGML
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPointToGML( self ) ;
end ;

function TGIS_ShapePoint.ExportToJSON
  : String;
begin
  Result := TGIS_GeometryFactory.GisExportPointToJSON( self ) ;
end;

function TGIS_ShapePoint.ExportToEWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPointToEWKT( self ) ;
end ;

procedure TGIS_ShapePoint.ExportToEWKB(
  var _ewkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPointToEWKB( self, _ewkb ) ;
end ;

function TGIS_ShapePoint.ExportToWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPointToWKT( self ) ;
end ;

procedure TGIS_ShapePoint.ExportToWKB(
  var _wkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPointToWKB( self, _wkb );
end ;

procedure TGIS_ShapePoint.ExportToGDO(
  var _gdo : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPointToGDO( self, _gdo );
end ;

procedure TGIS_ShapePoint.ExportToVAR(
  var _var : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPointToVAR( self, _var );
end ;

{$ENDREGION 'TGIS_ShapePoint'}

{$REGION 'TGIS_ShapeMultiPoint'}

constructor TGIS_ShapeMultiPoint.Create ;
begin
  Create( nil, nil, False, -1, nil, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeMultiPoint.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Create( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeMultiPoint.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Create( _source, _ptr, _mapped, _uid, _layer, _dim ) ;
  FShapeType := TGIS_ShapeType.MultiPoint ;
end ;

constructor TGIS_ShapeMultiPoint.Create(
  const _dim    : TGIS_DimensionType
) ;
begin
  Create( nil, nil, False, -1, nil, _dim ) ;
end ;

function TGIS_ShapeMultiPoint.fget_SmartSize
  : Integer ;
begin
  Result := Params.Marker.SmartSize ;
end ;

function TGIS_ShapeMultiPoint.getPartOffset(
  _part : Integer
) : Integer ;
begin
  assert( False, _rsrc( GIS_RS_SHOULD_NOT_BE_CALLED ) ) ;
  Result := 0 ;
end ;

procedure TGIS_ShapeMultiPoint.setPoint(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point
) ;
begin
  assert( False, _rsrc( GIS_RS_SHOULD_NOT_BE_CALLED ) ) ;
end ;

procedure TGIS_ShapeMultiPoint.setPoint3D(
  const _part : Integer;
  const _pos  : Integer;
  const _ptg  : TGIS_Point3D
) ;
begin
  assert( False, _rsrc( GIS_RS_SHOULD_NOT_BE_CALLED ) ) ;
end ;

function TGIS_ShapeMultiPoint.getIntersectInternal(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
var
  k        : Integer ;
  point    : TGIS_Point ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeMultiPoint.Create(nil, nil, False, Uid, Layer) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    Result.AddPart ;
    for k := 0 to GetPartSize(0) -1 do begin
      Result.AddPoint( GetPoint(0, k) );
    end ;

    Result.Unlock ;

    exit ;
  end ;

  if IsInsideExtent(_extent, TGIS_InsideType.Partial) then begin
    Result := TGIS_ShapeMultiPoint.Create(nil, nil, False, Uid, Layer) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    Result.AddPart ;
    for k := 0 to GetPartSize(0) -1 do begin
      point := GetPoint(0, k);
      if ( point.X <= _extent.XMax ) and
         ( point.X >= _extent.XMin ) and
         ( point.Y <= _extent.YMax ) and
         ( point.Y >= _extent.YMin )
      then
        Result.AddPoint(point);
    end ;

    if not Result.IsEmpty then begin
      Result.Unlock ;
      exit ;
    end
    else
      FreeObject( Result ) ;
  end ;
end ;

function TGIS_ShapeMultiPoint.getIntersectInternal3D(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
var
  k        : Integer ;
  point    : TGIS_Point3D ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeMultiPoint.Create(nil, nil, False, Uid, Layer, Dimension) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    Result.AddPart ;
    for k := 0 to GetPartSize(0) -1 do begin
      Result.AddPoint3D( GetPoint3D(0, k) );
    end ;

    Result.Unlock ;

    exit ;
  end ;

  if IsInsideExtent(_extent, TGIS_InsideType.Partial) then begin
    Result := TGIS_ShapeMultiPoint.Create(nil, nil, False, Uid, Layer, Dimension) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    Result.AddPart ;
    for k := 0 to GetPartSize(0) -1 do begin
      point := GetPoint3D(0, k);
      if ( point.X <= _extent.XMax ) and
         ( point.X >= _extent.XMin ) and
         ( point.Y <= _extent.YMax ) and
         ( point.Y >= _extent.YMin )
      then
        Result.AddPoint3D(point);
    end ;

    if not Result.IsEmpty then begin
      Result.Unlock ;
      exit ;
    end
    else
      FreeObject( Result ) ;
  end ;
end ;

procedure TGIS_ShapeMultiPoint.AddPoint(
  const _ptg : TGIS_Point
) ;
var
  ptg : TGIS_Point  ;
begin
  if FShape3D then begin
    AddPoint3D( GisPoint3DFrom2D( _ptg ) ) ;
  end
  else begin
    unmapGeometry ;
    reallocGeometry;
    FIsFixed := False ;

    ptg := _TGIS_Point(_ptg) ;
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Unproject_Ref( ptg ) ;

    if lockMode = TGIS_Lock.None then
      setExtentByPoint( ptg ) ;

    {$IFDEF MANAGED}
      FPoints.WriteDouble(
        GetNumPoints * SIZEOF_TGIS_POINT,
        ptg.X
      ) ;
      FPoints.WriteDouble(
        GetNumPoints * SIZEOF_TGIS_POINT +
        sizeOf( Double ),
        ptg.Y
      ) ;
    {$ELSE}
      PGIS_Point(
        NativeInt(FPoints) +
        GetNumPoints * SIZEOF_TGIS_POINT
      )^ := _TGIS_Point(ptg) ;
    {$ENDIF}
    {$IFDEF MANAGED}
      FParts.Inc( OFFSET_MULTIPOINTS ) ;
    {$ELSE}
      inc( PInteger(NativeInt(FParts) + OFFSET_MULTIPOINTS )^ ) ;
    {$ENDIF}

    FIsEmpty := False ;
    layerModified( True ) ;
  end ;
end ;

procedure TGIS_ShapeMultiPoint.AddPoint3D(
  const _ptg : TGIS_Point3D
) ;
var
  ptg : TGIS_Point3D  ;
begin
  if FShape3D then begin
    unmapGeometry ;
    reallocGeometry;
    FIsFixed := False ;

    ptg := _TGIS_Point3D(_ptg) ;
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Unproject3D_Ref( ptg ) ;

    if lockMode = TGIS_Lock.None then
      setExtentByPoint3D( ptg ) ;

    {$IFDEF MANAGED}
      FPoints.WriteDouble(
        GetNumPoints * SIZEOF_TGIS_POINT,
        ptg.X
      ) ;
      FPoints.WriteDouble(
        GetNumPoints * SIZEOF_TGIS_POINT + sizeOf( Double ),
        ptg.Y
      ) ;
      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        FPointsZ.WriteDouble( GetNumPoints * sizeOf(Double), ptg.Z ) ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        FPointsM.WriteDouble( GetNumPoints * sizeOf(Double), ptg.M ) ;
    {$ELSE}
      PDouble(
        NativeInt(FPoints) +
        GetNumPoints * SIZEOF_TGIS_POINT
      )^ := ptg.X;
      PDouble(
        NativeInt(FPoints) +
        GetNumPoints * SIZEOF_TGIS_POINT + sizeOf( Double )
      )^ := ptg.Y;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        PDouble(
          NativeInt(FPointsZ) +
          GetNumPoints * sizeOf(Double)
        )^ := ptg.Z;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        PDouble(
          NativeInt(FPointsM) +
          GetNumPoints * sizeOf(Double)
        )^ := ptg.M;

    {$ENDIF}
    {$IFDEF MANAGED}
      FParts.Inc( OFFSET_MULTIPOINTS ) ;
    {$ELSE}
      inc( PInteger(NativeInt(FParts) + OFFSET_MULTIPOINTS )^ ) ;
    {$ENDIF}

    FIsEmpty := False ;
    layerModified( True ) ;
  end
  else begin
    AddPoint( GisPoint2DFrom3D( _ptg ) ) ;
  end ;
end ;

procedure TGIS_ShapeMultiPoint.AddPart ;
{$IFNDEF MANAGED}
  var
    pext : PGIS_Extent ;
{$ENDIF}
begin
  unmapGeometry ;
  FIsFixed := False ;

  if IsEmpty then begin
    reallocGeometry;
    {$IFDEF MANAGED}
      FParts.WriteInt32( OFFSET_MULTIPOINTS, 0 ) ;
    {$ELSE}
      PInteger(NativeInt(FParts) + OFFSET_MULTIPOINTS)^ := 0 ;
    {$ENDIF}
    {$IFDEF MANAGED}
      FParts.WriteDouble( 0 * sizeOf( Double ), 0 ) ;
      FParts.WriteDouble( 1 * sizeOf( Double ), 0 ) ;
      FParts.WriteDouble( 2 * sizeOf( Double ), 0 ) ;
      FParts.WriteDouble( 3 * sizeOf( Double ), 0 ) ;
    {$ELSE}
      pext := PGIS_Extent(FParts) ;
      pext^.XMin := 0 ;
      pext^.XMax := 0 ;
      pext^.YMin := 0 ;
      pext^.YMax := 0 ;
    {$ENDIF}
  end ;
  layerModified( True ) ;
end ;

function TGIS_ShapeMultiPoint.GetPoint(
  const _part : Integer ;
  const _pos  : Integer
) : TGIS_Point ;
begin
  if FShape3D then begin
    Result := GisPoint2DFrom3D( GetPoint3D( _part, _pos ) ) ;
  end
  else begin
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Point ;
      {$ENDIF}
      Result.X := FPoints.ReadDouble(
                    _pos * SIZEOF_TGIS_POINT
                  ) ;
      Result.Y := FPoints.ReadDouble(
                    _pos * SIZEOF_TGIS_POINT + sizeOf( Double )
                  ) ;
    {$ELSE}
      Result := PGIS_Point(
                  NativeInt(FPoints) +
                  _pos * SIZEOF_TGIS_POINT
                )^;
    {$ENDIF}

    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project_Ref( Result ) ;
  end ;
end ;

procedure TGIS_ShapeMultiPoint.GetPointEx(
  const _part : Integer ;
  const _pos  : Integer ;
  var   _x    : Double  ;
  var   _y    : Double
) ;
var
  ptg  : TGIS_Point ;
  z, m : Double ;
begin
  if FShape3D then begin
    GetPoint3DEx( _part, _pos, _x, _y, z, m ) ;
  end
  else begin
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        ptg := new TGIS_Point ;
      {$ENDIF}
      ptg.X := FPoints.ReadDouble(
                 _pos * SIZEOF_TGIS_POINT
               ) ;
      ptg.Y := FPoints.ReadDouble(
                 _pos * SIZEOF_TGIS_POINT + sizeOf( Double )
               ) ;
    {$ELSE}
      ptg := PGIS_Point( NativeInt(FPoints) +
                         + _pos * SIZEOF_TGIS_POINT )^;
    {$ENDIF}

    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project_Ref( ptg ) ;

    _x := ptg.X ;
    _y := ptg.Y ;
  end ;
end ;

{$IFDEF JAVA}
  procedure TGIS_ShapeMultiPoint.GetPointEx2(
    const _part : Integer ;
    const _pos  : Integer ;
    const _ptg  : TGIS_Point3D ;
    const _pt   : TPointD
  ) ;
  begin
    if FShape3D then begin
        _ptg.X := FPoints.ReadDouble( _pos * SIZEOF_TGIS_POINT ) ;
        _ptg.Y := FPoints.ReadDouble( _pos * SIZEOF_TGIS_POINT + sizeOf( Double ) ) ;

        if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then begin
          _ptg.Z := FPoints.ReadDouble( _pos * SIZEOF_TGIS_POINT + sizeOf( Double ) + sizeOf( Double ) ) ;
        end
        else
          _ptg.Z := 0 ;

        if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then begin
          _ptg.M := FPoints.ReadDouble( _pos * SIZEOF_TGIS_POINT + sizeOf( Double ) + sizeOf( Double ) + sizeOf( Double ) ) ;
        end
        else
          _ptg.M := 0 ;
    end
    else begin
        _ptg.X := FPoints.ReadDouble( _pos * SIZEOF_TGIS_POINT ) ;
        _ptg.Y := FPoints.ReadDouble( _pos * SIZEOF_TGIS_POINT + sizeOf( Double ) ) ;
        _ptg.Z := 0 ;
        _ptg.M := 0 ;

      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Project3D_Ref( _ptg ) ;
    end ;
    _pt.X := _ptg.X ;
    _pt.Y := _ptg.Y ;
  end ;
{$ENDIF}

function TGIS_ShapeMultiPoint.GetPoint3D(
  const _part : Integer ;
  const _pos  : Integer
) : TGIS_Point3D ;
var
  old_lock : TGIS_Lock ;
begin
  if FShape3D then begin
    {$IFDEF MANAGED}
      {$IFDEF GIS_NORECORDS}
        Result := new TGIS_Point3D ;
      {$ENDIF}
      Result.X := FPoints.ReadDouble(
                    _pos * SIZEOF_TGIS_POINT
                  );
      Result.Y := FPoints.ReadDouble(
                    _pos * SIZEOF_TGIS_POINT + sizeOf( Double )
                  ) ;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        Result.Z := FPointsZ.ReadDouble( _pos * sizeOf( Double ) )
      else
        Result.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        Result.M := FPointsM.ReadDouble( _pos * sizeOf( Double ) )
      else
        Result.M := 0 ;
    {$ELSE}
      Result.X := PDouble(
                    NativeInt(FPoints) +
                    _pos * SIZEOF_TGIS_POINT
                  )^ ;
      Result.Y := PDouble(
                    NativeInt(FPoints) +
                    _pos * SIZEOF_TGIS_POINT + sizeOf( Double )
                  ) ^;

      if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
        Result.Z := PDouble( NativeInt(FPointsZ) + _pos * sizeOf( Double ) )^
      else
        Result.Z := 0 ;

      if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
        Result.M := PDouble( NativeInt(FPointsM) + _pos * sizeOf( Double ) )^
      else
        Result.M := 0 ;
    {$ENDIF}
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project3D_Ref( Result ) ;
  end
  else begin
    old_lock := lockMode ;
    lockMode := TGIS_Lock.Projection ; // turn off projection for a while

    Result := GisPoint3DFrom2D( GetPoint( _part, _pos ) ) ;

    lockMode := old_lock ;
    if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
      Layer.Project3D_Ref( Result ) ;
  end ;
end ;

procedure TGIS_ShapeMultiPoint.GetPoint3DEx(
  const _part : Integer ;
  const _pos  : Integer ;
  var   _x    : Double  ;
  var   _y    : Double  ;
  var   _z    : Double  ;
  var   _m    : Double
) ;
var
  ptg : TGIS_Point3D ;
begin
  if FShape3D then begin
    with ptg do begin
      {$IFDEF MANAGED}
        X := FPoints.ReadDouble(
               _pos * SIZEOF_TGIS_POINT
             ) ;
        Y := FPoints.ReadDouble(
               _pos * SIZEOF_TGIS_POINT + sizeOf( Double )
             ) ;
        if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
          Z := FPointsZ.ReadDouble( _pos * sizeOf( Double ) )
        else
          Z := 0 ;

        if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
          Z := FPointsM.ReadDouble( _pos * sizeOf( Double ) )
        else
          M := 0 ;
      {$ELSE}
        X := PDouble(
               NativeInt(FPoints) + _pos * SIZEOF_TGIS_POINT
             )^ ;
        Y := PDouble(
               NativeInt(FPoints) + _pos * SIZEOF_TGIS_POINT + sizeOf( Double )
             )^ ;

        if FDimension in [ TGIS_DimensionType.XYZ, TGIS_DimensionType.XYZM ] then
          Z := PDouble( NativeInt(FPointsZ) + _pos * sizeOf( Double ) )^
        else
          Z := 0 ;

        if FDimension in [ TGIS_DimensionType.XYM, TGIS_DimensionType.XYZM ] then
          M := PDouble( NativeInt(FPointsM) + _pos * sizeOf( Double ) )^
        else
          M := 0 ;
      {$ENDIF}

      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Project3D_Ref( ptg ) ;

      _x := X ;
      _y := Y ;
      _z := Z ;
      _m := M ;
    end ;
  end
  else begin
    GetPointEx( _part, _pos, _x, _y ) ;
  end ;
end ;

function TGIS_ShapeMultiPoint.GetNumPoints
  : Integer ;
begin
  if assigned( FParts ) then
    {$IFDEF MANAGED}
      Result := FParts.ReadInt32( OFFSET_MULTIPOINTS )
    {$ELSE}
      Result := PInteger( NativeInt(FParts) + OFFSET_MULTIPOINTS )^
    {$ENDIF}
  else
    Result := 0 ;
end ;

function TGIS_ShapeMultiPoint.GetNumParts
  : Integer ;
begin
  if assigned( FPoints ) then Result := 1
                         else Result := 0
end ;

function TGIS_ShapeMultiPoint.GetPartSize(
  const _part : Integer
) : Integer ;
begin
  Result := GetNumPoints ;
end ;

function TGIS_ShapeMultiPoint.Distance2Part(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  i    : Integer ;
  dist : Double ;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  Result := GIS_MAX_DOUBLE ; // really far away :)
  _proj := _ptg ;
  for i := 0 to GetPartSize(0) -1 do begin
      dist := GisPoint2Point(_ptg, GetPoint(0, i)) ;
      if dist < Result then begin
        Result := dist ;
        _proj := GetPoint(0, i) ;
      end ;
  end ;
end ;

function TGIS_ShapeMultiPoint.Distance2PartCS(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  ptg : TGIS_Point ;
  dst : Double ;
  tmp : Double ;
  ipo : Integer ;
  opt : TGIS_Point ;
  i   : Integer ;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  ptg := pointToWGS( _ptg ) ;
  ipo := 0 ;
  dst := GIS_MAX_DOUBLE ;

  if indexDist2PartCS < 0 then begin
    for i := 0 to GetPartSize( 0 ) - 1 do begin
      tmp := haversineFormula( ptg, pointToWGS( GetPoint( 0, i ) ) ) ;
      if tmp < dst then begin
        dst := tmp ;
        ipo := i ;
      end ;
    end ;
  end
  else
    ipo := indexDist2PartCS ;

  opt := pointToWGS( GetPoint( 0, ipo ) ) ;

  _proj := GetPoint( 0, ipo ) ;
  Result := distanceWGS( ptg, opt ) ;
end ;

function  TGIS_ShapeMultiPoint.Centroid
  : TGIS_Point ;
begin
  Result := GisCenterPoint( ProjectedExtent );
end ;

function TGIS_ShapeMultiPoint.IsInsideCircle(
  const _center : TGIS_Point;
  const _range : Double ;
  const _itype : TGIS_InsideType
) : Boolean;
var
  point_no : Integer ;
  line_pt  : TGIS_Point ;
begin

  if IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  Result := True ;

  case _itype of
    TGIS_InsideType.Full :
         begin
           for point_no := 0 to GetPartSize( 0 ) - 1 do begin
             line_pt := GetPoint(0, point_no) ;
             if GisPoint2Point( _center, line_pt ) > _range then begin
               Result := False ;
               break ;
             end ;
           end ;
         end ;
    TGIS_InsideType.Partial :
         begin
           Result := False ;
           for point_no := 0 to GetPartSize( 0 ) - 1 do begin
             line_pt := GetPoint(0, point_no) ;
             if GisPoint2Point( _center, line_pt ) <= _range then begin
               Result := True ;
               break ;
             end ;
           end ;
         end ;
    TGIS_InsideType.Centroid :
         if GisPoint2Point( _center, Centroid ) <= _range then
           Result := True
         else
           Result := False ;
    else begin
           assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
           Result := False ;
         end ;
  end ;

end ;

function TGIS_ShapeMultiPoint.IsInsidePolygon(
  const _shape : TGIS_ShapePolygon ;
  const _itype : TGIS_InsideType
) : Boolean ;
var
  cns : TGIS_Shape ;
  tpl : TGIS_Topology ;
begin
  if ( not assigned( _shape ) ) or IsEmpty or _shape.IsEmpty then begin
    Result := False;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    case _itype of
      TGIS_InsideType.Full :
        Result := tpl.Relate(self, _shape, '**F') ;
      TGIS_InsideType.Partial :
        Result := tpl.Relate(self, _shape, 'T') ;
      TGIS_InsideType.Centroid :
        begin
          cns := TGIS_ShapePoint.Create(nil, nil, false, -1, _shape.Layer) ;
          cns.AddPart ;
          cns.AddPoint(Centroid);
          Result := tpl.Relate(cns, _shape, '**F') ;
          FreeObject(cns) ;
        end ;
      else
        Result := False ;
    end ;
  finally
    FreeObject( tpl ) ;
  end ;

end ;

function TGIS_ShapeMultiPoint.IsCommonPoint(
  const _shape : TGIS_Shape
) : Boolean;
 var
  in_pt_idx,
  point_idx,
  point_no  : Integer ;
  in_pt_no  : Integer ;

begin
  if ( not assigned( _shape ) ) or IsEmpty or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  Result := False ;

  case _shape.ShapeType of
    TGIS_ShapeType.Polygon :
         begin
           point_no := _shape.GetPartSize(0);
           for point_idx := 0 to point_no do
             if GisIsPointInsidePolygon( self.GetPoint(0,point_idx),
                                         TGIS_ShapePolygon(_shape)
                                       )
               then begin
                 Result := True ;
                 break ;
               end ;
           end ;
    TGIS_ShapeType.Arc :
         begin
           point_no := GetPartSize(0);
           for point_idx := 0 to point_no do
           if _shape.Distance(self.GetPoint(0,point_idx), 0) = 0 then begin
             Result := True ;
             break ;
           end ;
         end ;
    TGIS_ShapeType.Point :
         begin
           Result := _shape.IsCommonPoint(self) ;
         end ;
    TGIS_ShapeType.MultiPoint :
         begin
           in_pt_no := _shape.GetPartSize(0) ;
           point_no := GetPartSize(0) ;
           for in_pt_idx := 0 to in_pt_no -1 do
             for point_idx := 0 to point_no -1 do
               if GisIsSamePoint( _shape.GetPoint(0,in_pt_idx),
                                  self.GetPoint(0,point_idx)
                                )
               then begin
                 Result := True ;
                 exit ;
               end ;
         end ;

    else begin
           assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
           Result := False ;
         end ;
  end ;

end ;

function TGIS_ShapeMultiPoint.ExportToGML
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportMultiPointToGML( self );
end ;

function TGIS_ShapeMultiPoint.ExportToJSON
  : String;
begin
  Result := TGIS_GeometryFactory.GisExportMultiPointToJSON( self );
end;

function TGIS_ShapeMultiPoint.ExportToEWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportMultiPointToEWKT( self ) ;
end ;

procedure TGIS_ShapeMultiPoint.ExportToEWKB(
  var _ewkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportMultiPointToEWKB( self, _ewkb ) ;
end ;

function TGIS_ShapeMultiPoint.ExportToWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportMultiPointToWKT( self );
end ;

procedure TGIS_ShapeMultiPoint.ExportToWKB(
  var _wkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportMultiPointToWKB( self, _wkb );
end ;

procedure TGIS_ShapeMultiPoint.ExportToGDO(
  var _gdo : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportMultiPointToGDO( self, _gdo );
end ;

procedure TGIS_ShapeMultiPoint.ExportToVAR(
  var _var : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportMultiPointToVAR( self, _var );
end ;

{$ENDREGION 'TGIS_ShapeMultiPoint'}

{$REGION 'TGIS_ShapeArc'}

constructor TGIS_ShapeArc.Create ;
begin
  Create( nil, nil, False, -1, nil, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeArc.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Create( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeArc.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Create( _source, _ptr, _mapped, _uid, _layer, _dim ) ;
  FShapeType := TGIS_ShapeType.Arc ;
end ;

constructor TGIS_ShapeArc.Create(
  const _dim    : TGIS_DimensionType
) ;
begin
  Create( nil, nil, False, -1, nil, _dim ) ;
end ;

function TGIS_ShapeArc.fget_SmartSize
  : Integer ;
begin
  Result := Params.Line.SmartSize ;
end ;

function TGIS_ShapeArc.getIntersectInternal(
  const _extent : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
const
  NEARZERO = 1e-30 ;
var
  p1, p2      : TGIS_Point  ;
  point_no    : Integer     ;
  part_no     : Integer     ;
  part_size   : Integer     ;
  out_pts     : array of TGIS_Point ;
  idx         : Integer ;
  lcount      : Integer ;
  res         : TGIS_Shape ;

  procedure prepare_result ;
  var
    i : Integer ;
    tpt : TGIS_Point ;
  begin
    lcount := 0 ;
    {$IFDEF GIS_NORECORDS}
      tpt := new TGIS_Point ;
    {$ENDIF}
    for i := 0 to idx -2 do begin
      tpt.X := (out_pts[i].X +out_pts[i +1].X) / 2 ;
      tpt.Y := (out_pts[i].Y +out_pts[i +1].Y) / 2 ;

      if Abs(_extent.XMin - tpt.X) <= NEARZERO then begin
        lcount := 0 ;
        continue ;
      end ;

      if Abs(_extent.XMax - tpt.X) <= NEARZERO then begin
        lcount := 0 ;
        continue ;
      end ;

      if Abs(_extent.YMin - tpt.Y) <= NEARZERO  then begin
        lcount := 0 ;
        continue ;
      end ;

      if Abs(_extent.YMax - tpt.Y) <= NEARZERO then begin
        lcount := 0 ;
        continue ;
      end ;

      if lcount = 0 then begin
        res.AddPart ;
        res.AddPoint(out_pts[i]);
        inc( lcount ) ;
      end ;
      res.AddPoint(out_pts[i +1]);
      inc( lcount ) ;
    end ;
  end ;

  procedure cut_vector ;
  var
    deltax, deltay, xin,xout,  yin,yout : Double ;
    tinx,tiny,  toutx,touty,  tin1, tin2,  tout1 : Double ;
  begin

    deltax := p2.X - p1.X ;
    if deltax = 0 then begin
      // bump off of the vertical
      if p1.X > _extent.XMin then deltax := -NEARZERO
                             else deltax :=  NEARZERO ;
    end ;

    deltay := p2.Y-p1.Y ;
    if deltay = 0 then begin
      // bump off of the horizontal
      if p1.Y > _extent.YMin then deltay := -NEARZERO
                             else deltay :=  NEARZERO ;
    end ;

    if deltax > 0 then begin
      // points to right
      xin  := _extent.XMin ;
      xout := _extent.XMax ;
    end
    else begin
      xin  := _extent.XMax ;
      xout := _extent.XMin ;
    end ;

    if deltay > 0 then begin
      // points up
      yin  := _extent.YMin ;
      yout := _extent.YMax ;
    end
    else begin
      yin  := _extent.YMax ;
      yout := _extent.YMin ;
    end ;

    if Abs(deltax) < NEARZERO then begin
      if Sign( deltax ) = -1 then
        deltax := -NEARZERO
      else
        deltax :=  NEARZERO ;
    end ;

    if Abs(deltay) < NEARZERO then begin
      if Sign( deltay ) = -1 then
        deltay := -NEARZERO
      else
        deltay :=  NEARZERO ;
    end ;

    tinx := ( xin - p1.X ) / deltax ;
    tiny := ( yin - p1.Y ) / deltay ;

    if tinx < tiny then begin
      // hits x first
      tin1 := tinx ;
      tin2 := tiny ;
    end
    else begin
      // hits y first
      tin1 := tiny ;
      tin2 := tinx ;
    end ;

    if 1 >= tin1 then begin
      if 0 < tin1 then begin
        out_pts[idx] := GisPoint( xin, yin ) ;
        inc( idx ) ;
      end ;
      if 1 >= tin2 then begin
        toutx := ( xout - p1.X ) / deltax ;
        touty := ( yout - p1.Y ) / deltay ;

        if toutx < touty then tout1 := toutx
                         else tout1 := touty ;

        if ( 0 < tin2 ) or ( 0 < tout1 ) then begin
          if tin2 <= tout1 then begin
            if 0 < tin2 then begin
              if tinx > tiny then begin
                out_pts[idx] := GisPoint( xin, p1.Y+tinx*deltay ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint( p1.X + tiny*deltax, yin ) ;
                inc( idx ) ;
              end ;
            end ;
            if 1 > tout1 then begin
              if toutx < touty then begin
                out_pts[idx] := GisPoint( xout, p1.Y+toutx*deltay) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint( p1.X + touty*deltax, yout) ;
                inc( idx ) ;
              end ;
            end
            else begin
              out_pts[idx] := _TGIS_Point( p2 ) ;
              inc( idx ) ;
            end ;
          end
          else begin
            if tinx > tiny then begin
              out_pts[idx] := GisPoint( xin, yout ) ;
              inc( idx ) ;
            end
            else begin
              out_pts[idx] := GisPoint( xout, yin ) ;
              inc( idx ) ;
            end ;
          end ;
        end ;
      end ;
    end ;
  end ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeArc.Create(nil, nil, False, Uid, Layer ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      Result.AddPart ;
      part_size := GetPartSize( part_no ) ;
      for point_no := 0 to part_size -1 do  begin
        Result.AddPoint( GetPoint( part_no, point_no ) ) ;
      end ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  res := TGIS_ShapeArc.Create(nil, nil, False, Uid, Layer ) ;

  copyInternalFields( self, res ) ;
  copyInternalParams( self, res ) ;

  if _lockInternal2 then res.Lock( TGIS_Lock.Internal2 )
                    else res.Lock( TGIS_Lock.Internal  ) ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    part_size := GetPartSize( part_no ) ;
    if part_size > 0 then begin
      SetLength( out_pts, 2*part_size +2 ) ;

      idx := 0 ;

      p1 := GetPoint( part_no, 0 ) ;
      if ( p1.X > 1e30 ) or ( p1.Y > 1e30 ) then
        continue ;

      p2 := GetPoint( part_no, 0 ) ;
      if ( p2.X > 1e30 ) or ( p2.Y > 1e30 ) then
        continue ;

      cut_vector ;

      for point_no := 1 to part_size -1 do  begin
        // translate all points in the part to screen coordinates
        p2 := GetPoint( part_no, point_no ) ;
        if ( p2.X > 1e30 ) or ( p2.Y > 1e30 ) then
          continue ;

        cut_vector ;

        p1 := _TGIS_Point( p2 ) ;
      end ;
      if idx > 0 then
        prepare_result ;
    end ;
  end ;

  Result := res ;

  if not Result.IsEmpty then begin
    Result.Unlock ;
  end
  else
    FreeObject( Result ) ;
end ;

function TGIS_ShapeArc.getIntersectInternal3D(
  const _extent : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
const
  NEARZERO = 1e-30 ;
var
  p1, p2      : TGIS_Point3D;
  point_no    : Integer     ;
  part_no     : Integer     ;
  part_size   : Integer     ;
  out_pts     : array of TGIS_Point3D ;
  idx         : Integer ;
  lcount      : Integer ;
  res         : TGIS_Shape ;

  procedure prepare_result ;
  var
    i : Integer ;
    tpt : TGIS_Point3D ;
  begin
    lcount := 0 ;
    {$IFDEF GIS_NORECORDS}
      tpt := new TGIS_Point3D ;
    {$ENDIF}
    for i := 0 to idx -2 do begin
      tpt.X := (out_pts[i].X +out_pts[i +1].X) / 2 ;
      tpt.Y := (out_pts[i].Y +out_pts[i +1].Y) / 2 ;
      tpt.Z := (out_pts[i].Z +out_pts[i +1].Z) / 2 ;
      tpt.M := (out_pts[i].M +out_pts[i +1].M) / 2 ;

      if Abs(_extent.XMin - tpt.X) <= NEARZERO then begin
        lcount := 0 ;
        continue ;
      end ;

      if Abs(_extent.XMax - tpt.X) <= NEARZERO then begin
        lcount := 0 ;
        continue ;
      end ;

      if Abs(_extent.YMin - tpt.Y) <= NEARZERO  then begin
        lcount := 0 ;
        continue ;
      end ;

      if Abs(_extent.YMax - tpt.Y) <= NEARZERO then begin
        lcount := 0 ;
        continue ;
      end ;

      if lcount = 0 then begin
        res.AddPart ;
        res.AddPoint3D(out_pts[i]);
        inc( lcount ) ;
      end ;
      res.AddPoint3D(out_pts[i +1]);
      inc( lcount ) ;
    end ;
  end ;

  procedure cut_vector ;
  var
    deltax, deltay, xin,xout,  yin,yout : Double ;
    tinx,tiny,  toutx,touty,  tin1, tin2,  tout1 : Double ;
  begin

    deltax := p2.X - p1.X ;
    if deltax = 0 then begin
      // bump off of the vertical
      if p1.X > _extent.XMin then deltax := -NEARZERO
                             else deltax :=  NEARZERO ;
    end ;

    deltay := p2.Y-p1.Y ;
    if deltay = 0 then begin
      // bump off of the horizontal
      if p1.Y > _extent.YMin then deltay := -NEARZERO
                             else deltay :=  NEARZERO ;
    end ;

    if deltax > 0 then begin
      // points to right
      xin  := _extent.XMin ;
      xout := _extent.XMax ;
    end
    else begin
      xin  := _extent.XMax ;
      xout := _extent.XMin ;
    end ;

    if deltay > 0 then begin
      // points up
      yin  := _extent.YMin ;
      yout := _extent.YMax ;
    end
    else begin
      yin  := _extent.YMax ;
      yout := _extent.YMin ;
    end ;

    if Abs(deltax) < NEARZERO then begin
      if Sign( deltax ) = -1 then
        deltax := -NEARZERO
      else
        deltax :=  NEARZERO ;
    end ;

    if Abs(deltay) < NEARZERO then begin
      if Sign( deltay ) = -1 then
        deltay := -NEARZERO
      else
        deltay :=  NEARZERO ;
    end ;

    tinx := ( xin - p1.X ) / deltax ;
    tiny := ( yin - p1.Y ) / deltay ;

    if tinx < tiny then begin
      // hits x first
      tin1 := tinx ;
      tin2 := tiny ;
    end
    else begin
      // hits y first
      tin1 := tiny ;
      tin2 := tinx ;
    end ;

    if 1 >= tin1 then begin
      if 0 < tin1 then begin
        out_pts[idx] := GisPoint3D( xin, yin, p1.Z, p1.M ) ;
        inc( idx ) ;
      end ;
      if 1 >= tin2 then begin
        toutx := ( xout - p1.X ) / deltax ;
        touty := ( yout - p1.Y ) / deltay ;

        if toutx < touty then tout1 := toutx
                         else tout1 := touty ;

        if ( 0 < tin2 ) or ( 0 < tout1 ) then begin
          if tin2 <= tout1 then begin
            if 0 < tin2 then begin
              if tinx > tiny then begin
                out_pts[idx] := GisPoint3D( xin, p1.Y+tinx*deltay, p1.Z, p1.M ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint3D( p1.X + tiny*deltax, yin, p1.Z, p1.M ) ;
                inc( idx ) ;
              end ;
            end ;
            if 1 > tout1 then begin
              if toutx < touty then begin
                out_pts[idx] := GisPoint3D( xout, p1.Y+toutx*deltay, p1.Z, p1.M) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint3D( p1.X + touty*deltax, yout, p1.Z, p1.M) ;
                inc( idx ) ;
              end ;
            end
            else begin
              out_pts[idx] := _TGIS_Point3D( p2 ) ;
              inc( idx ) ;
            end ;
          end
          else begin
            if tinx > tiny then begin
              out_pts[idx] := GisPoint3D( xin, yout, p1.Z, p1.M ) ;
              inc( idx ) ;
            end
            else begin
              out_pts[idx] := GisPoint3D( xout, yin, p1.Z, p1.M ) ;
              inc( idx ) ;
            end ;
          end ;
        end ;
      end ;
    end ;
  end ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeArc.Create(nil, nil, False, Uid, Layer, Dimension ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      Result.AddPart ;
      part_size := GetPartSize( part_no ) ;
      for point_no := 0 to part_size -1 do  begin
        Result.AddPoint3D( GetPoint3D( part_no, point_no ) ) ;
      end ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  res := TGIS_ShapeArc.Create(nil, nil, False, Uid, Layer, Dimension ) ;

  copyInternalFields( self, res ) ;
  copyInternalParams( self, res ) ;

  if _lockInternal2 then res.Lock( TGIS_Lock.Internal2 )
                    else res.Lock( TGIS_Lock.Internal  ) ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    part_size := GetPartSize( part_no ) ;
    if part_size > 0 then begin
      SetLength( out_pts, 2*part_size +2 ) ;
      idx := 0 ;

      p1 := GetPoint3D( part_no, 0 ) ;
      if ( p1.X > 1e30 ) or ( p1.Y > 1e30 ) then
        continue ;

      p2 := GetPoint3D( part_no, 0 ) ;
      if ( p2.X > 1e30 ) or ( p2.Y > 1e30 ) then
        continue ;

      cut_vector ;

      for point_no := 1 to part_size -1 do  begin
        // translate all points in the part to screen coordinates
        p2 := GetPoint3D( part_no, point_no ) ;
        if ( p2.X > 1e30 ) or ( p2.Y > 1e30 ) then
          continue ;

        cut_vector ;

        p1 := _TGIS_Point3D( p2 ) ;
      end ;
      if idx > 0 then
        prepare_result ;
    end ;
  end ;

  Result := res ;

  if not Result.IsEmpty then begin
    Result.Unlock ;
  end
  else
    FreeObject( Result ) ;
end ;


procedure TGIS_ShapeArc.AddPoint(
  const _ptg : TGIS_Point
) ;
var
  ptg       : TGIS_Point  ;
  num_parts : Integer     ;
  currmode  : TGIS_Lock  ;
begin
  if FShape3D then begin
    AddPoint3D( GisPoint3DFrom2D( _ptg ) ) ;
  end
  else begin
    unmapGeometry ;
    FIsFixed := False ;
    try
      ptg := _TGIS_Point(_ptg) ;
      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Unproject_Ref( ptg ) ;

      num_parts := GetNumParts-1 ;

      // add two point line to an empty part
      if GetPartSize( num_parts ) = 0 then begin
        setPoint( num_parts, -1, ptg ) ;
        setPoint( num_parts, -1, ptg ) ;
        exit ;
      end ;

      // if 2 point arc then test if two point are equal
      if GetPartSize( num_parts ) = 2 then begin
        currmode := lockMode ;
        lockMode := TGIS_Lock.Projection ;
        if GisIsSamePoint( GetPoint( num_parts, 0 ),
                           GetPoint( num_parts, 1 )
                         )
        then begin
          // last point is the same as the first point so remove it
          {$IFDEF MANAGED}
            FParts.Dec( OFFSET_NUM_POINTS ) ;
          {$ELSE}
            dec( PInteger(NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
          {$ENDIF}
        end ;
        lockMode := currmode ;
      end ;

      // add our point to arc
      setPoint( num_parts, -1, ptg ) ;
    finally
      layerModified( True ) ;
    end ;
  end ;
end ;

procedure TGIS_ShapeArc.AddPoint3D(
  const _ptg : TGIS_Point3D
) ;
var
  ptg       : TGIS_Point3D  ;
  num_parts : Integer     ;
  currmode  : TGIS_Lock  ;
begin
  if FShape3D then begin
    unmapGeometry ;
    FIsFixed := False ;
    try
      ptg := _TGIS_Point3D(_ptg) ;
      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Unproject3D_Ref( ptg ) ;

      num_parts := GetNumParts-1 ;

      // add two point line to an empty part
      if GetPartSize( num_parts ) = 0 then begin
        setPoint3D( num_parts, -1, ptg ) ;
        setPoint3D( num_parts, -1, ptg ) ;
        exit ;
      end ;

      // if 2 point arc then test if two point are equal
      if GetPartSize( num_parts ) = 2 then begin
        currmode := lockMode ;
        lockMode := TGIS_Lock.Projection ;
        if GisIsSamePoint3D( GetPoint3D( num_parts, 0 ),
                             GetPoint3D( num_parts, 1 )
                           )
        then begin
          // last point is the same as the first point so remove it
          {$IFDEF MANAGED}
            FParts.Dec( OFFSET_NUM_POINTS ) ;
          {$ELSE}
            dec(PInteger(NativeInt(FParts) + OFFSET_NUM_POINTS)^) ;
          {$ENDIF}
        end ;
        lockMode := currmode ;
      end ;

      // add our point to arc
      setPoint3D( num_parts, -1, ptg ) ;
    finally
      layerModified( True ) ;
    end ;
  end
  else begin
    AddPoint( GisPoint2DFrom3D( _ptg ) ) ;
  end ;
end ;

function  TGIS_ShapeArc.Distance2Part(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  point_no     : Integer ;
  next_pt      : Integer ;
  points_count : Integer ;
  dist         : Double ;
  tmp          : Double ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  dist := GIS_MAX_DOUBLE ; // really far away :)
  _proj := _TGIS_Point(_ptg) ;

  // divide polygon to a series of lines; then find a minimum distance
  // between each line and the a given point; found minimum will be a distance
  // between line and polygon

  points_count := GetPartSize( _part ) ;

  if points_count = 1 then begin
    // only for broken shapes - normally
    // such case is impossible
    dist := GisPoint2Point( GetPoint(_part,0), _ptg ) ;
    _proj := GetPoint(_part,0) ;
  end
  else
    for point_no := 0 to points_count - 2 do begin // all points
      next_pt := point_no +1;
      line_a  := GetPoint(_part,point_no) ;  // beginning of line
      line_b  := GetPoint(_part,next_pt);    // end of line
      tmp     := GisLine2Point(line_a, line_b, _ptg ) ;
      if tmp < dist then begin
        dist := tmp ;
        _proj := GisPointOnLine( line_a, line_b, _ptg ) ;
      end ;
    end ;
  Result := dist ;
end ;

function TGIS_ShapeArc.Distance2PartCS(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  ptg  : TGIS_Point ;
  dst  : Double ;
  tmp  : Double ;
  tmp1 : Double ;
  tmp2 : Double ;
  ipo  : Integer ;
  p1   : TGIS_Point ;
  p2   : TGIS_Point ;
  pt   : TGIS_Point ;
  opt  : TGIS_Point ;
  opt1 : TGIS_Point ;
  opt2 : TGIS_Point ;
  mid  : Boolean ;
  i    : Integer ;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  ptg := pointToWGS( _ptg ) ;
  ipo := 0 ;
  dst := GIS_MAX_DOUBLE ;

  if indexDist2PartCS < 0 then begin
    for i := 0 to GetPartSize( _part ) - 1 do begin
      tmp := haversineFormula( ptg, pointToWGS( GetPoint( _part, i ) ) ) ;
      if tmp < dst then begin
        dst := tmp ;
        ipo := i ;
      end ;
    end ;
  end
  else
    ipo := indexDist2PartCS ;

  pt := pointToWGS( GetPoint( _part, ipo ) ) ;

  if GetPartSize( _part ) = 1 then begin
    _proj := GetPoint( _part, ipo ) ;
    Result := distanceWGS( ptg, pt ) ;
    exit ;
  end ;

  if GetPartSize( _part ) = 2 then begin
    if ipo = 0 then begin
      p1 := _TGIS_Point(pt) ;
      p2 := pointToWGS( GetPoint( _part, 1 ) ) ;
    end
    else begin
      p1 := pointToWGS( GetPoint( _part, 0 ) ) ;
      p2 := _TGIS_Point(pt) ;
    end ;

    if ( p1.X = p2.X ) and ( p1.Y = p2.Y ) then begin
      _proj := GetPoint( _part, ipo ) ;
      Result := distanceWGS( ptg, pt ) ;
      exit ;
    end ;

    dst := distance2SegmentWGS( ptg, p1, p2, False, opt ) ;
    _proj := pointFromWGS( opt ) ;
    Result := dst ;

    exit ;
  end ;

  mid := False ;
  if ipo = 0 then begin
    p1 := pt ;
    p2 := pointToWGS( GetPoint( _part, 1 ) ) ;
  end
  else
  if ipo = GetPartSize( _part ) - 1 then begin
    p1 := pointToWGS( GetPoint( _part, GetPartSize( _part ) - 2 ) ) ;
    p2 := pt ;
  end
  else
    mid := True ;

  if mid then begin
    p1 := pointToWGS( GetPoint( _part, ipo - 1 ) ) ;
    p2 := pointToWGS( GetPoint( _part, ipo + 1 ) ) ;

    tmp1 := distance2SegmentWGS( ptg, pt, p2, False, opt1 ) ;
    tmp2 := distance2SegmentWGS( ptg, p1, pt, False, opt2 ) ;
    if tmp1 < tmp2 then begin
      dst := tmp1 ;
      opt := opt1 ;
    end
    else begin
      dst := tmp2 ;
      opt := opt2 ;
    end ;
  end ;

  if not mid then
    dst := distance2SegmentWGS( ptg, p1, p2, False, opt ) ;

  _proj := pointFromWGS( opt ) ;
  Result := dst ;
end ;

function  TGIS_ShapeArc.Centroid
  : TGIS_Point ;
var
  old_lock : TGIS_Lock  ;
begin
  old_lock := lockMode ;
  try
    lockMode := TGIS_Lock.Internal ;

    Result := GetPointOnLine( Length / 2, 0 ) ;

    if assigned( Layer ) and GisLockLessThan( old_lock, TGIS_Lock.Projection ) then
      Layer.Project_Ref( Result ) ;
  finally
    lockMode := old_lock ;
  end;
end ;

function TGIS_ShapeArc.Area
  : Double ;
begin
  Result := 0 ; // line area = 0 ;
end ;

function TGIS_ShapeArc.AreaCS
  : Double ;
var
  lcs : TGIS_CSCoordinateSystem ;
begin
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          Result := 0
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          Result := 0 ;
end ;

function TGIS_ShapeArc.Length
  : Double ;
var
  part_no      : Integer ;
  point_no     : Integer ;
  points_count : Integer ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
begin

  // sum of all lines in all parts
  Result := 0;

  for part_no := 0 to GetNumParts -1 do begin
    points_count := GetPartSize( part_no ); // only for most external part
    pta := GetPoint( part_no, 0 ) ;

    for point_no := 1 to points_count - 1 do begin  // all points
      ptb := pta ;
      pta := GetPoint( part_no, point_no ) ;
      Result := Result + GisPoint2Point( ptb, pta ) ;
    end ;

  end ;

end ;

function TGIS_ShapeArc.LengthCS
  : Double ;
var
  btransform   : Boolean    ;
  old_mode     : TGIS_Lock  ;
  part_no      : Integer    ;
  point_no     : Integer    ;
  points_count : Integer    ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
  ellps        : TGIS_CSEllipsoid ;
  lcs          : TGIS_CSCoordinateSystem ;
  gcs          : TGIS_CSGeographicCoordinateSystem ;
begin
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  btransform := assigned( Layer.Transform ) and Layer.Transform.Active ;

  if btransform and assigned( Viewer ) then
    lcs := Viewer.Ref.CS
  else
    lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          gcs   := TGIS_CSProjectedCoordinateSystem( lcs ).Geocs
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          gcs := TGIS_CSGeographicCoordinateSystem( lcs )
  else    exit ;

  Result := 0 ;

  ellps := gcs.Datum.Ellipsoid ;

  old_mode := lockMode ;
  if not btransform then
    lockMode := TGIS_Lock.Projection ;
  try

    for part_no := 0 to GetNumParts -1 do begin

      points_count := GetPartSize( part_no ); // only for most external part
      pta := lcs.ToCS( gcs, GetPoint( part_no, 0 ) ) ;
      pta.X := DegToRad( pta.X ) ;
      pta.Y := DegToRad( pta.Y ) ;

      for point_no := 1 to points_count - 1 do begin  // all points
        ptb := pta ;
        pta := lcs.ToCS( gcs, GetPoint( part_no, point_no ) ) ;
        pta.X := DegToRad( pta.X ) ;
        pta.Y := DegToRad( pta.Y ) ;

        if (pta.X > 1e30) or (pta.Y > 1e30) then
          continue ;
        if (ptb.X > 1e30) or (ptb.Y > 1e30) then
          continue ;

        Result := Result + ellps.Distance( ptb, pta ) ;
      end ;

    end ;

  finally
    lockMode := old_mode ;
  end ;

end ;

function TGIS_ShapeArc.PartLength(
  const _part : Integer
) : Double ;
var
  point_no     : Integer ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
begin

  Result := 0;
  if (_part >= GetNumParts) or (_part < 0) then
    exit ;

  pta := GetPoint(_part, 0) ;
  for point_no := 1 to GetPartSize( _part ) - 1 do begin  // all points
    ptb := pta ;
    pta := GetPoint(_part, point_no);
    Result := Result + GisPoint2Point( ptb, pta ) ;
  end ;

end ;

function TGIS_ShapeArc.PartLengthCS(
  const _part : Integer
) : Double ;
var
  btransform   : Boolean    ;
  old_mode     : TGIS_Lock  ;
  point_no     : Integer    ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
  ellps        : TGIS_CSEllipsoid ;
  lcs          : TGIS_CSCoordinateSystem ;
begin
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  btransform := assigned( Layer.Transform ) and Layer.Transform.Active ;

  if btransform and assigned( Viewer ) then
    lcs := Viewer.Ref.CS
  else
    lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          ellps := TGIS_CSProjectedCoordinateSystem(
                     lcs
                   ).Geocs.Datum.Ellipsoid
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          ellps := TGIS_CSGeographicCoordinateSystem(
                     lcs
                   ).Datum.Ellipsoid
  else    exit ;

  if (_part >= GetNumParts) or (_part < 0) then
    exit ;

  Result := 0 ;

  old_mode := lockMode ;
  if not btransform then
    lockMode := TGIS_Lock.Projection ;
  try

    pta := lcs.ToWGS( GetPoint(_part, 0) ) ;
    for point_no := 1 to GetPartSize( _part ) - 1 do begin  // all points
      ptb := pta ;
      pta := lcs.ToWGS( GetPoint(_part, point_no) );

      if (pta.X > 1e30) or (pta.Y > 1e30) then
        continue ;
      if (ptb.X > 1e30) or (ptb.Y > 1e30) then
        continue ;

      Result := Result + ellps.Distance( ptb, pta ) ;
    end ;

  finally
    lockMode := old_mode ;
  end ;

end ;

function TGIS_ShapeArc.IsInsideCircle(
  const _center : TGIS_Point ;
  const _range : Double ;
  const _itype : TGIS_InsideType
) : Boolean;
var
  part_no      : Integer ;
  point_no     : Integer ;
  points_count : Integer ;
  line_pt      : TGIS_Point ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
begin

  if IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  if Extent.XMin > _center.X +_range then
    Result := False
  else
  if Extent.XMax < _center.X -_range then
    Result := False
  else
  if Extent.YMin > _center.Y +_range then
    Result := False
  else
  if Extent.YMax < _center.Y -_range then
    Result := False
  else begin
    Result := True ;

    case _itype of
      TGIS_InsideType.Full :
           begin
             for part_no := 0 to GetNumParts - 1 do begin // all parts
               points_count := GetPartSize( part_no );
               for point_no := 0 to points_count - 1 do begin // all points
                 line_pt := GetPoint(part_no, point_no) ;
                 if GisPoint2Point( _center, line_pt ) > _range then begin
                   Result := False ;
                   break ;
                 end ;
               end ;
               if not Result then
                break ;
             end ;
           end ;
      TGIS_InsideType.Centroid :
           begin
             if GisPoint2Point( _center, Centroid ) > _range then
               Result := False ;
           end ;
      TGIS_InsideType.Partial :
           begin
             Result := False ;
             for part_no := 0 to GetNumParts - 1 do begin // all parts
               points_count := GetPartSize( part_no );
               for point_no := 0 to points_count - 1 do begin // all points
                 line_pt := GetPoint(part_no, point_no) ;
                 if GisPoint2Point( _center, line_pt ) <= _range then begin
                   Result := True ;
                   break ;
                 end ;
               end ;
               if Result then
                 break ;
             end ;
             if not Result then begin
               for part_no := 0 to GetNumParts - 1 do begin // all parts
                 points_count := GetPartSize( part_no );
                 line_a := GetPoint(part_no, 0) ;
                 for point_no := 1 to points_count - 1 do begin // all points
                   line_b := GetPoint(part_no, point_no) ;
                   if GisLine2Point(line_a, line_b, _center) <= _range then
                   begin
                     Result := True ;
                     break ;
                   end ;
                   line_a := _TGIS_Point(line_b) ;
                 end ;
                 if Result then
                   break ;
               end ;
             end ;
           end ;
      else begin
             assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
             Result := False ;
           end ;
    end ;
  end ;

end ;

function TGIS_ShapeArc.IsInsidePolygon(
  const _shape : TGIS_ShapePolygon ;
  const _itype : TGIS_InsideType
) : Boolean ;
var
  tpl : TGIS_Topology ;
  cns : TGIS_ShapePoint ;
begin
  if ( not assigned( _shape ) ) or IsEmpty or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    case _itype of
      TGIS_InsideType.Full :
        Result := tpl.Relate(self, _shape, '**F') ;
      TGIS_InsideType.Partial :
        Result := tpl.Relate(self, _shape, 'T') ;
      TGIS_InsideType.Centroid :
        begin
          cns := TGIS_ShapePoint.Create(nil, nil, false, -1, _shape.Layer) ;
          cns.AddPart ;
          cns.AddPoint(Centroid);
          Result := tpl.Relate(cns, _shape, '**F') ;
          FreeObject(cns) ;
        end ;
      else
        Result := False ;
    end ;
  finally
    FreeObject( tpl ) ;
  end ;

end ;

function TGIS_ShapeArc.IsCommonPoint(
  const _shape : TGIS_Shape
) : Boolean ;
var
  part_idx,
  point_idx,
  in_pt_idx,
  point_no  : Integer ;
  in_pt_no  : Integer ;
  line_a,
  line_b    : TGIS_Point;
  in_line_a : TGIS_Point;
  line1,
  line2     : TGIS_Line ;
  r, s      : Double;
  m         : Double;
begin
  if ( not assigned( _shape ) ) or IsEmpty or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  Result := False ;

  case _shape.ShapeType of
    TGIS_ShapeType.Polygon :
         begin
           if self.IsInsidePolygon( TGIS_ShapePolygon(_shape),
                                    TGIS_InsideType.Partial
                                  )
           then
             Result := True ;
         end ;

    TGIS_ShapeType.Arc :
         begin
           in_pt_no := _shape.GetPartSize( 0 );

           for part_idx := 0 to GetNumParts - 1 do begin
             point_no := GetPartSize( part_idx );

             for point_idx := 0 to point_no -2 do begin
               line1.A := GetPoint(part_idx, point_idx) ;
               line1.B := GetPoint(part_idx, point_idx +1) ;

               for in_pt_idx := 0 to in_pt_no -2 do begin
                 line2.A := _shape.GetPoint(0,in_pt_idx) ;
                 line2.B := _shape.GetPoint(0,in_pt_idx +1);

                 if GisIsLinesCommonPoint(line1, line2) then begin
                   Result := True ;
                   exit ;
                 end ;
               end ;
             end ;
           end ;
         end ;
    TGIS_ShapeType.Point,
    TGIS_ShapeType.MultiPoint :
         begin
           in_pt_no := _shape.GetPartSize( 0 );

           for part_idx := 0 to GetNumParts - 1 do begin
             point_no := GetPartSize( part_idx );

             for point_idx := 0 to point_no -2 do begin
               line_a := GetPoint(part_idx, point_idx) ;
               line_b := GetPoint(part_idx, point_idx +1) ;

               for in_pt_idx := 0 to in_pt_no -1 do begin
                 in_line_a := _shape.GetPoint(0,in_pt_idx) ;
                 r := (line_a.Y-in_line_a.Y)*(line_a.Y-line_b.Y) -
                      (line_a.X-in_line_a.X)*(line_b.X-line_a.X);
                 s := (line_a.Y-in_line_a.Y)*(line_b.X-line_a.X) -
                      (line_a.X-in_line_a.X)*(line_b.Y-line_a.Y);
                 m := Sqr( line_b.X-line_a.X ) + Sqr( line_b.Y-line_a.Y ) ;
                 r := r/m;
                 s := s/m;
                 if ((r>=0) and (r<=1)) or (s=0) then begin
                   Result := True ;
                   exit ;
                 end ;
               end ;
             end ;
           end ;
         end ;
    else begin
           assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
           Result := False ;
         end ;
  end ;

end ;

function TGIS_ShapeArc.GetDistanceOnLine(
  const _ptg      : TGIS_Point ;
  var   _side     : Integer    ;
  var   _location : Integer    ;
  var   _distance : Double
) : Double ;
begin
  Result := GetDistanceOnLine( _ptg, _side, _location, _distance, -1 ) ;
end ;

function TGIS_ShapeArc.GetDistanceOnLine(
  const _ptg      : TGIS_Point ;
  var   _side     : Integer    ;
  var   _location : Integer    ;
  var   _distance : Double     ;
  const _part     : Integer
) : Double ;
var
  point_no     : Integer    ;
  part_no      : Integer    ;
  part_start   : Integer    ;
  part_end     : Integer    ;
  next_pt      : Integer    ;
  points_count : Integer    ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
  t_distance   : Double     ;
  m_distance   : Double     ;
  t_location   : Integer    ;
  m_location   : Integer    ;
  t_side       : Integer    ;
  m_side       : Integer    ;
  d_length     : Double     ;
  t_length     : Double     ;
  m_length     : Double     ;
  m_seg        : Integer    ;

  function get_distance( const _ptg1  : TGIS_Point ;
                         const _ptg2  : TGIS_Point ;
                         const _ptgR  : TGIS_Point ;
                         var   _vside : Integer    ;
                         var   _vloc  : Integer    ;
                         var   _dlen  : Double
                       ) : Double ;
  var
    s,
    r, m, m2  : Double ;
  begin
    // is line length = 0 ?
    if (( _ptg1.X = _ptg2.X ) and ( _ptg1.Y = _ptg2.Y ) ) then begin
      Result := Sqrt( Sqr( _ptg1.X - _ptgR.X ) +
                      Sqr( _ptg1.Y - _ptgR.Y)
                    ) ;
      if Result = 0 then begin
        _vloc  := 0 ;
        _vside := 0 ;
      end
      else begin
        _vloc  := 2 ;
        _vside := 2 ;
      end ;
      _dlen  := 0 ;
    end
    else begin
      m2 := Sqr(_ptg2.X -_ptg1.X) + Sqr(_ptg2.Y -_ptg1.Y) ;
      r := ( (_ptg1.Y - _ptgR.Y) * (_ptg1.Y - _ptg2.Y) -
             (_ptg1.X - _ptgR.X) * (_ptg2.X - _ptg1.X) ) / m2;

      if      r < 0 then begin
                      // before start of the line
                      // Result := GisPoint2Point( _ptg1, _ptgR ) ;
                      Result := Sqrt( Sqr( _ptg1.X - _ptgR.X ) +
                                      Sqr( _ptg1.Y - _ptgR.Y)
                                    ) ;

                      _vloc := -1 ;
                      _dlen := 0  ;
                    end
      else if r > 1 then begin
                      // beyond and of the line
                      // Result := GisPoint2Point( _ptg2, _ptgR ) ;
                      Result := Sqrt( Sqr( _ptg2.X - _ptgR.X ) +
                                      Sqr( _ptg2.Y - _ptgR.Y)
                                    ) ;

                      _vloc := 1 ;

                      // _dlen :=  GisPoint2Point( _ptg1, _ptg2 ) ;
                      _dlen := Sqrt( Sqr( _ptg1.X - _ptg2.X ) +
                                     Sqr( _ptg1.Y - _ptg2.Y)
                                   ) ;
                    end
      else          begin
                      // within line
                      s := ( ( _ptg1.Y - _ptgR.Y ) * ( _ptg2.X - _ptg1.X ) -
                             ( _ptg1.X - _ptgR.X ) * ( _ptg2.Y - _ptg1.Y )
                           ) / m2;
                      m := Sqrt( m2 ) ;
                      Result := Abs( s*m ) ;

                      _vloc := 0 ;

                      // _dlen := r * GisPoint2Point( _ptg1, _ptg2 ) ;
                      _dlen := r * Sqrt( Sqr( _ptg2.X - _ptg1.X ) +
                                         Sqr( _ptg2.Y - _ptg1.Y)
                                       ) ;
                    end ;
      // compute side
      _vside := CompareValue(
                  ( ( _ptg2.Y - _ptg1.Y ) * _ptgR.X +
                    ( _ptg1.X - _ptg2.X ) * _ptgR.Y +
                    ( ( _ptg2.X * _ptg1.Y ) - ( _ptg1.X * _ptg2.Y ) )
                  ),
                  0
                ) ;
    end ;

  end ;

begin
  assert( _part <= GetNumParts ) ;

  if _part >= 0 then begin
    part_start := _part ;
    part_end   := _part ;
  end
  else begin
    part_start := 0 ;
    part_end   := Max( GetNumParts - 1, -1 ) ;
  end ;

  d_length   := 0              ;
  m_distance := GIS_MAX_DOUBLE ; // really far away :)
  m_location := 2 ;
  m_side     := 2 ;
  m_length   := 0 ;
  m_seg      := 2 ;

  for part_no  := part_start to part_end do begin
    // divide polygon to a series of lines; then find a minimum distance
    // between each line and the a given point; found minimum will be a
    // distance between line and polygon
    points_count := GetPartSize( part_no );

    for point_no := 0 to points_count - 2 do begin // all points
      next_pt := point_no +1;
      line_a  := GetPoint(part_no,point_no) ;  // beginning of line
      line_b  := GetPoint(part_no,next_pt);    // end of line
      t_distance := get_distance( line_a, line_b, _ptg,
                                  t_side, t_location, t_length
                                ) ;
      if t_distance < m_distance then begin
        m_distance := t_distance ;
        m_location := t_location ;
        m_side     := t_side     ;
        m_length   := d_length + t_length ;

        if      point_no = 0 then                 m_seg := -1
        else if point_no =  points_count - 2 then m_seg :=  1
        else                                      m_seg :=  0 ;
      end ;
      d_length := d_length + GisPoint2Point( line_a, line_b ) ;
    end ;

  end ;

  Result := m_length ;

  _side     := m_side     ;
  _distance := m_distance ;

  case m_seg of
    -1 :  _location := m_location ; // before beginning of the line
     0 :  _location := 0          ; // within the line
     1 :  _location := m_location ; // before end of the line
     else _location := 2          ; // undefined
  end;

end ;

function TGIS_ShapeArc.GetPointOnLine(
  const _distance : Double ;
  const _offset   : Double
) : TGIS_Point ;
begin
  Result := GetPointOnLine( _distance, _offset, -1 ) ;
end;

function TGIS_ShapeArc.GetPointOnLine(
  const _distance : Double ;
  const _offset   : Double ;
  const _part     : Integer
) : TGIS_Point ;
begin
  Result := GetPointOnLine( _distance, _offset, _part, True ) ;
end;

function  TGIS_ShapeArc.GetPointOnLine(
  const _distance  : Double ;
  const _offset    : Double ;
  const _part      : Integer ;
  const _canExceed : Boolean
) : TGIS_Point ;
var
  distance     : Double ;
  bfound       : Boolean ;
  part_no      : Integer ;
  part_start   : Integer ;
  part_end     : Integer ;
  point_no     : Integer ;
  next_pt      : Integer ;
  points_count : Integer ;
  length_curr  : Double  ;
  length_tmp   : Double  ;
  pointA       : TGIS_Point ;
  pointB       : TGIS_Point ;

  function move_by_offset(
    const _result : TGIS_Point ;
    const _offset : Double ;
    const _pointA : TGIS_Point ;
    const _pointB : TGIS_Point
  ) : TGIS_Point ;
  var
    angle     : Double     ;
    pt_tmp    : TGIS_Point ;
    sa,ca     : Double ;
  begin
    {$IFDEF GIS_NORECORDS}
      pt_tmp := new TGIS_Point ;
    {$ENDIF}
    Result := _result ;
    if _pointA.Y = _pointB.Y then begin
      pt_tmp.X := 0 ;
      pt_tmp.Y := _offset ;
    end
    else begin
      angle := Pi/2 -
               ArcTan( Abs( _pointA.X - _pointB.X ) /
                       Abs( _pointA.Y - _pointB.Y )
                     ) ;
      SinCos( angle, sa, ca ) ;
      pt_tmp.X := sa * _offset ;
      pt_tmp.Y := ca * _offset ;
    end ;

    if _pointB.X < _pointA.X then
      Result.Y := _result.Y + pt_tmp.Y
    else
      Result.Y := _result.Y - pt_tmp.Y ;

    if _pointB.Y < _pointA.Y then
      Result.X := _result.X - pt_tmp.X
    else
      Result.X := _result.X + pt_tmp.X ;
  end ;

begin
  {$IFDEF GIS_NORECORDS}
    Result := new TGIS_Point ;
  {$ENDIF}
  assert( _part <= GetNumParts ) ;

  if _canExceed then
    distance := _distance
  else begin
    if _part >= 0 then
      distance := Max( 0, Min( _distance, PartLength( _part ) ) )
    else
      distance := Max( 0, Min( _distance, Length ) ) ;
  end ;

  // find a line in which a middle is placed
  length_curr := 0;
  length_tmp  := 0;

  if _part >= 0 then begin
    part_start := _part ;
    part_end   := _part ;
  end
  else begin
    part_start := 0 ;
    part_end   := Max( GetNumParts - 1, -1 ) ;
  end ;

  bfound := False ;
  for part_no := part_start to part_end do begin  // all parts

    points_count := GetPartSize( part_no );
    for point_no := 0 to points_count - 2 do begin // all points
      next_pt := point_no + 1 ;
      pointA := GetPoint( part_no, point_no ) ;
      pointB := GetPoint( part_no, next_pt ) ;
      length_tmp := GisPoint2Point( pointB, pointA );

      if (length_tmp + length_curr) >= distance then begin
        bfound := True ;
        break ;
      end
      else
        length_curr := length_curr + length_tmp ;
    end ;

    if length_curr > distance then
      bfound := True ;

    if bfound then
      break ;
  end ;

  if length_tmp = 0 then begin
    Result.X := pointA.X ; // same as starting point
    Result.Y := pointA.Y ;
  end
  else if (distance > 0 ) and ( not bfound ) then begin
    // calculate the point after last point
    Result.X := pointB.X +
                ( pointB.X - pointA.X ) /
                length_tmp * ( distance - length_curr ) ;
    Result.Y := pointB.Y +
                ( pointB.Y - pointA.Y ) /
                length_tmp * ( distance -length_curr ) ;
  end
  else if distance < 0 then begin
    // calculate the point before first point
    Result.X := pointA.X +
                ( pointB.X - pointA.X ) /
                length_tmp * ( distance - length_curr ) ;
    Result.Y := pointA.Y +
                ( pointB.Y - pointA.Y ) /
                length_tmp * ( distance - length_curr ) ;
  end
  else begin
    // calculate the middle point of the last iterated line
    Result.X := pointA.X +
                ( pointB.X - pointA.X ) /
                length_tmp * ( distance - length_curr ) ;
    Result.Y := pointA.Y +
                ( pointB.Y - pointA.Y ) /
                length_tmp * ( distance - length_curr ) ;
  end ;

  if not GisIsSameValue( _offset, 0 ) then
    Result := move_by_offset( Result, _offset, pointA, pointB ) ;
end ;

function TGIS_ShapeArc.GetSegment
  : TGIS_ShapeArc ;
begin
  Result := GetSegment( 0, GIS_MAX_DOUBLE, -1 ) ;
end ;

function TGIS_ShapeArc.GetSegment(
  const _from : Double ;
  const _to   : Double
) : TGIS_ShapeArc ;
begin
  Result := GetSegment( _from, _to, -1 ) ;
end ;

function TGIS_ShapeArc.GetSegment(
  const _from : Double ;
  const _to   : Double ;
  const _part : Integer
) : TGIS_ShapeArc ;
var
  point_no     : Integer ;
  part_no      : Integer ;
  part_start   : Integer ;
  part_end     : Integer ;
  length_curr  : Double ;
  length_tmp   : Double ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
  pt : TGIS_Point ;
  new_part     : Boolean ;
  state        : Integer ;
const
  _SEARCH_FROM = 1 ;
  _SEARCH_TO   = 2 ;
  _SEARCH_DONE = 3 ;

  function get_interim_point( _len : Double ) : TGIS_Point ;
  begin
    if length_tmp = 0 then begin
      Result.X := line_a.X ; // same as starting point
      Result.Y := line_a.Y ;
    end
    else begin
      // calculate the middle point of the last iterated line
      Result.X := line_a.X +
                  ( line_b.X -line_a.X ) / length_tmp*( _len - length_curr ) ;
      Result.Y := line_a.Y +
                  ( line_b.Y -line_a.Y ) / length_tmp*( _len - length_curr ) ;
    end ;
  end ;

begin
  assert( _part <= GetNumParts ) ;

  if _to < _from then begin
    Result := nil ;
    exit ;
  end
  else
    Result := TGIS_ShapeArc.Create( nil, nil, False, -1, nil ) ;

  length_curr := 0    ;
  length_tmp  := 0    ;

  if _part >= GetNumParts then exit ;

  if _part >= 0 then begin
    part_start := _part ;
    part_end   := _part ;
  end
  else begin
    part_start := 0 ;
    part_end   := Max( GetNumParts - 1, -1 ) ;
  end ;

  state := _SEARCH_FROM ;

  Result.Lock( TGIS_Lock.Extent );
  try
    for part_no := part_start to part_end do begin  // all parts
      if GetPartSize( part_no ) < 1 then continue ;

      new_part := True ;

      line_a := GetPoint( part_no, 0 ) ;

      // continue segment from last part
      if state = _SEARCH_TO then begin
        Result.AddPart ;
        Result.AddPoint( line_a ) ;
        new_part := False ;
      end ;

      for point_no := 1 to GetPartSize( part_no ) - 1 do  begin // all points
        line_b := GetPoint( part_no, point_no ) ;
        length_tmp := GisPoint2Point( line_a, line_b ) ;

        if ( state = _SEARCH_FROM ) and
           ( length_curr + length_tmp >= _from ) then
        begin
          state := _SEARCH_TO ;
          pt := get_interim_point( _from ) ;
          if new_part then
            Result.AddPart ;
          Result.AddPoint( pt ) ;
        end ;

        if ( state = _SEARCH_TO ) and
           ( length_curr + length_tmp >= _to ) then
        begin
          state := _SEARCH_DONE ;
          pt := get_interim_point( _to ) ;
          length_tmp := GisPoint2Point( line_a, pt ) ;
          Result.AddPoint( pt ) ;
          break ;
        end ;

        if ( state = _SEARCH_TO ) then
          Result.AddPoint( line_b ) ;

        line_a := line_b ;
        length_curr := length_curr + length_tmp ;
      end ;

      if state = _SEARCH_DONE then break ;
    end ;
  finally
    Result.Unlock ;
    if Result.IsEmpty then begin
      FreeObject( Result ) ;
      Result := nil ;
    end;
  end ;

end ;

function TGIS_ShapeArc.ExportToGML
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportArcToGML( self );
end ;

function TGIS_ShapeArc.ExportToJSON
  : String;
begin
  Result := TGIS_GeometryFactory.GisExportArcToJSON( self );
end;

function TGIS_ShapeArc.ExportToEWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportArcToEWKT( self ) ;
end ;

procedure TGIS_ShapeArc.ExportToEWKB(
  var _ewkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportArcToEWKB( self, _ewkb ) ;
end ;

function TGIS_ShapeArc.ExportToWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportArcToWKT( self ) ;
end ;

procedure TGIS_ShapeArc.ExportToWKB(
  var _wkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportArcToWKB( self, _wkb ) ;
end ;

procedure TGIS_ShapeArc.ExportToGDO(
  var _gdo : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportArcToGDO( self, _gdo );
end ;

procedure TGIS_ShapeArc.ExportToVAR(
  var _var : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportArcToVAR( self, _var );
end ;

{$ENDREGION 'TGIS_ShapeArc'}

{$REGION 'TGIS_ShapePolygon'}

constructor TGIS_ShapePolygon.Create ;
begin
  Create( nil, nil, False, -1, nil, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapePolygon.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Create( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapePolygon.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Create( _source, _ptr, _mapped, _uid, _layer, _dim ) ;
  FShapeType := TGIS_ShapeType.Polygon ;
end ;

constructor TGIS_ShapePolygon.Create(
  const _dim    : TGIS_DimensionType
) ;
begin
  Create( nil, nil, False, -1, nil, _dim ) ;
end ;

function TGIS_ShapePolygon.fget_SmartSize
  : Integer ;
begin
  Result := Params.Area.SmartSize ;
end ;

function TGIS_ShapePolygon.getIntersectInternal(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
const
  NEARZERO = 1e-30 ;
var
  p1, p2      : TGIS_Point  ;
  point_no    : Integer     ;
  part_no     : Integer     ;
  part_size   : Integer     ;
  tot_s2area  : Double      ;
  part_s2area : Double      ;
  out_pts     : array of TGIS_Point ;
  idx         : Integer ;
  res         : TGIS_Shape ;
  fp          : TGIS_Point ;

  procedure prepare_result ;
  var
    i  : Integer ;
    pt_origin : TGIS_Point ;
  begin
    part_s2area := 0 ;

    res.AddPart ;
    p1 := _TGIS_Point( out_pts[0] ) ;
    pt_origin := _TGIS_Point( p1 ) ;
    TGIS_ShapePolygon(res).AddPoint(p1);
    p1.X := p1.X - pt_origin.X ; // normalize to avoid big number
    p1.Y := p1.Y - pt_origin.Y ;

    for i := 1 to idx -1 do begin
      p2 := _TGIS_Point( out_pts[i] ) ;
      TGIS_ShapePolygon(res).AddPoint(p2);
      p2.X := p2.X - pt_origin.X ; // normalize to avoid big number
      p2.Y := p2.Y - pt_origin.Y ;
      part_s2area := part_s2area + (p2.Y*p1.X - p1.Y*p2.X) ;
      p1 := _TGIS_Point( p2 ) ;
    end ;

    if ( not GisIsSamePoint(out_pts[idx -1], pt_origin)) or (idx = 1) then
      TGIS_ShapePolygon(res).AddPoint(pt_origin);

    tot_s2area := tot_s2area + part_s2area ;
  end ;

  procedure cut_vector ;
  var
    deltax,deltay,
    xin,xout,
    yin,yout,
    tinx,tiny,
    toutx,touty,
    tin1, tin2, tout1 : Double ;
  begin

    deltax := p2.X - p1.X ;
    if deltax = 0 then begin
      // bump off of the vertical
      if p1.X > _extent.XMin then deltax := -NEARZERO
                             else deltax :=  NEARZERO ;
    end ;

    deltay := p2.Y-p1.Y ;
    if deltay = 0 then begin
      // bump off of the horizontal
      if p1.Y > _extent.YMin then deltay := -NEARZERO
                             else deltay :=  NEARZERO ;
    end ;

    if deltax > 0 then begin
      // points to right
      xin  := _extent.XMin ;
      xout := _extent.XMax ;
    end
    else begin
      xin  := _extent.XMax ;
      xout := _extent.XMin ;
    end ;

    if deltay > 0 then begin
      // points up
      yin  := _extent.YMin ;
      yout := _extent.YMax ;
    end
    else begin
      yin  := _extent.YMax ;
      yout := _extent.YMin ;
    end ;

    if Abs(deltax) < NEARZERO then begin
      if Sign( deltax ) = -1 then
        deltax := -NEARZERO
      else
        deltax :=  NEARZERO ;
    end ;

    if Abs(deltay) < NEARZERO then begin
      if Sign( deltay ) = -1 then
        deltay := -NEARZERO
      else
        deltay :=  NEARZERO ;
    end ;

    tinx := ( xin - p1.X ) / deltax ;
    tiny := ( yin - p1.Y ) / deltay ;

    if tinx < tiny then begin
      // hits x first
      tin1 := tinx ;
      tin2 := tiny ;
    end
    else begin
      // hits y first
      tin1 := tiny ;
      tin2 := tinx ;
    end ;

    if 1 >= tin1 then begin
      if 0 < tin1 then begin
        out_pts[idx] := GisPoint( xin, yin ) ;
        inc( idx ) ;
      end ;
      if 1 >= tin2 then begin
        toutx := ( xout - p1.X ) / deltax ;
        touty := ( yout - p1.Y ) / deltay ;

        if toutx < touty then tout1 := toutx
                         else tout1 := touty ;

        if ( 0 < tin2 ) or ( 0 < tout1 ) then begin
          if tin2 <= tout1 then begin
            if 0 < tin2 then begin
              if tinx > tiny then begin
                out_pts[idx] := GisPoint( xin, p1.Y+tinx*deltay ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint( p1.X + tiny*deltax, yin ) ;
                inc( idx ) ;
              end ;
            end ;
            if 1 > tout1 then begin
              if toutx < touty then begin
                out_pts[idx] := GisPoint( xout, p1.Y+toutx*deltay) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint( p1.X + touty*deltax, yout) ;
                inc( idx ) ;
              end ;
            end
            else begin
              out_pts[idx] := _TGIS_Point( p2 ) ;
              inc( idx ) ;
            end ;
          end
          else begin
            if tinx > tiny then begin
              out_pts[idx] := GisPoint( xin, yout ) ;
              inc( idx ) ;
            end
            else begin
              out_pts[idx] := GisPoint( xout, yin ) ;
              inc( idx ) ;
            end ;
          end ;
        end ;
      end ;
    end ;
  end ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapePolygon.Create(nil, nil, False, Uid, Layer ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      Result.AddPart ;
      part_size := GetPartSize( part_no ) ;
      for point_no := 0 to part_size -2 do  begin
        Result.AddPoint( GetPoint( part_no, point_no ) ) ;
      end ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  res :=  TGIS_ShapePolygon.Create(nil, nil, False, Uid, Layer ) ;

  copyInternalFields( self, res ) ;
  copyInternalParams( self, res ) ;

  if _lockInternal2 then res.Lock( TGIS_Lock.Internal2 )
                    else res.Lock( TGIS_Lock.Internal  ) ;

  tot_s2area := 0 ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    part_size := GetPartSize( part_no ) ;
    if part_size > 0 then begin
      SetLength(out_pts, 2*part_size +2) ;
      idx := 0 ;

      p1 := GetPoint( part_no, 0 ) ;
      if p1.Y > 1e30 then continue ;
      p2 := _TGIS_Point( p1 ) ;
      fp := _TGIS_Point( p1 ) ;

      cut_vector ;
      for point_no := 1 to part_size -1 do  begin
        // translate all points in the part to screen coordinates
        p2 := GetPoint( part_no, point_no ) ;
        if p2.Y > 1e30 then continue ;
        cut_vector ;
        p1 := _TGIS_Point( p2 ) ;
      end ;

      if not GisIsSamePoint(p1, fp) then begin
        p2 := _TGIS_Point( fp ) ;
        cut_vector ;
      end ;

      if idx > 0 then
        prepare_result ;
    end ;
  end ;

  Result := res ;

  if not Result.IsEmpty then begin
    Result.Unlock ;

    if ( Result.Extent.XMax <= _extent.XMin ) or
       ( Result.Extent.XMin >= _extent.XMax ) or
       ( Result.Extent.YMax <= _extent.YMin ) or
       ( Result.Extent.YMin >= _extent.YMax )
    then
      FreeObject( Result ) ;
  end
  else
    FreeObject( Result ) ;
end ;

function TGIS_ShapePolygon.getIntersectInternal3D(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
const
  NEARZERO = 1e-30 ;
var
  p1, p2      : TGIS_Point3D  ;
  point_no    : Integer     ;
  part_no     : Integer     ;
  part_size   : Integer     ;
  tot_s2area  : Double      ;
  part_s2area : Double      ;
  out_pts     : array of TGIS_Point3D ;
  idx         : Integer ;
  res         : TGIS_Shape ;
  fp          : TGIS_Point3D ;

  procedure prepare_result ;
  var
    i  : Integer ;
    pt_origin : TGIS_Point3D ;
  begin
    part_s2area := 0 ;

    res.AddPart ;
    p1 := _TGIS_Point3D( out_pts[0] ) ;
    pt_origin := _TGIS_Point3D( p1 ) ;
    TGIS_ShapePolygon(res).AddPoint3D(p1);
    p1.X := p1.X - pt_origin.X ; // normalize to avoid big number
    p1.Y := p1.Y - pt_origin.Y ;
    p1.Z := p1.Z - pt_origin.Z ;
    p1.M := p1.M - pt_origin.M ;

    for i := 1 to idx -1 do begin
      p2 := _TGIS_Point3D( out_pts[i] ) ;
      TGIS_ShapePolygon(res).AddPoint3D(p2);
      p2.X := p2.X - pt_origin.X ; // normalize to avoid big number
      p2.Y := p2.Y - pt_origin.Y ;
      p2.Z := p2.Z - pt_origin.Z ;
      p2.M := p2.M - pt_origin.M ;
      part_s2area := part_s2area + (p2.Y*p1.X - p1.Y*p2.X) ;
      p1 := _TGIS_Point3D( p2 ) ;
    end ;

    if ( not GisIsSamePoint(GisPoint(out_pts[idx -1].X, out_pts[idx -1].Y),
                            GisPoint(pt_origin.X, pt_origin.Y)))
      or
       (idx = 1)
    then
      TGIS_ShapePolygon(res).AddPoint3D(pt_origin);

    tot_s2area := tot_s2area + part_s2area ;
  end ;

  procedure cut_vector ;
  var
    deltax,deltay,
    xin,xout,
    yin,yout,
    tinx,tiny,
    toutx,touty,
    tin1, tin2, tout1 : Double ;
  begin

    deltax := p2.X - p1.X ;
    if deltax = 0 then begin
      // bump off of the vertical
      if p1.X > _extent.XMin then deltax := -NEARZERO
                             else deltax :=  NEARZERO ;
    end ;

    deltay := p2.Y-p1.Y ;
    if deltay = 0 then begin
      // bump off of the horizontal
      if p1.Y > _extent.YMin then deltay := -NEARZERO
                             else deltay :=  NEARZERO ;
    end ;

    if deltax > 0 then begin
      // points to right
      xin  := _extent.XMin ;
      xout := _extent.XMax ;
    end
    else begin
      xin  := _extent.XMax ;
      xout := _extent.XMin ;
    end ;

    if deltay > 0 then begin
      // points up
      yin  := _extent.YMin ;
      yout := _extent.YMax ;
    end
    else begin
      yin  := _extent.YMax ;
      yout := _extent.YMin ;
    end ;

    if Abs(deltax) < NEARZERO then begin
      if Sign( deltax ) = -1 then
        deltax := -NEARZERO
      else
        deltax :=  NEARZERO ;
    end ;

    if Abs(deltay) < NEARZERO then begin
      if Sign( deltay ) = -1 then
        deltay := -NEARZERO
      else
        deltay :=  NEARZERO ;
    end ;

    tinx := ( xin - p1.X ) / deltax ;
    tiny := ( yin - p1.Y ) / deltay ;

    if tinx < tiny then begin
      // hits x first
      tin1 := tinx ;
      tin2 := tiny ;
    end
    else begin
      // hits y first
      tin1 := tiny ;
      tin2 := tinx ;
    end ;

    if 1 >= tin1 then begin
      if 0 < tin1 then begin
        out_pts[idx] := GisPoint3D( xin, yin, p1.Z, p1.M ) ;
        inc( idx ) ;
      end ;
      if 1 >= tin2 then begin
        toutx := ( xout - p1.X ) / deltax ;
        touty := ( yout - p1.Y ) / deltay ;

        if toutx < touty then tout1 := toutx
                         else tout1 := touty ;

        if ( 0 < tin2 ) or ( 0 < tout1 ) then begin
          if tin2 <= tout1 then begin
            if 0 < tin2 then begin
              if tinx > tiny then begin
                out_pts[idx] := GisPoint3D( xin, p1.Y+tinx*deltay, p1.Z, p1.M ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint3D( p1.X + tiny*deltax, yin, p1.Z, p1.M  ) ;
                inc( idx ) ;
              end ;
            end ;
            if 1 > tout1 then begin
              if toutx < touty then begin
                out_pts[idx] := GisPoint3D( xout, p1.Y+toutx*deltay, p1.Z, p1.M ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint3D( p1.X + touty*deltax, yout, p1.Z, p1.M ) ;
                inc( idx ) ;
              end ;
            end
            else begin
              out_pts[idx] := _TGIS_Point3D( p2 ) ;
              inc( idx ) ;
            end ;
          end
          else begin
            if tinx > tiny then begin
              out_pts[idx] := GisPoint3D( xin, yout, p1.Z, p1.M ) ;
              inc( idx ) ;
            end
            else begin
              out_pts[idx] := GisPoint3D( xout, yin, p1.Z, p1.M  ) ;
              inc( idx ) ;
            end ;
          end ;
        end ;
      end ;
    end ;
  end ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapePolygon.Create(nil, nil, False, Uid, Layer, Dimension ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      Result.AddPart ;
      part_size := GetPartSize( part_no ) ;
      for point_no := 0 to part_size -2 do  begin
        Result.AddPoint3D( GetPoint3D( part_no, point_no ) ) ;
      end ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  res :=  TGIS_ShapePolygon.Create(nil, nil, False, Uid, Layer, Dimension ) ;

  copyInternalFields( self, res ) ;
  copyInternalParams( self, res ) ;

  if _lockInternal2 then res.Lock( TGIS_Lock.Internal2 )
                    else res.Lock( TGIS_Lock.Internal  ) ;

  tot_s2area := 0 ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    part_size := GetPartSize( part_no ) ;
    if part_size > 0 then begin
      SetLength(out_pts, 2*part_size +2) ;
      idx := 0 ;

      p1 := GetPoint3D( part_no, 0 ) ;
      if p1.Y > 1e30 then continue ;
      p2 := _TGIS_Point3D( p1 ) ;
      fp := _TGIS_Point3D( p1 ) ;

      cut_vector ;
      for point_no := 1 to part_size -1 do  begin
        // translate all points in the part to screen coordinates
        p2 := GetPoint3D( part_no, point_no ) ;
        if p2.Y > 1e30 then continue ;
        cut_vector ;
        p1 := _TGIS_Point3D( p2 ) ;
      end ;

      if not GisIsSamePoint(GisPoint(p1.X, p1.Y), GisPoint(fp.X, fp.Y)) then
      begin
        p2 := _TGIS_Point3D( fp ) ;
        cut_vector ;
      end ;

      if idx > 0 then
        prepare_result ;
    end ;
  end ;

  Result := res ;

  if not Result.IsEmpty then begin
    Result.Unlock ;

    if ( Result.Extent.XMax <= _extent.XMin ) or
       ( Result.Extent.XMin >= _extent.XMax ) or
       ( Result.Extent.YMax <= _extent.YMin ) or
       ( Result.Extent.YMin >= _extent.YMax ) or
       ( Result.Area        =  0            )
    then
      FreeObject( Result ) ;
  end
  else
    FreeObject( Result ) ;
end ;


procedure TGIS_ShapePolygon.AddPoint(
  const _ptg : TGIS_Point
) ;
var
  ptg       : TGIS_Point ;
  ptg_tmp   : TGIS_Point ;
  num_parts : Integer    ;
  currmode  : TGIS_Lock  ;
begin
  if FShape3D then begin
    AddPoint3D( GisPoint3DFrom2D( _ptg ) )
  end
  else begin
    unmapGeometry ;
    FIsFixed := False ;
    try
      ptg := _TGIS_Point(_ptg) ;
      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Unproject_Ref( ptg ) ;

      num_parts := GetNumParts -1 ;

      // add two points to the empty part
      if GetPartSize(num_parts) = 0 then begin
        setPoint( num_parts, -1, ptg ) ;
        if lockMode = TGIS_Lock.None then begin
          setPoint( num_parts, -1, ptg ) ;
        end ;
        exit ;
      end ;

      // store first point in the polygon
      currmode := lockMode ;
      lockMode := TGIS_Lock.Projection ;
      ptg_tmp  := GetPoint( num_parts, 0 ) ;
      lockMode := currmode ;

      if ( lockMode = TGIS_Lock.None ) or ( not lockModified ) then begin
        // last point is the same as the first point, so remove it
        {$IFDEF MANAGED}
          FParts.Dec( OFFSET_NUM_POINTS ) ;
        {$ELSE}
          dec( PInteger(NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
        {$ENDIF}
      end ;

      // add our point to polygon
      setPoint( num_parts, -1, ptg ) ;

      if lockMode = TGIS_Lock.None then begin
        // if not the same as the first point in polygon, then add the first point
        // to the tail.
        if not GisIsSamePoint( ptg_tmp, ptg ) then
          setPoint( num_parts, -1, ptg_tmp ) ;
      end ;

    finally
      layerModified( True ) ;
    end ;
  end ;
end ;

procedure TGIS_ShapePolygon.AddPoint3D(
  const _ptg : TGIS_Point3D
) ;
var
  ptg,
  ptg_tmp   : TGIS_Point3D  ;
  num_parts : Integer     ;
  currmode  : TGIS_Lock ;
begin
  if FShape3D then begin
    unmapGeometry ;
    FIsFixed := False ;
    try
      ptg := _TGIS_Point3D(_ptg) ;
      if GisLockLessThan( lockMode, TGIS_Lock.Projection ) and assigned( Layer ) then
        Layer.Unproject3D_Ref( ptg ) ;

      num_parts := GetNumParts -1 ;

      // add two points to the empty part
      if GetPartSize(num_parts) = 0 then begin
        setPoint3D( num_parts, -1, ptg ) ;
        if lockMode = TGIS_Lock.None then begin
          setPoint3D( num_parts, -1, ptg ) ;
        end ;
        exit ;
      end ;

      // store first point in the polygon
      currmode := lockMode ;
      lockMode := TGIS_Lock.Projection ;
      ptg_tmp  := GetPoint3D( num_parts, 0 ) ;
      lockMode := currmode ;

      if ( lockMode = TGIS_Lock.None ) or ( not lockModified ) then begin
        // last point is the same as the first point, so remove it
        {$IFDEF MANAGED}
          FParts.Dec( OFFSET_NUM_POINTS ) ;
        {$ELSE}
          dec( PInteger(NativeInt(FParts) + OFFSET_NUM_POINTS)^ ) ;
        {$ENDIF}
      end ;

      // add our point to polygon
      setPoint3D( num_parts, -1, ptg ) ;

      if lockMode = TGIS_Lock.None then begin
        // if not the same as the first point in polygon, then add the first
        // point to the tail.
        if not GisIsSamePoint3D( ptg_tmp, ptg ) then
          setPoint3D( num_parts, -1, ptg_tmp ) ;
      end ;

    finally
      layerModified( True ) ;
    end ;
  end
  else begin
    AddPoint( GisPoint2DFrom3D( _ptg ) )
  end ;
end ;

function TGIS_ShapePolygon.Distance2Part(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  point_no     : Integer ;
  next_pt      : Integer ;
  points_count : Integer ;
  tmp          : Double  ;
  dist         : Double  ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
  inside       : Boolean;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  dist := GIS_MAX_DOUBLE ; // really far away :)
  _proj := _TGIS_Point(_ptg) ;

  inside := False ;

  if _prec >= 0 then begin // otherwise being inside is not important
    if GisIsPointInsidePolygon( _ptg, self, _part ) then begin
      dist := Abs(_prec) ;
      inside := True ;
    end ;
  end ;

  // divide polygon to a series of lines; then find a minimum distance
  // between each line and given point; found minimum will be a distance
  // between line and polygon

  points_count := GetPartSize( _part ) ;

  if points_count = 1 then begin
    // only for broken shapes - normally
    // such case is impossible
    dist := GisPoint2Point( GetPoint(_part,0), _ptg ) ;
    _proj := GetPoint(_part,0) ;
  end
  else
    for point_no := 0 to points_count - 2 do begin // all points
      next_pt := point_no +1;

      line_a := GetPoint(_part,point_no) ; // beginning of line
      if (line_a.X > 1e30) or (line_a.Y > 1e30) then
        continue ;

      line_b := GetPoint(_part,next_pt)  ; // end of line
      if (line_b.X > 1e30) or (line_b.Y > 1e30) then
        continue ;

      tmp := GisLine2Point(line_a, line_b, _ptg ) ;
      if tmp < dist then begin
        dist  := tmp ;
        _proj := GisPointOnLine(line_a, line_b, _ptg ) ;
      end ;
    end ;
  if inside then
    dist := dist *0.95 ; // to be inside is always a bit better then outside
  Result := dist ;
end ;

function TGIS_ShapePolygon.Distance2PartCS(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
var
  ptg  : TGIS_Point ;
  dst  : Double ;
  tmp  : Double ;
  tmp1 : Double ;
  tmp2 : Double ;
  ipo  : Integer ;
  p1   : TGIS_Point ;
  p2   : TGIS_Point ;
  pt   : TGIS_Point ;
  opt  : TGIS_Point ;
  opt1 : TGIS_Point ;
  opt2 : TGIS_Point ;
  i    : Integer ;
begin
  assert( _part >= 0           ) ;
  assert( _part <= GetNumParts ) ;

  ptg := pointToWGS( _ptg ) ;
  ipo := 0 ;
  dst := GIS_MAX_DOUBLE ;

  if indexDist2PartCS < 0 then begin
    for i := 0 to GetPartSize( _part ) - 1 do begin
      tmp := haversineFormula( ptg, pointToWGS( GetPoint( _part, i ) ) ) ;
      if tmp < dst then begin
        dst := tmp ;
        ipo := i ;
      end ;
    end ;
  end
  else
    ipo := indexDist2PartCS ;

  pt := pointToWGS( GetPoint( _part, ipo ) ) ;

  if GetPartSize( _part ) = 1 then begin
    _proj := GetPoint( _part, ipo ) ;
    Result := distanceWGS( ptg, pt ) ;
    exit ;
  end ;

  if GetPartSize( _part ) = 2 then begin
    if ipo = 0 then begin
      p1 := _TGIS_Point(pt) ;
      p2 := pointToWGS( GetPoint( _part, 1 ) ) ;
    end
    else begin
      p1 := pointToWGS( GetPoint( _part, 0 ) ) ;
      p2 := _TGIS_Point(pt) ;
    end ;

    if ( p1.X = p2.X ) and ( p1.Y = p2.Y ) then begin
      _proj := GetPoint( _part, ipo ) ;
      Result := distanceWGS( ptg, pt ) ;
      exit ;
    end ;

    dst := distance2SegmentWGS( ptg, p1, p2, False, opt ) ;
    _proj := pointFromWGS( opt ) ;
    Result := dst ;

    exit ;
  end ;

  if ipo = 0 then
    p1 := pointToWGS( GetPoint( _part, GetPartSize( _part ) - 2 ) )
  else
    p1 := pointToWGS( GetPoint( _part, ipo - 1 ) ) ;
  p2 := pointToWGS( GetPoint( _part, ipo + 1 ) ) ;

  tmp1 := distance2SegmentWGS( ptg, pt, p2, False, opt1 ) ;
  tmp2 := distance2SegmentWGS( ptg, p1, pt, False, opt2 ) ;
  if tmp1 < tmp2 then begin
    dst := tmp1 ;
    opt := _TGIS_Point(opt1) ;
  end
  else begin
    dst := tmp2 ;
    opt := _TGIS_Point(opt2) ;
  end ;

  _proj := pointFromWGS( opt ) ;
  Result := dst ;
end ;

function TGIS_ShapePolygon.Centroid
  : TGIS_Point;
var
  part_no      : Integer ;
  point_no     : Integer ;
  first_pt     : Integer ;
  next_pt      : Integer ;
  points_count : Integer ;
  darea        : Double  ;
  point        : TGIS_Point ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
  origin       : TGIS_Point ;
begin
  if self.IsEmpty  then begin
    Result := GisPoint( 0, 0 ) ;
    exit ;
  end;

  darea   := 0 ;
  {$IFDEF GIS_NORECORDS}
    point := new TGIS_Point ;
  {$ENDIF}
  point.X := 0;
  point.Y := 0;

  {$IFDEF GIS_NORECORDS}
    line_a := new TGIS_Point ;
  {$ENDIF}
  line_a.X := 0 ;
  line_a.Y := 0 ;

  // to avoid big numbers - make it relative to some point in the geometry
  origin := GetFirstPoint ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    points_count := GetPartSize( part_no );
    first_pt := points_count -1;
    next_pt := 0;
    for point_no := 0 to points_count -1 do  begin // all points
      line_a   := GetPoint(part_no,first_pt) ;

      line_a.X := line_a.X - origin.X;
      line_a.Y := line_a.Y - origin.Y;
      line_b   := GetPoint(part_no,next_pt);
      line_b.X := line_b.X - origin.X;
      line_b.Y := line_b.Y - origin.Y;
      first_pt := point_no;
      next_pt  := point_no +1;
      darea    := darea + (line_b.Y*line_a.X - line_a.Y*line_b.X) / 2 ;
      point.X  := point.X +
                 ( line_a.X + line_b.X ) *
                 ( line_b.Y*line_a.X - line_a.Y*line_b.X) / 6 ;
      point.Y := point.Y +
                 ( line_a.Y + line_b.Y ) *
                 ( line_b.Y*line_a.X - line_a.Y*line_b.X ) / 6 ;
    end ;
  end ;

  if darea <> 0 then begin
    {$IFDEF GIS_NORECORDS}
      Result := new TGIS_Point ;
    {$ENDIF}
    Result.X := (point.X/darea) + origin.X;
    Result.Y := (point.Y/darea) + origin.Y;
  end
  else begin
    Result := GisPoint( ( Extent.XMin + Extent.XMax ) / 2,
                        ( Extent.YMin + Extent.YMax ) / 2
                      ) ;
    if assigned( Layer ) and GisLockLessThan( lockMode, TGIS_Lock.Projection ) then begin
      Layer.Project_Ref( Result ) ;
    end
  end ;
end ;

function TGIS_ShapePolygon.PointOnShape
  : TGIS_Point ;
var
  pt         : TGIS_Point ;
  ipl, pl    : TGIS_ShapePolygon ;
  vp, hp     : Double  ;
  lastvp     : Double  ;
  lasthp     : Double  ;
  l, r, t, b : Double  ;
  onleft     : Boolean ;
  ontop      : Boolean ;
  thesamevp  : Boolean ;
  thesamehp  : Boolean ;
  newext     : TGIS_Extent {$IFDEF JAVA} = new TGIS_Extent {$ENDIF} ;
  ext        : TGIS_Extent {$IFDEF JAVA} = new TGIS_Extent {$ENDIF} ;
  dolock     : Boolean ;
  firsttime  : Boolean ;
begin
  pl  := nil ;

  dolock := lockMode = TGIS_Lock.None ;

  if dolock then
    Lock( TGIS_Lock.Internal ) ;
  try
    pt := Centroid ;

    Result := pt ;
    if GisIsPointInsidePolygon(pt, self) then begin
      exit ;
    end ;

    pl        := self ;
    lastvp    := 0 ;
    lasthp    := 0 ;
    firsttime := True ;

    repeat
      ext := pl.Extent ;

      l := Abs( pt.X     - ext.XMin ) ;
      r := Abs( ext.XMax - pt.X     ) ;
      t := Abs( pt.Y     - ext.YMin ) ;
      b := Abs( ext.YMax - pt.Y     ) ;

      if      l = 0 then begin
                           hp := 0 ;
                           onleft := True ;
                         end
      else if r = 0 then begin
                           hp := GIS_MAX_DOUBLE ;
                           onleft := False ;
                        end
      else if l > r then begin
                           hp := l/r ;
                           onleft := false ;
                         end
      else               begin
                           hp := r/l ;
                           onleft := true ;
                         end ;

      if lasthp = hp then
        thesamehp := true
      else begin
        thesamehp := false ;
        lasthp := hp ;
      end ;

      if      t = 0 then begin
                           vp := 0 ;
                           ontop := True ;
                         end
      else if b = 0 then begin
                           vp := GIS_MAX_DOUBLE ;
                           ontop:= False ;
                         end
      else if t > b then begin
                           vp := t/b ;
                           ontop := false ;
                         end
      else               begin
                           vp := b/t ;
                           ontop := true ;
                         end ;

      if lastvp = vp then
        thesamevp := true
      else begin
        thesamevp := false ;
        lastvp := vp ;
      end ;

      if (hp > vp) and ((not thesamehp) or thesamevp) then begin
        newext.YMin := ext.YMin ;
        newext.YMax := ext.YMax ;
        if onleft then begin
          newext.XMin := ext.XMin ;
          newext.XMax := pt.X ;
        end
        else begin
          newext.XMin := pt.X ;
          newext.XMax := ext.XMax ;
        end ;
      end
      else begin
        newext.XMin := ext.XMin ;
        newext.XMax := ext.XMax ;
        if ontop then begin
          newext.YMin := ext.YMin ;
          newext.YMax := pt.Y ;
        end
        else begin
          newext.YMin := pt.Y ;
          newext.YMax := ext.YMax ;
        end ;
      end ;

      ipl := TGIS_ShapePolygon( pl.getIntersectInternal( newext, True ) ) ;

      if ipl = nil then begin
        if GisIsPointInsidePolygon(pt, self) then
          Result := pt
        else
          Result := self.GetFirstPoint ;
        exit ;
      end ;

      if not firsttime then
        FreeObject( pl )
      else
        firsttime := False ;

      pl := ipl ;
      pt := ipl.Centroid ;

    until( GisIsPointInsidePolygon( pt, ipl ) ) ;
    Result := pt ;

  finally
    if pl <> self then
      FreeObject( pl ) ;
    if dolock then begin
      Unlock() ;

      if assigned( Layer ) then
        Result := Layer.Project( Result ) ;
    end;
  end;
end ;

function TGIS_ShapePolygon.Area
  : Double ;
var
  part_no      : Integer ;
  point_no     : Integer ;
  next_pt      : Integer ;
  points_count : Integer ;
  darea        : Double  ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
  origin       : TGIS_Point ;
  first        : Boolean ;
begin
  // result is absolute value of some of the area of all trapezoids
  // makes by each polygon line
  darea := 0 ;

  first := True ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    points_count := GetPartSize( part_no );
    for point_no := 0 to points_count - 2 do begin // all points
      next_pt := point_no +1;
      line_a := GetPoint(part_no,point_no) ;
      if (line_a.X > 1e30) or (line_a.Y > 1e30) then
        continue ;

      // to avoid big numbers - make it relative to some point in the geometry
      if first then begin
        origin := _TGIS_Point( line_a ) ;
        first  := False ;
      end;

      line_a.X := line_a.X - origin.X;
      line_a.Y := line_a.Y - origin.Y;

      line_b := GetPoint(part_no,next_pt);
      if (line_b.X > 1e30) or (line_b.Y > 1e30) then
        continue ;

      line_b.X := line_b.X - origin.X;
      line_b.Y := line_b.Y - origin.Y;
      darea := darea + (line_b.Y*line_a.X -line_a.Y*line_b.X) / 2 ;
    end ;
  end ;

  Result := Abs( darea ) ;
end ;

function TGIS_ShapePolygon.AreaCS
  : Double ;
var
  old_mode     : TGIS_Lock  ;
  part_no      : Integer    ;
  point_no     : Integer    ;
  next_pt      : Integer    ;
  points_count : Integer    ;
  darea        : Double     ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
  origin       : TGIS_Point ;
  first        : Boolean ;
  gcs          : TGIS_CSGeographicCoordinateSystem ;
  lcs          : TGIS_CSCoordinateSystem ;
  acs          : TGIS_CSCoordinateSystem ;
begin
  // result is absolute value of some of the area of all trapezoids
  // makes by each polygon line
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          gcs := TGIS_CSProjectedCoordinateSystem( lcs ).Geocs
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          gcs := TGIS_CSGeographicCoordinateSystem( lcs )
  else    exit ;

  acs := CSProjectedCoordinateSystemList.Prepare(
           -1,
           'Cylindrical_Equal_Area_on_' + gcs.WKT,
           gcs.EPSG,
           9001    , // Meters
           CSPROJ_Cylindrical_Equal_Area,
           CSProjectedCoordinateSystemList.DefaultParams(
             CSPROJ_Cylindrical_Equal_Area
           )
         ) ;

  darea := 0 ;
  old_mode := lockMode ;
  lockMode := TGIS_Lock.Projection ;
  try
    first := True ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      points_count := GetPartSize( part_no );
      for point_no := 0 to points_count - 2 do begin // all points
        next_pt := point_no +1;

        line_a := acs.FromCS( lcs, GetPoint(part_no,point_no) ) ;
        if (line_a.X > 1e30) or (line_a.Y > 1e30) then
          continue ;

        // to avoid big numbers - make it relative to
        // some point in the geometry
        if first then begin
          origin := _TGIS_Point( line_a ) ;
          first  := False  ;
        end;

        line_a.X := line_a.X - origin.X;
        line_a.Y := line_a.Y - origin.Y;

        line_b := acs.FromCS( lcs, GetPoint(part_no,next_pt) );
        if (line_b.X > 1e30) or (line_b.Y > 1e30) then
          continue ;

        line_b.X := line_b.X - origin.X;
        line_b.Y := line_b.Y - origin.Y;
        darea := darea + (line_b.Y*line_a.X -line_a.Y*line_b.X) / 2 ;
      end ;
    end ;

    Result := Abs( darea ) ;

  finally
    lockMode := old_mode ;
  end ;
end ;

function TGIS_ShapePolygon.Length
  : Double ;
var
  part_no      : Integer ;
  point_no     : Integer ;
  points_count : Integer ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
begin

  // sum of all lines in all parts
  Result := 0;

  for part_no := 0 to GetNumParts -1 do begin
    points_count := GetPartSize( part_no ); // only for most external part
    pta := GetPoint( part_no, 0 ) ;

    for point_no := 1 to points_count - 1 do begin  // all points
      ptb := pta ;
      pta := GetPoint( part_no, point_no ) ;
      if (pta.X > 1e30) or (pta.Y > 1e30) then
        continue ;
      if (ptb.X > 1e30) or (ptb.Y > 1e30) then
        continue ;

      Result := Result + GisPoint2Point( ptb, pta ) ;
    end ;

  end ;

end ;

function TGIS_ShapePolygon.LengthCS
  : Double ;
var
  btransform   : Boolean    ;
  old_mode     : TGIS_Lock  ;
  part_no      : Integer    ;
  point_no     : Integer    ;
  points_count : Integer    ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
  ellps        : TGIS_CSEllipsoid ;
  lcs          : TGIS_CSCoordinateSystem ;
begin
  Result := -1 ;

  if not assigned( Layer ) then
    exit ;

  btransform := assigned( Layer.Transform ) and Layer.Transform.Active ;

  if btransform and assigned( Viewer ) then
    lcs := Viewer.Ref.CS
  else
    lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          ellps := TGIS_CSProjectedCoordinateSystem(
                     lcs
                   ).Geocs.Datum.Ellipsoid
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          ellps := TGIS_CSGeographicCoordinateSystem(
                     lcs
                   ).Datum.Ellipsoid
  else    exit ;

  Result := 0 ;

  old_mode := lockMode ;
  if not btransform then
    lockMode := TGIS_Lock.Projection ;
  try

    for part_no := 0 to GetNumParts -1 do begin

      points_count := GetPartSize( part_no ); // only for most external part
      pta := lcs.ToWGS( GetPoint( part_no, 0) ) ;

      for point_no := 1 to points_count - 1 do begin  // all points
        ptb := pta ;
        pta := lcs.ToWGS( GetPoint( part_no, point_no ) ) ;

        if (pta.X > 1e30) or (pta.Y > 1e30) then
          continue ;
        if (ptb.X > 1e30) or (ptb.Y > 1e30) then
          continue ;

        Result := Result + ellps.Distance( ptb, pta ) ;
      end ;

    end ;

  finally
    lockMode := old_mode ;
  end ;

end ;

function TGIS_ShapePolygon.PartLength(
  const _part : Integer
) : Double ;
var
  point_no     : Integer    ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
begin

  Result := 0;

  if (_part >= GetNumParts) or (_part < 0) then
    exit ;

  pta := GetPoint(_part, 0) ;
  for point_no := 1 to GetPartSize( _part ) - 1 do begin  // all points
    ptb := pta ;
    pta := GetPoint( _part, point_no  ) ;
    Result := Result + GisPoint2Point( ptb, pta ) ;
  end ;

end ;

function TGIS_ShapePolygon.PartLengthCS(
  const _part : Integer
) : Double ;
var
  btransform   : Boolean    ;
  old_mode     : TGIS_Lock  ;
  point_no     : Integer    ;
  pta          : TGIS_Point ;
  ptb          : TGIS_Point ;
  ellps        : TGIS_CSEllipsoid ;
  lcs          : TGIS_CSCoordinateSystem ;
begin
  Result := 0 ;

  if not assigned( Layer ) then
    exit ;

  btransform := assigned( Layer.Transform ) and Layer.Transform.Active ;

  if btransform and assigned( Viewer ) then
    lcs := Viewer.Ref.CS
  else
    lcs := Layer.CS ;

  if      lcs is TGIS_CSProjectedCoordinateSystem  then
          ellps := TGIS_CSProjectedCoordinateSystem(
                     lcs
                   ).Geocs.Datum.Ellipsoid
  else if lcs is TGIS_CSGeographicCoordinateSystem then
          ellps := TGIS_CSGeographicCoordinateSystem(
                     lcs
                   ).Datum.Ellipsoid
  else    exit ;

  if (_part >= GetNumParts) or (_part < 0) then
    exit ;

  Result := 0 ;

  old_mode := lockMode ;
  if not btransform then
    lockMode := TGIS_Lock.Projection ;
  try

    pta := lcs.ToWGS( GetPoint(_part, 0) ) ;
    for point_no := 1 to GetPartSize( _part ) - 1 do begin  // all points
      ptb := pta ;
      pta := lcs.ToWGS( GetPoint( _part, point_no  ) ) ;

      if (pta.X > 1e30) or (pta.Y > 1e30) then
        continue ;
      if (ptb.X > 1e30) or (ptb.Y > 1e30) then
        continue ;

      Result := Result + ellps.Distance( ptb, pta ) ;
    end ;

  finally
    lockMode := old_mode ;
  end ;

end ;

function TGIS_ShapePolygon.IsInsideCircle(
  const _center : TGIS_Point ;
  const _range : Double ;
  const _itype : TGIS_InsideType
) : Boolean;
var
  part_no      : Integer ;
  point_no     : Integer ;
  points_count : Integer ;
  line_pt      : TGIS_Point ;
  line_a       : TGIS_Point ;
  line_b       : TGIS_Point ;
begin

  if IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  if Extent.XMin > _center.X +_range then
    Result := False
  else
  if Extent.XMax < _center.X -_range then
    Result := False
  else
  if Extent.YMin > _center.Y +_range then
    Result := False
  else
  if Extent.YMax < _center.Y -_range then
    Result := False
  else begin
    Result := True ;

    case _itype of
      TGIS_InsideType.Full :
           begin
             for part_no := 0 to GetNumParts - 1 do begin // all parts
               points_count := GetPartSize( part_no );
               for point_no := 0 to points_count - 1 do begin // all points
                 line_pt := GetPoint(part_no, point_no) ;
                 if GisPoint2Point( _center, line_pt ) > _range then begin
                   Result := False ;
                   break ;
                 end ;
               end ;
               if not Result then
                 break ;
             end ;
           end ;
      TGIS_InsideType.Centroid :
           begin
             if GisPoint2Point( _center, Centroid ) > _range then
               Result := False ;
           end ;
      TGIS_InsideType.Partial :
           begin
             Result := False ;
             for part_no := 0 to GetNumParts - 1 do begin // all parts
               points_count := GetPartSize( part_no );
               for point_no := 0 to points_count - 1 do begin // all points
                 line_pt := GetPoint(part_no, point_no) ;
                 if GisPoint2Point( _center, line_pt ) <= _range then begin
                   Result := True ;
                   break ;
                 end ;
               end ;
               if Result then
                 break ;
             end ;
             if not Result then begin
               Result := GisIsPointInsidePolygon(_center, self) ;
             end ;
             if not Result then begin
               for part_no := 0 to GetNumParts - 1 do begin // all parts
                 points_count := GetPartSize( part_no );
                 line_a := GetPoint(part_no, 0) ;
                 for point_no := 1 to points_count - 1 do begin // all points
                   line_b := GetPoint(part_no, point_no) ;
                   if GisLine2Point(line_a, line_b, _center) <= _range then
                   begin
                     Result := True ;
                     break ;
                   end ;
                   line_a := line_b ;
                 end ;
                 if Result then
                   break ;
               end ;
             end ;
           end ;
      else begin
             assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
             Result := False ;
           end ;
    end ;
  end ;

end ;

function TGIS_ShapePolygon.IsInsidePolygon(
  const _shape : TGIS_ShapePolygon ;
  const _itype : TGIS_InsideType
) : Boolean ;
var
  tpl : TGIS_Topology ;
  cns : TGIS_ShapePoint ;
begin
  if (not assigned( _shape ) ) or IsEmpty or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  tpl := TGIS_Topology.Create ;
  try
    case _itype of
      TGIS_InsideType.Full :
        Result := tpl.Relate(self, _shape, '**F') ;
      TGIS_InsideType.Partial :
        Result := tpl.Relate(self, _shape, 'T') ;
      TGIS_InsideType.Centroid :
        begin
          cns := TGIS_ShapePoint.Create(nil, nil, false, -1, _shape.Layer) ;
          cns.AddPart ;
          cns.AddPoint(Centroid);
          Result := tpl.Relate(cns, _shape, '**F') ;
          FreeObject(cns) ;
        end ;
      else
        Result := False ;
    end ;
  finally
    FreeObject( tpl ) ;
  end ;

end ;

function TGIS_ShapePolygon.IsCommonPoint(
  const _shape : TGIS_Shape
) : Boolean;
var
  in_pt_idx,
  point_idx,
  point_no  : Integer ;
  in_pt_no  : Integer ;

  line_a    : TGIS_Point ;
  line_b    : TGIS_Point ;
  in_line_a : TGIS_Point ;
  npar      : Integer ;
begin
  if IsEmpty or _shape.IsEmpty then begin
    Result := False ;
    exit ;
  end ;

  Result := False ;

  case _shape.ShapeType of
    TGIS_ShapeType.Polygon,
    TGIS_ShapeType.Arc :
         begin
           if _shape.IsInsidePolygon(self, TGIS_InsideType.Partial) then
             Result := True ;
         end ;
    TGIS_ShapeType.Point,
    TGIS_ShapeType.MultiPoint :
         begin
           npar := 0 ;

           in_pt_no := _shape.GetPartSize( 0 );

           for in_pt_idx := 0 to in_pt_no -1 do begin
             in_line_a := _shape.GetPoint(0, in_pt_idx) ;
             point_no := GetPartSize(0);

             for point_idx := 0 to point_no -2 do begin
               line_a := GetPoint(0, point_idx) ;
               line_b := GetPoint(0, point_idx +1);

               if ( ( ( (line_a.Y    <= in_line_a.Y) and
                        (in_line_a.Y <  line_b.Y   )
                      ) or
                      ( (line_b.Y    <= in_line_a.Y) and
                        (in_line_a.Y < line_a.Y    )
                      )
                    ) and
                    ( in_line_a.X < ( (line_b.X    - line_a.X)*
                                      (in_line_a.Y - line_a.Y) /
                                      (line_b.Y    - line_a.Y)
                                      + line_a.X
                                    )
                    )
                  )
               then
                 npar := npar +1;
             end ;

             if (npar mod 2) = 1 then begin //point inside polygon
               Result := True ;
               exit ;
             end ;

           end ;
         end ;
    else begin
           assert( False, _rsrc( GIS_RS_ERR_UNTESTED ) ) ;
           Result := False ;
         end ;
  end ;

end ;

function TGIS_ShapePolygon.Split(
  const _keep_holes : Boolean
) : TGIS_ShapeList ;
var
  i, k, nparts       : Integer ;
  shp                : TGIS_Shape ;
  topo               : TGIS_Topology ;
  part_status        : Integer ;
  parent_part        : Integer ;
  kparent_part       : Integer ;
  current_parent     : Integer ;
begin
  if not _keep_holes then begin
    Result := Self.Split ;
    exit ;
  end ;

  shp := nil ;
  current_parent := 0 ;
  nparts := GetNumParts ;

  topo := TGIS_Topology.Create ;
  try
    Result := TGIS_ShapeList.Create( True ) ;

    Lock( TGIS_Lock.Projection ) ;
    for i := 0 to nparts -1 do begin

      if GetPartSize( i ) <= 0 then
        continue ;

      part_status := topo.PartStatus( TGIS_ShapePolygon( Self ), i, parent_part ) ;

      // main part (0) or island(1) create new shape
      if ( part_status = 0 ) or ( part_status = 1 ) then begin
        current_parent := i ;
        // add the previously created shape to Result
        if assigned( shp ) then
          Result.Add( shp ) ;

        createShapeFromPart( i, False, shp ) ;
        for k := 0 to nparts -1 do begin
          if k = i then
            continue ;
          part_status := topo.PartStatus( TGIS_ShapePolygon( Self ), k, kparent_part ) ;
          if ( part_status = -1 ) and ( kparent_part = current_parent ) then begin
            // add hole (-1) to newly reated shape
            createShapeFromPart( k, True, shp ) ;
          end ;
        end;

      end ;
      // ensure that the last shape is added to Result
      if ( i = nparts - 1 ) then
        Result.Add( shp ) ;
    end ;
    Unlock ;
  finally
    FreeObject( topo ) ;
  end ;
end ;

function TGIS_ShapePolygon.ExportToGML
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToGML( self );
end ;

function TGIS_ShapePolygon.ExportToJSON
  : String;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToJSON( self );
end;

function TGIS_ShapePolygon.ExportToEWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToEWKT( self ) ;
end ;

procedure TGIS_ShapePolygon.ExportToEWKB(
   var _ewkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPolygonToEWKB( self, _ewkb ) ;
end ;

function TGIS_ShapePolygon.ExportToWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToWKT( self );
end ;

procedure TGIS_ShapePolygon.ExportToWKB(
  var _wkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPolygonToWKB( self, _wkb );
end ;

procedure TGIS_ShapePolygon.ExportToGDO(
  var _gdo : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPolygonToGDO( self, _gdo );
end ;

procedure TGIS_ShapePolygon.ExportToVAR(
  var _var : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPolygonToVAR( self, _var );
end ;

procedure TGIS_ShapePolygon.BuildFromEdges(
  const _edges     : TGIS_ObjectList ;
  const _tolerance : Double
)  ;
var
  shp : TGIS_Shape ;
  i,j : Integer    ;
begin
  shp := TGIS_GeometryFactory.GisBuildShapeFromEdges(
           _edges, TGIS_ShapeType.Polygon, _tolerance, nil, nil, False, -1, Layer, True
         ) ;

  shp.Lock( TGIS_Lock.Projection ) ;
  try
    Reset ;
    if IsSameType( shp, self ) then begin
      for i:= 0 to shp.GetNumParts - 1 do begin
        AddPart ;
        for j:= 0 to shp.GetPartSize( i ) - 1 do begin
          if FShape3D then
            AddPoint3D( shp.GetPoint3D( i, j ) )
          else
            AddPoint  ( shp.GetPoint  ( i, j ) ) ;
        end ;
      end ;
    end ;
  finally
    shp.Unlock ;
    FreeObject( shp ) ;
  end ;
end ;

{$ENDREGION 'TGIS_ShapePolygon'}

{$REGION 'TGIS_ShapeComplex'}

constructor TGIS_ShapeComplex.Create ;
begin
  Create( nil, nil, False, -1, nil, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeComplex.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Create( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeComplex.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Create( _source, _ptr, _mapped, _uid, _layer, _dim ) ;

  FComplexList := TGIS_ShapeList.Create ;
  FShapeType   := TGIS_ShapeType.Complex ;
end ;

constructor TGIS_ShapeComplex.Create(
  const _dim    : TGIS_DimensionType
) ;
begin
  Create( nil, nil, False, -1, nil, _dim ) ;
end ;

procedure TGIS_ShapeComplex.Recreate(
            const _source : TGIS_Shape ;
            {$IFDEF MANAGED}
              const _ptr  : TGIS_Bytes ;
            {$ELSE}
              const _ptr  : Pointer ;
            {$ENDIF}
            const _mapped : Boolean ;
            const _uid    : TGIS_Uid   ;
            const _layer  : TGIS_LayerVector ;
            {$IFNDEF OXYGENE}
              const _dim    : TGIS_DimensionType  = TGIS_DimensionType.Unknown
            {$ELSE}
              const _dim    : TGIS_DimensionType
                {$IFDEF CLR}:= TGIS_DimensionType.Unknown{$ENDIF}
            {$ENDIF}
          ) ;
var
  i : Integer ;
begin
  // fake Recreate
  inherited Recreate( _source, _ptr, _mapped, _uid, _layer, _dim ) ;

  if assigned( FComplexList ) then begin
    FComplexList.Clear ;

    if ( _source <> nil ) then begin
      if ( _source is TGIS_ShapeComplex ) then
        for i := 0 to TGIS_ShapeComplex( _source ).FComplexList.Count - 1 do
          AddShape( TGIS_Shape(
                      TGIS_ShapeComplex( _source ).FComplexList[i]
                    ).CreateCopy
                  )
      else
        AddShape( _source.CreateCopy ) ;
    end;
  end;
end ;

{$IFNDEF MANAGED}

  destructor TGIS_ShapeComplex.Destroy ;
  begin
    FComplexList.Clear ;

    FreeObject( FComplexList );

    inherited ;
  end;
{$ENDIF}

function TGIS_ShapeComplex.CreateCopy
  : TGIS_Shape ;
var
  i : Integer ;
begin
  Result := TGIS_ShapeComplex.Create( self, nil, False, 0, nil, FDimension ) ;

  for i := 0 to FComplexList.Count - 1 do
    TGIS_ShapeComplex( Result ).AddShape(
      TGIS_Shape( FComplexList[ i ] ).CreateCopy
    );
end ;

function TGIS_ShapeComplex.fget_ShapesCount
  : Integer ;
begin
  Result := FComplexList.Count ;
end;

function TGIS_ShapeComplex.fget_SmartSize
  : Integer ;
begin
  Result := 0 ;
end;

function TGIS_ShapeComplex.fget_Extent
  : TGIS_Extent ;
var
  i   : Integer ;
  ext : TGIS_Extent ;
begin
  ext := GisNoWorld ;

  for i := 0 to FComplexList.Count - 1 do begin
    if GisIsNoWorld( TGIS_Shape( FComplexList[i] ).Extent ) then
      continue ;

    ext := GisMaxExtent( ext, TGIS_Shape( FComplexList[ i ] ).Extent ) ;
  end ;

  Result := ext ;
end ;

function TGIS_ShapeComplex.fget_ProjectedExtent
  : TGIS_Extent ;
var
  i   : Integer ;
  ext : TGIS_Extent ;
begin
  ext := GisNoWorld ;

  for i := 0 to FComplexList.Count - 1 do begin
    if GisIsNoWorld( TGIS_Shape( FComplexList[i] ).ProjectedExtent ) then
      continue ;

    ext := GisMaxExtent( ext, TGIS_Shape( FComplexList[ i ] ).ProjectedExtent ) ;
  end ;

  Result := ext ;
end ;

function TGIS_ShapeComplex.checkIsEmpty
  : Boolean ;
begin
  if assigned( FComplexList ) then
    Result := FComplexList.Count = 0
  else
    Result := True ;
end ;

function TGIS_ShapeComplex.getIntersectInternal(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
var
  i   : Integer ;
  shp : TGIS_Shape ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeComplex.Create(nil, nil, False, Uid, Layer ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for i := 0 to ShapesCount - 1 do begin // all shapes
      shp := GetShape(i) ;
      if assigned( shp ) then
        TGIS_ShapeComplex(Result).AddShape( shp ) ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  Result := TGIS_ShapeComplex.Create(nil, nil, False, Uid, Layer ) ;

  copyInternalFields( self, Result ) ;
  copyInternalParams( self, Result ) ;

  if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                    else Result.Lock( TGIS_Lock.Internal  ) ;

  for i := 0 to ShapesCount - 1 do begin // all shapes
    shp := GetShape(i).getIntersectInternal( _extent, _lockInternal2 ) ;
    if assigned( shp ) then
      TGIS_ShapeComplex(Result).AddShape( shp ) ;
  end ;

  Result.Unlock ;
end ;

function TGIS_ShapeComplex.getIntersectInternal3D(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
var
  i   : Integer ;
  shp : TGIS_Shape ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeComplex.Create(nil, nil, False, Uid, Layer ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for i := 0 to ShapesCount - 1 do begin // all shapes
      shp := GetShape(i) ;
      if assigned( shp ) then
        TGIS_ShapeComplex(Result).AddShape( shp ) ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  Result := TGIS_ShapeComplex.Create(nil, nil, False, Uid, Layer ) ;

  copyInternalFields( self, Result ) ;
  copyInternalParams( self, Result ) ;

  if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                    else Result.Lock( TGIS_Lock.Internal  ) ;

  for i := 0 to ShapesCount - 1 do begin // all shapes
    shp := GetShape(i).getIntersectInternal3D( _extent, _lockInternal2 ) ;
    if assigned( shp ) then
      TGIS_ShapeComplex(Result).AddShape( shp ) ;
  end ;

  Result.Unlock ;
end ;

procedure TGIS_ShapeComplex.fset_Layer(
  const _layer : TGIS_LayerVector
) ;
var
  i : Integer ;
begin
  FLayer := _layer ;

  for i := 0 to FComplexList.Count - 1 do
    TGIS_Shape( FComplexList[ i ] ).Layer := _layer ;
end;

procedure TGIS_ShapeComplex.fset_IsSelected(
  const _value : Boolean
) ;
begin
  inherited fset_IsSelected( _value ) ;
end ;

procedure TGIS_ShapeComplex.AddPoint(
  const _ptg : TGIS_Point
) ;
begin
  // safe inheritance
end;

procedure TGIS_ShapeComplex.AddPoint3D(
  const _ptg : TGIS_Point3D
) ;
begin
  // safe inheritance
end ;

function TGIS_ShapeComplex.Distance2Part(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
begin
  // safe inheritance
  Result := -1 ;
end ;

function TGIS_ShapeComplex.Distance2PartCS(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
begin
  // safe inheritance
  Result := -1 ;
end ;

function TGIS_ShapeComplex.Centroid
  : TGIS_Point ;
begin
  Result := GisCenterPoint( ProjectedExtent );
end ;

function TGIS_ShapeComplex.Area
  : Double ;
var
  i : Integer ;
begin
  Result := 0 ;
  for i := 0 to FComplexList.Count - 1 do
    Result := Result + TGIS_Shape( FComplexList[ i ] ).Area ;
end ;

function TGIS_ShapeComplex.AreaCS
  : Double ;
var
  i : Integer ;
begin
  Result := 0 ;
  for i := 0 to FComplexList.Count - 1 do
    Result := Result + TGIS_Shape( FComplexList[ i ] ).AreaCS ;
end ;

function TGIS_ShapeComplex.Length
  : Double ;
var
  i : Integer ;
begin
  Result := 0 ;
  for i := 0 to FComplexList.Count - 1 do
    Result := Result + TGIS_Shape( FComplexList[ i ] ).Length ;
end ;

function TGIS_ShapeComplex.LengthCS
  : Double ;
var
  i : Integer ;
begin
  Result := 0 ;
  for i := 0 to FComplexList.Count - 1 do
    Result := Result + TGIS_Shape( FComplexList[ i ] ).LengthCS ;
end ;

function TGIS_ShapeComplex.ExportToGML
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportComplexToGML( self ) ;
end ;

function TGIS_ShapeComplex.ExportToJSON
  : String;
begin
  Result := TGIS_GeometryFactory.GisExportComplexToJSON( self ) ;
end;

function TGIS_ShapeComplex.ExportToEWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportComplexToEWKT( self ) ;
end ;

procedure TGIS_ShapeComplex.ExportToEWKB(
  var _ewkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportComplexToEWKB( self, _ewkb ) ;
end ;

function TGIS_ShapeComplex.ExportToWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportComplexToWKT( self ) ;
end ;

procedure TGIS_ShapeComplex.ExportToWKB(
  var _wkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportComplexToWKB( self, _wkb ) ;
end ;

procedure TGIS_ShapeComplex.ExportToGDO(
  var _gdo : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportComplexToGDO( self, _gdo ) ;
end ;

procedure TGIS_ShapeComplex.ExportToVAR(
  var _var : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportComplexToVAR( self, _var );
end ;

procedure TGIS_ShapeComplex.Flash(
  const _times : Integer ;
  const _delay : Integer
) ;
var
  i : Integer ;
begin
  for i := 0 to FComplexList.Count - 1 do
    TGIS_Shape( FComplexList[ i ] ).Flash( _times, _delay ) ;
end;

procedure TGIS_ShapeComplex.CopyGeometry(
  const _shape : TGIS_Shape
) ;
var
  i : Integer ;
begin
  if not assigned( _shape ) then exit ;

  if _shape is TGIS_ShapeComplex then
    for i := 0 to TGIS_ShapeComplex(_shape).ShapesCount - 1 do
      AddShape( TGIS_ShapeComplex(_shape).GetShape(i).CreateCopy )
  else
    inherited CopyGeometry( _shape ) ;
end ;

procedure TGIS_ShapeComplex.Unlock ;
begin
  if lockMode = TGIS_Lock.None then begin
    exit ;
  end ;

  if lockMode = TGIS_Lock.Internal2 then begin
    lockModified := False ;
    exit ;
  end ;

  try
    if not lockModified then exit ;
    if IsMapped         then exit ;
    if IsEmpty          then exit ;

    if assigned( Layer ) then begin
      if GisLockLessThan( lockMode, TGIS_Lock.Internal ) then
        Layer.Extent3D := GisMaxExtent3D( Layer.Extent3D, Extent3D ) ;
      UpdateIndex ;
    end ;

  finally
    lockMode     := TGIS_Lock.None ;
    lockModified := False       ;
  end ;
end ;

procedure TGIS_ShapeComplex.AddShape(
  const _shp : TGIS_Shape
) ;
begin
  if not assigned( _shp ) then exit ;

  _shp.ParentShape := self ;
  _shp.Layer       := self.Layer ;

  FComplexList.Add( _shp ) ;
  FIsEmpty := False ;

  layerModified( True ) ;

  if assigned( Layer ) and
     GisLockLessThan( lockMode, TGIS_Lock.Internal ) and not _shp.IsEmpty then
    if not GisIsSameExtent( _shp.Extent, Layer.Extent ) then
      Layer.Extent := GisMaxExtent( _shp.Extent, Layer.Extent ) ;
end ;

procedure TGIS_ShapeComplex.DeleteShape(
  const _index : Integer
) ;
begin
  if _index < FComplexList.Count then
    FComplexList.Delete( _index );

  if FComplexList.Count = 0 then
    FIsEmpty := True ;

  layerModified( True ) ;

  if assigned( Layer ) and
     GisLockLessThan( lockMode, TGIS_Lock.Internal ) then
    if not GisIsSameExtent( Extent, Layer.Extent ) then
      Layer.Extent := GisMaxExtent( Extent, Layer.Extent ) ;
end;

function TGIS_ShapeComplex.GetShape(
  const _index : Integer
) : TGIS_Shape ;
begin
  if _index < FComplexList.Count then
    Result := TGIS_Shape( FComplexList[ _index ] )
  else
    Result := nil ;
end;

function TGIS_ShapeComplex.Locate(
  const _ptg     : TGIS_Point ;
  const _prec    : Double     ;
  const _visible : Boolean    ;
  var   _dist    : Double
) : TGIS_Shape ;
var
  i, j      : Integer    ;
  min_uid   : Integer    ;
  cnt       : Integer    ;
  tmp1      : Double     ;
  tmp2      : Double     ;
  dist,
  dist2     : Double     ;
  proj_ptg  : TGIS_Point ;
  shp       : TGIS_Shape ;
  prec      : Double     ;
  is_visible: Boolean    ;
  ptfix     : Double     ;
begin
  dist    := GIS_MAX_DOUBLE ;
  dist2   := GIS_MAX_DOUBLE ;
  min_uid := -1    ;
  cnt     := 0     ;

  if _visible and assigned( Layer ) then begin
    Layer.prepareParamsCache( '' ) ;

    cnt := Layer.paramsCache.Count ;

    is_visible := False ;

    for i:= cnt -1 downto 0 do begin
      is_visible := is_visible or
                    TGIS_ParamsSectionVector( Layer.paramsCache[i] ).Visible ;
      if is_visible then break ;
    end ;

    if not is_visible then begin
      Result := nil ;
      exit;
    end;
  end ;

  // calculate front attract (points within 3 pixels should
  // more attractive then line or polygons
  if assigned( Viewer ) then
    ptfix := 3 / Viewer.Ref.Zoom
  else
    ptfix := 0 ;

  for j := 0 to FComplexList.Count - 1 do begin
    shp := TGIS_Shape( FComplexList[ j ] ) ;

    if ( not shp.IsHidden ) or ( not _visible ) then begin
      if ( shp is TGIS_ShapePolygon ) and
        ( not GisIsPointInsidePolygon( _ptg, TGIS_ShapePolygon( shp ), -1 ) )
      then
        prec := GIS_MAX_DOUBLE   // point is outside - so we are trying
                                 // to find a distance to the border
      else
        prec := _prec ;

      is_visible := True ;

      if _visible and assigned( Layer ) then begin
        is_visible := Layer.checkParamsCache( shp, 0 ) ;
      end ;

      if is_visible then begin
        for i:= 0 to shp.GetNumParts-1 do begin
          tmp1 := shp.Distance2Part( _ptg, prec, i, proj_ptg ) ;

          case shp.ShapeType of
            TGIS_ShapeType.Point       ,
            TGIS_ShapeType.MultiPoint  : if ptfix = 0 then tmp2 := tmp1 * 0.9
                                                   else tmp2 := tmp1 -ptfix ;
            else                      tmp2 := tmp1 ;
          end ;

          if tmp2 <= dist2 then begin
            // better then previous (or laid on top) - makes it default
            dist     := tmp1     ;
            dist2    := tmp2     ;
            min_uid  := j  ;
            _dist    := dist ;
          end ;
        end ;
      end ;
    end ;
  end;

  if ( dist <= Abs(_prec ) ) and ( min_uid >= 0 ) then
    Result := TGIS_Shape( FComplexList[ min_uid ] )
  else
    Result := nil ;
end ;

{$ENDREGION 'TGIS_ShapeComplex'}

{$REGION 'TGIS_ShapeMultiPatch'}

constructor TGIS_ShapeMultiPatch.Create ;
begin
  Create( nil, nil, False, -1, nil, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeMultiPatch.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Create( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

constructor TGIS_ShapeMultiPatch.Create(
  const _source : TGIS_Shape       ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes       ;
  {$ELSE}
    const _ptr  : Pointer          ;
  {$ENDIF}
  const _mapped : Boolean          ;
  const _uid    : TGIS_Uid            ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Create( _source, _ptr, _mapped, _uid, _layer, _dim ) ;

  FShapeType := TGIS_ShapeType.MultiPatch ;
  FDimension := _dim ;
end ;

constructor TGIS_ShapeMultiPatch.Create(
  const _dim : TGIS_DimensionType
) ;
begin
  Create( nil, nil, False, -1, nil, _dim ) ;
end ;

{$IFNDEF MANAGED}

  destructor TGIS_ShapeMultiPatch.Destroy ;
  begin
    FreeObject( FNormals          ) ;
    FreeObject( FMaterials        ) ;
    FreeObject( FTextures         ) ;
    FreeObject( FPartDescriptors  ) ;
    FreeObject( FVertexColors     ) ;

    inherited ;
  end ;
{$ENDIF}

procedure TGIS_ShapeMultiPatch.Recreate(
  const _source : TGIS_Shape ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes ;
  {$ELSE}
    const _ptr  : Pointer ;
  {$ENDIF}
  const _mapped : Boolean ;
  const _uid    : TGIS_Uid   ;
  const _layer  : TGIS_LayerVector
) ;
begin
  Recreate( _source, _ptr, _mapped, _uid, _layer, TGIS_DimensionType.Unknown ) ;
end ;

procedure TGIS_ShapeMultiPatch.Recreate(
  const _source : TGIS_Shape ;
  {$IFDEF MANAGED}
    const _ptr  : TGIS_Bytes ;
  {$ELSE}
    const _ptr  : Pointer ;
  {$ENDIF}
  const _mapped : Boolean ;
  const _uid    : TGIS_Uid   ;
  const _layer  : TGIS_LayerVector ;
  const _dim    : TGIS_DimensionType
) ;
begin
  inherited Recreate( _source, _ptr, _mapped, _uid, _layer, _dim ) ;

  if not assigned( FMaterials ) then
    FMaterials := TGIS_Materials.Create ;
  if not assigned( FTextures ) then
    FTextures  := TGIS_Textures.Create ;
  if not assigned( FNormals ) then
    FNormals   := TGIS_Normals.Create ;
  if not assigned( FPartDescriptors ) then
    FPartDescriptors := TGIS_PartDescriptors.Create ;
  if not assigned( FVertexColors ) then
    FVertexColors := TGIS_VertexColors.Create ;

  if _source is TGIS_ShapeMultiPatch then begin
    if TGIS_ShapeMultiPatch(_source).HasMaterials then begin
      FMaterials.Assign( TGIS_ShapeMultiPatch(_source).Materials ) ;
      FHasMaterials := True ;
    end ;
    if TGIS_ShapeMultiPatch(_source).HasTextures then begin
      FTextures.Assign( TGIS_ShapeMultiPatch(_source).Textures ) ;
      FHasTextures := True ;
    end ;
    if TGIS_ShapeMultiPatch(_source).HasNormals then begin
      FNormals.Assign( TGIS_ShapeMultiPatch(_source).Normals ) ;
      FHasNormals := True ;
    end ;
    if TGIS_ShapeMultiPatch(_source).HasPartDescriptors then begin
      FPartDescriptors.Assign( TGIS_ShapeMultiPatch(_source).PartDescriptors ) ;
      HasPartDescriptors := True ;
    end ;
    if TGIS_ShapeMultiPatch(_source).HasVertexColors then begin
      FVertexColors.Assign( TGIS_ShapeMultiPatch(_source).VertexColors ) ;
      HasVertexColors := True ;
    end ;
  end ;

end ;

function TGIS_ShapeMultiPatch.fget_SmartSize
  : Integer ;
begin
  Result := inherited fget_SmartSize ;
end;

procedure copy_MultiPatch(
  const _source : TGIS_ShapeMultiPatch ;
  const _dest   : TGIS_ShapeMultiPatch
) ;
begin
  if not assigned( _dest.FMaterials ) then
    _dest.FMaterials := TGIS_Materials.Create ;
  if not assigned( _dest.FTextures ) then
    _dest.FTextures  := TGIS_Textures.Create ;
  if not assigned( _dest.FNormals ) then
    _dest.FNormals   := TGIS_Normals.Create ;
  if not assigned( _dest.FPartDescriptors ) then
    _dest.FPartDescriptors := TGIS_PartDescriptors.Create ;

  if _source.HasMaterials then begin
    _dest.FMaterials.Assign( _source.Materials ) ;
    _dest.FHasMaterials := True ;
  end ;
  if _source.HasTextures then begin
    _dest.FTextures.Assign( _source.Textures ) ;
    _dest.FHasTextures := True ;
  end ;
  if _source.HasNormals then begin
    _dest.FNormals.Assign( _source.Normals ) ;
    _dest.FHasNormals := True ;
  end ;
  if _source.HasPartDescriptors then begin
    _dest.FPartDescriptors.Assign( _source.PartDescriptors ) ;
    _dest.HasPartDescriptors := True ;
  end ;
  if _source.HasVertexColors then begin
    _dest.FVertexColors.Assign( _source.VertexColors ) ;
    _dest.HasVertexColors := True ;
  end ;
end ;

function TGIS_ShapeMultiPatch.getIntersectInternal(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
const
  NEARZERO = 1e-30 ;
var
  p1, p2      : TGIS_Point  ;
  point_no    : Integer     ;
  part_no     : Integer     ;
  part_size   : Integer     ;
  tot_s2area  : Double      ;
  part_s2area : Double      ;
  out_pts     : array of TGIS_Point ;
  idx         : Integer ;
  res         : TGIS_Shape ;
  fp          : TGIS_Point ;

  procedure prepare_result ;
  var
    i  : Integer ;
    pt_origin : TGIS_Point ;
  begin
    part_s2area := 0 ;

    res.AddPart ;
    res.SetPartType( res.GetNumParts-1, GetPartType( part_no ) ) ;
    p1 := _TGIS_Point( out_pts[0] ) ;
    pt_origin := _TGIS_Point( p1 ) ;
    TGIS_ShapeMultiPatch(res).AddPoint(p1);
    p1.X := p1.X - pt_origin.X ; // normalize to avoid big number
    p1.Y := p1.Y - pt_origin.Y ;

    for i := 1 to idx -1 do begin
      p2 := _TGIS_Point( out_pts[i] ) ;
      TGIS_ShapeMultiPatch(res).AddPoint(p2);
      p2.X := p2.X - pt_origin.X ; // normalize to avoid big number
      p2.Y := p2.Y - pt_origin.Y ;
      part_s2area := part_s2area + (p2.Y*p1.X - p1.Y*p2.X) ;
      p1 := _TGIS_Point( p2 ) ;
    end ;

    if ( not GisIsSamePoint(out_pts[idx -1], pt_origin)) or (idx = 1) then
      TGIS_ShapeMultiPatch(res).AddPoint(pt_origin);

    tot_s2area := tot_s2area + part_s2area ;
  end ;

  procedure cut_vector ;
  var
    deltax,deltay,
    xin,xout,
    yin,yout,
    tinx,tiny,
    toutx,touty,
    tin1, tin2, tout1 : Double ;
  begin

    deltax := p2.X - p1.X ;
    if deltax = 0 then begin
      // bump off of the vertical
      if p1.X > _extent.XMin then deltax := -NEARZERO
                             else deltax :=  NEARZERO ;
    end ;

    deltay := p2.Y-p1.Y ;
    if deltay = 0 then begin
      // bump off of the horizontal
      if p1.Y > _extent.YMin then deltay := -NEARZERO
                             else deltay :=  NEARZERO ;
    end ;

    if deltax > 0 then begin
      // points to right
      xin  := _extent.XMin ;
      xout := _extent.XMax ;
    end
    else begin
      xin  := _extent.XMax ;
      xout := _extent.XMin ;
    end ;

    if deltay > 0 then begin
      // points up
      yin  := _extent.YMin ;
      yout := _extent.YMax ;
    end
    else begin
      yin  := _extent.YMax ;
      yout := _extent.YMin ;
    end ;

    if Abs(deltax) < NEARZERO then begin
      if Sign( deltax ) = -1 then
        deltax := -NEARZERO
      else
        deltax :=  NEARZERO ;
    end ;

    if Abs(deltay) < NEARZERO then begin
      if Sign( deltay ) = -1 then
        deltay := -NEARZERO
      else
        deltay :=  NEARZERO ;
    end ;

    tinx := ( xin - p1.X ) / deltax ;
    tiny := ( yin - p1.Y ) / deltay ;

    if tinx < tiny then begin
      // hits x first
      tin1 := tinx ;
      tin2 := tiny ;
    end
    else begin
      // hits y first
      tin1 := tiny ;
      tin2 := tinx ;
    end ;

    if 1 >= tin1 then begin
      if 0 < tin1 then begin
        out_pts[idx] := GisPoint( xin, yin ) ;
        inc( idx ) ;
      end ;
      if 1 >= tin2 then begin
        toutx := ( xout - p1.X ) / deltax ;
        touty := ( yout - p1.Y ) / deltay ;

        if toutx < touty then tout1 := toutx
                         else tout1 := touty ;

        if ( 0 < tin2 ) or ( 0 < tout1 ) then begin
          if tin2 <= tout1 then begin
            if 0 < tin2 then begin
              if tinx > tiny then begin
                out_pts[idx] := GisPoint( xin, p1.Y+tinx*deltay ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint( p1.X + tiny*deltax, yin ) ;
                inc( idx ) ;
              end ;
            end ;
            if 1 > tout1 then begin
              if toutx < touty then begin
                out_pts[idx] := GisPoint( xout, p1.Y+toutx*deltay) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint( p1.X + touty*deltax, yout) ;
                inc( idx ) ;
              end ;
            end
            else begin
              out_pts[idx] := _TGIS_Point( p2 ) ;
              inc( idx ) ;
            end ;
          end
          else begin
            if tinx > tiny then begin
              out_pts[idx] := GisPoint( xin, yout ) ;
              inc( idx ) ;
            end
            else begin
              out_pts[idx] := GisPoint( xout, yin ) ;
              inc( idx ) ;
            end ;
          end ;
        end ;
      end ;
    end ;
  end ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeMultiPatch.Create(nil, nil, False, Uid, Layer ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;
    copy_MultiPatch( TGIS_ShapeMultiPatch(self), TGIS_ShapeMultiPatch(Result) ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      Result.AddPart ;
      Result.SetPartType( part_no, GetPartType( part_no ) ) ;
      part_size := GetPartSize( part_no ) ;
      for point_no := 0 to part_size -2 do  begin
        Result.AddPoint( GetPoint( part_no, point_no ) ) ;
      end ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  res :=  TGIS_ShapeMultiPatch.Create(nil, nil, False, Uid, Layer ) ;

  copyInternalFields( self, res ) ;
  copyInternalParams( self, res ) ;
  copy_MultiPatch( TGIS_ShapeMultiPatch(self), TGIS_ShapeMultiPatch(res) ) ;

  if _lockInternal2 then res.Lock( TGIS_Lock.Internal2 )
                    else res.Lock( TGIS_Lock.Internal  ) ;

  tot_s2area := 0 ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    part_size := GetPartSize( part_no ) ;
    if part_size > 0 then begin
      SetLength(out_pts, 2*part_size +2) ;
      idx := 0 ;

      p1 := GetPoint( part_no, 0 ) ;
      if p1.Y > 1e30 then continue ;
      p2 := _TGIS_Point( p1 ) ;
      fp := _TGIS_Point( p1 ) ;

      cut_vector ;
      for point_no := 1 to part_size -1 do  begin
        // translate all points in the part to screen coordinates
        p2 := GetPoint( part_no, point_no ) ;
        if p2.Y > 1e30 then continue ;
        cut_vector ;
        p1 := _TGIS_Point( p2 ) ;
      end ;

      if not GisIsSamePoint(p1, fp) then begin
        p2 := _TGIS_Point( fp ) ;
        cut_vector ;
      end ;

      if idx > 0 then
        prepare_result ;
    end ;
  end ;

  Result := res ;

  if not Result.IsEmpty then begin
    Result.Unlock ;

    if ( Result.Extent.XMax <= _extent.XMin ) or
       ( Result.Extent.XMin >= _extent.XMax ) or
       ( Result.Extent.YMax <= _extent.YMin ) or
       ( Result.Extent.YMin >= _extent.YMax )
    then
      FreeObject( Result ) ;
  end
  else
    FreeObject( Result ) ;
end ;

function TGIS_ShapeMultiPatch.getIntersectInternal3D(
  const _extent        : TGIS_Extent ;
  const _lockInternal2 : Boolean
) : TGIS_Shape ;
const
  NEARZERO = 1e-30 ;
var
  p1, p2      : TGIS_Point3D  ;
  point_no    : Integer     ;
  part_no     : Integer     ;
  part_size   : Integer     ;
  tot_s2area  : Double      ;
  part_s2area : Double      ;
  out_pts     : array of TGIS_Point3D ;
  idx         : Integer ;
  res         : TGIS_Shape ;
  fp          : TGIS_Point3D ;

  procedure prepare_result ;
  var
    i  : Integer ;
    pt_origin : TGIS_Point3D ;
  begin
    part_s2area := 0 ;

    res.AddPart ;
    res.SetPartType( res.GetNumParts-1, GetPartType( part_no ) ) ;
    p1 := _TGIS_Point3D( out_pts[0] ) ;
    pt_origin := _TGIS_Point3D( p1 ) ;
    TGIS_ShapeMultiPatch(res).AddPoint3D(p1);
    p1.X := p1.X - pt_origin.X ; // normalize to avoid big number
    p1.Y := p1.Y - pt_origin.Y ;
    p1.Z := p1.Z - pt_origin.Z ;
    p1.M := p1.M - pt_origin.M ;

    for i := 1 to idx -1 do begin
      p2 := _TGIS_Point3D( out_pts[i] ) ;
      TGIS_ShapeMultiPatch(res).AddPoint3D(p2);
      p2.X := p2.X - pt_origin.X ; // normalize to avoid big number
      p2.Y := p2.Y - pt_origin.Y ;
      p2.Z := p2.Z - pt_origin.Z ;
      p2.M := p2.M - pt_origin.M ;
      part_s2area := part_s2area + (p2.Y*p1.X - p1.Y*p2.X) ;
      p1 := p2 ;
    end ;

    if ( not GisIsSamePoint(GisPoint(out_pts[idx -1].X, out_pts[idx -1].Y),
                            GisPoint(pt_origin.X, pt_origin.Y)))
      or
       (idx = 1)
    then
      TGIS_ShapeMultiPatch(res).AddPoint3D(pt_origin);

    tot_s2area := tot_s2area + part_s2area ;
  end ;

  procedure cut_vector ;
  var
    deltax,deltay,
    xin,xout,
    yin,yout,
    tinx,tiny,
    toutx,touty,
    tin1, tin2, tout1 : Double ;
  begin

    deltax := p2.X - p1.X ;
    if deltax = 0 then begin
      // bump off of the vertical
      if p1.X > _extent.XMin then deltax := -NEARZERO
                             else deltax :=  NEARZERO ;
    end ;

    deltay := p2.Y-p1.Y ;
    if deltay = 0 then begin
      // bump off of the horizontal
      if p1.Y > _extent.YMin then deltay := -NEARZERO
                             else deltay :=  NEARZERO ;
    end ;

    if deltax > 0 then begin
      // points to right
      xin  := _extent.XMin ;
      xout := _extent.XMax ;
    end
    else begin
      xin  := _extent.XMax ;
      xout := _extent.XMin ;
    end ;

    if deltay > 0 then begin
      // points up
      yin  := _extent.YMin ;
      yout := _extent.YMax ;
    end
    else begin
      yin  := _extent.YMax ;
      yout := _extent.YMin ;
    end ;

    if Abs(deltax) < NEARZERO then begin
      if Sign( deltax ) = -1 then
        deltax := -NEARZERO
      else
        deltax :=  NEARZERO ;
    end ;

    if Abs(deltay) < NEARZERO then begin
      if Sign( deltay ) = -1 then
        deltay := -NEARZERO
      else
        deltay :=  NEARZERO ;
    end ;

    tinx := ( xin - p1.X ) / deltax ;
    tiny := ( yin - p1.Y ) / deltay ;

    if tinx < tiny then begin
      // hits x first
      tin1 := tinx ;
      tin2 := tiny ;
    end
    else begin
      // hits y first
      tin1 := tiny ;
      tin2 := tinx ;
    end ;

    if 1 >= tin1 then begin
      if 0 < tin1 then begin
        out_pts[idx] := GisPoint3D( xin, yin, p1.Z, p1.M ) ;
        inc( idx ) ;
      end ;
      if 1 >= tin2 then begin
        toutx := ( xout - p1.X ) / deltax ;
        touty := ( yout - p1.Y ) / deltay ;

        if toutx < touty then tout1 := toutx
                         else tout1 := touty ;

        if ( 0 < tin2 ) or ( 0 < tout1 ) then begin
          if tin2 <= tout1 then begin
            if 0 < tin2 then begin
              if tinx > tiny then begin
                out_pts[idx] := GisPoint3D( xin, p1.Y+tinx*deltay, p1.Z, p1.M ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint3D( p1.X + tiny*deltax, yin, p1.Z, p1.M  ) ;
                inc( idx ) ;
              end ;
            end ;
            if 1 > tout1 then begin
              if toutx < touty then begin
                out_pts[idx] := GisPoint3D( xout, p1.Y+toutx*deltay, p1.Z, p1.M ) ;
                inc( idx ) ;
              end
              else begin
                out_pts[idx] := GisPoint3D( p1.X + touty*deltax, yout, p1.Z, p1.M ) ;
                inc( idx ) ;
              end ;
            end
            else begin
              out_pts[idx] := _TGIS_Point3D( p2 ) ;
              inc( idx ) ;
            end ;
          end
          else begin
            if tinx > tiny then begin
              out_pts[idx] := GisPoint3D( xin, yout, p1.Z, p1.M ) ;
              inc( idx ) ;
            end
            else begin
              out_pts[idx] := GisPoint3D( xout, yin, p1.Z, p1.M  ) ;
              inc( idx ) ;
            end ;
          end ;
        end ;
      end ;
    end ;
  end ;
begin
  Result := nil ;

  if IsInsideExtent(_extent, TGIS_InsideType.Full) then begin
    Result := TGIS_ShapeMultiPatch.Create(nil, nil, False, Uid, Layer, Dimension ) ;

    copyInternalFields( self, Result ) ;
    copyInternalParams( self, Result ) ;
    copy_MultiPatch( TGIS_ShapeMultiPatch(self), TGIS_ShapeMultiPatch(Result) ) ;

    if _lockInternal2 then Result.Lock( TGIS_Lock.Internal2 )
                      else Result.Lock( TGIS_Lock.Internal  ) ;

    for part_no := 0 to GetNumParts - 1 do begin // all parts
      Result.AddPart ;
      Result.SetPartType( part_no, GetPartType( part_no ) ) ;
      part_size := GetPartSize( part_no ) ;
      for point_no := 0 to part_size -2 do  begin
        Result.AddPoint3D( GetPoint3D( part_no, point_no ) ) ;
      end ;
    end ;

    Result.Unlock ;
    exit ;
  end ;

  res :=  TGIS_ShapeMultiPatch.Create(nil, nil, False, Uid, Layer, Dimension ) ;

  copyInternalFields( self, res ) ;
  copyInternalParams( self, res ) ;
  copy_MultiPatch( TGIS_ShapeMultiPatch(self), TGIS_ShapeMultiPatch(res) ) ;

  if _lockInternal2 then res.Lock( TGIS_Lock.Internal2 )
                    else res.Lock( TGIS_Lock.Internal  ) ;

  tot_s2area := 0 ;

  for part_no := 0 to GetNumParts - 1 do begin // all parts
    part_size := GetPartSize( part_no ) ;
    if part_size > 0 then begin
      SetLength(out_pts, 2*part_size +2) ;
      idx := 0 ;

      p1 := GetPoint3D( part_no, 0 ) ;
      if p1.Y > 1e30 then continue ;
      p2 := _TGIS_Point3D( p1 ) ;
      fp := _TGIS_Point3D( p1 ) ;

      cut_vector ;
      for point_no := 1 to part_size -1 do  begin
        // translate all points in the part to screen coordinates
        p2 := GetPoint3D( part_no, point_no ) ;
        if p2.Y > 1e30 then continue ;
        cut_vector ;
        p1 := _TGIS_Point3D( p2 ) ;
      end ;

      if not GisIsSamePoint(GisPoint(p1.X, p1.Y), GisPoint(fp.X, fp.Y)) then
      begin
        p2 := _TGIS_Point3D( fp ) ;
        cut_vector ;
      end ;

      if idx > 0 then
        prepare_result ;
    end ;
  end ;

  Result := res ;

  if not Result.IsEmpty then begin
    Result.Unlock ;

    if ( Result.Extent.XMax <= _extent.XMin ) or
       ( Result.Extent.XMin >= _extent.XMax ) or
       ( Result.Extent.YMax <= _extent.YMin ) or
       ( Result.Extent.YMin >= _extent.YMax ) or
       ( Result.Area        =  0            )
    then
      FreeObject( Result ) ;
  end
  else
    FreeObject( Result ) ;
end ;

procedure TGIS_ShapeMultiPatch.AddPoint(
  const _ptg : TGIS_Point
) ;
begin
  inherited AddPoint( _ptg ) ;
end;

procedure TGIS_ShapeMultiPatch.AddPoint3D(
  const _ptg : TGIS_Point3D
) ;
begin
  inherited AddPoint3D( _ptg ) ;
end ;

function TGIS_ShapeMultiPatch.Distance2Part(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
begin
  Result := inherited Distance2Part( _ptg, _prec, _part, _proj ) ;
end ;

function TGIS_ShapeMultiPatch.Distance2PartCS(
  const _ptg  : TGIS_Point ;
  const _prec : Double     ;
  const _part : Integer    ;
  var   _proj : TGIS_Point
) : Double ;
begin
  Result := inherited Distance2PartCS( _ptg, _prec, _part, _proj ) ;
end ;

function TGIS_ShapeMultiPatch.Centroid
  : TGIS_Point ;
begin
  Result := inherited Centroid ;
end ;

function TGIS_ShapeMultiPatch.Area
  : Double ;
begin
  Result := inherited Area;
end ;

function TGIS_ShapeMultiPatch.AreaCS
  : Double ;
begin
  Result := inherited AreaCS;
end ;

function TGIS_ShapeMultiPatch.Length
  : Double ;
begin
  Result := inherited Length;
end ;

function TGIS_ShapeMultiPatch.LengthCS
  : Double ;
begin
  Result := inherited LengthCS;
end ;

function TGIS_ShapeMultiPatch.PointOnShape
  : TGIS_Point ;
var
  pt         : TGIS_Point ;
  ipl, pl    : TGIS_ShapeMultiPatch ;
  vp, hp     : Double  ;
  lastvp     : Double  ;
  lasthp     : Double  ;
  l, r, t, b : Double  ;
  onleft     : Boolean ;
  ontop      : Boolean ;
  thesamevp  : Boolean ;
  thesamehp  : Boolean ;
  newext     : TGIS_Extent ;
  ext        : TGIS_Extent ;
  dolock     : Boolean ;
  firsttime  : Boolean ;
begin
  pl  := nil ;

  dolock := lockMode = TGIS_Lock.None ;

  if dolock then
    Lock( TGIS_Lock.Internal ) ;
  try
    pt := Centroid ;

    Result := pt ;
    if GisIsPointInsidePolygon(pt, self) then begin
      exit ;
    end ;

    pl        := self ;
    lastvp    := 0 ;
    lasthp    := 0 ;
    firsttime := True ;

    repeat
      ext := pl.Extent ;

      l := Abs( pt.X     - ext.XMin ) ;
      r := Abs( ext.XMax - pt.X     ) ;
      t := Abs( pt.Y     - ext.YMin ) ;
      b := Abs( ext.YMax - pt.Y     ) ;

      if      l = 0 then begin
                           hp := 0 ;
                           onleft := True ;
                         end
      else if r = 0 then begin
                           hp := GIS_MAX_DOUBLE ;
                           onleft := False ;
                        end
      else if l > r then begin
                           hp := l/r ;
                           onleft := false ;
                         end
      else               begin
                           hp := r/l ;
                           onleft := true ;
                         end ;

      if lasthp = hp then
        thesamehp := true
      else begin
        thesamehp := false ;
        lasthp := hp ;
      end ;

      if      t = 0 then begin
                           vp := 0 ;
                           ontop := True ;
                         end
      else if b = 0 then begin
                           vp := GIS_MAX_DOUBLE ;
                           ontop:= False ;
                         end
      else if t > b then begin
                           vp := t/b ;
                           ontop := false ;
                         end
      else               begin
                           vp := b/t ;
                           ontop := true ;
                         end ;

      if lastvp = vp then
        thesamevp := true
      else begin
        thesamevp := false ;
        lastvp := vp ;
      end ;

      {$IFDEF GIS_NORECORDS}
        newext := new TGIS_Extent ;
      {$ENDIF}

      if (hp > vp) and ((not thesamehp) or thesamevp) then begin
        newext.YMin := ext.YMin ;
        newext.YMax := ext.YMax ;
        if onleft then begin
          newext.XMin := ext.XMin ;
          newext.XMax := pt.X ;
        end
        else begin
          newext.XMin := pt.X ;
          newext.XMax := ext.XMax ;
        end ;
      end
      else begin
        newext.XMin := ext.XMin ;
        newext.XMax := ext.XMax ;
        if ontop then begin
          newext.YMin := ext.YMin ;
          newext.YMax := pt.Y ;
        end
        else begin
          newext.YMin := pt.Y ;
          newext.YMax := ext.YMax ;
        end ;
      end ;

      ipl := TGIS_ShapeMultiPatch( pl.getIntersectInternal( newext, True ) ) ;

      if ipl = nil then begin
        if GisIsPointInsidePolygon(pt, self) then
          Result := pt
        else
          Result := self.GetFirstPoint ;
        exit ;
      end ;

      if not firsttime then
        FreeObject( pl )
      else
        firsttime := False ;

      pl := ipl ;
      pt := ipl.Centroid ;

    until( GisIsPointInsidePolygon( pt, ipl ) ) ;
    Result := pt ;

  finally
    if pl <> self then
      FreeObject( pl ) ;
    if dolock then begin
      Unlock() ;

      if assigned( Layer ) then
        Result := Layer.Project( Result ) ;
    end;
  end;
end ;

function TGIS_ShapeMultiPatch.ExportToGML
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToGML( Self ) ;
end ;

function TGIS_ShapeMultiPatch.ExportToJSON
  : String;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToJSON( Self ) ;
end;

function TGIS_ShapeMultiPatch.ExportToEWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToEWKT( Self ) ;
end ;

procedure TGIS_ShapeMultiPatch.ExportToEWKB(
   var _ewkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPolygonToEWKB( Self, _ewkb ) ;
end ;

function TGIS_ShapeMultiPatch.ExportToWKT
  : String ;
begin
  Result := TGIS_GeometryFactory.GisExportPolygonToWKT( Self ) ;
end ;

procedure TGIS_ShapeMultiPatch.ExportToWKB(
  var _wkb : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPolygonToWKB( Self, _wkb ) ;
end ;

procedure TGIS_ShapeMultiPatch.ExportToGDO(
  var _gdo : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportPolygonToGDO( Self, _gdo ) ;
end ;

procedure TGIS_ShapeMultiPatch.ExportToVAR(
  var _var : OleVariant
) ;
begin
  TGIS_GeometryFactory.GisExportMultiPatchToVAR( self, _var );
end ;

{$ENDREGION 'TGIS_ShapeMultiPatch'}

{$REGION 'initialization / finalization'}
{$IFDEF DCC}
  initialization
  finalization
    FreeObject( oAggregators      );
    FreeObject( oAggregatorsNames );
{$ENDIF}
{$ENDREGION 'initialization / finalization'}

{==================================== END =====================================}
end.
